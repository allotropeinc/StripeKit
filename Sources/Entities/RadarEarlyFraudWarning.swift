// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// An early fraud warning indicates that the card issuer has notified us that a
/// charge may be fraudulent.
/// 
/// Related guide: [Early Fraud Warnings](https://stripe.com/docs/disputes/measuring#early-fraud-warnings).
public struct RadarEarlyFraudWarning: Codable {
    /// An EFW is actionable if it has not received a dispute and has not been fully refunded. You may wish to proactively refund a charge that receives an EFW, in order to avoid receiving a dispute later.
    public var isActionable: Bool
    /// ID of the charge this early fraud warning is for, optionally expanded.
    public var charge: Charge
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public var created: Int
    /// The type of fraud labelled by the issuer. One of `card_never_received`, `fraudulent_card_application`, `made_with_counterfeit_card`, `made_with_lost_card`, `made_with_stolen_card`, `misc`, `unauthorized_use_of_card`.
    public var fraudType: String
    /// Unique identifier for the object.
    public var id: String
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// ID of the Payment Intent this early fraud warning is for, optionally expanded.
    public var paymentIntent: PaymentIntent?

    /// ID of the charge this early fraud warning is for, optionally expanded.
    public final class Charge: Codable {
        public let string: String?
        /// To charge a credit or a debit card, you create a `Charge` object. You can
        /// retrieve and refund individual charges as well as list all charges. Charges
        /// are identified by a unique, random ID.
        /// 
        /// Related guide: [Accept a payment with the Charges API](https://stripe.com/docs/payments/accept-a-payment-charges).
        public let charge: StripeKit.Charge?

        public init(string: String? = nil, charge: StripeKit.Charge? = nil) {
            self.string = string
            self.charge = charge
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.charge = try? container.decode(StripeKit.Charge.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = charge { try container.encode(value) }
        }
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case radarEarlyFraudWarning = "radar.early_fraud_warning"
    }

    /// ID of the Payment Intent this early fraud warning is for, optionally expanded.
    public final class PaymentIntent: Codable {
        public let string: String?
        /// A PaymentIntent guides you through the process of collecting a payment from your customer.
        /// We recommend that you create exactly one PaymentIntent for each order or
        /// customer session in your system. You can reference the PaymentIntent later to
        /// see the history of payment attempts for a particular session.
        /// 
        /// A PaymentIntent transitions through
        /// [multiple statuses](https://stripe.com/docs/payments/intents#intent-statuses)
        /// throughout its lifetime as it interfaces with Stripe.js to perform
        /// authentication flows and ultimately creates at most one successful charge.
        /// 
        /// Related guide: [Payment Intents API](https://stripe.com/docs/payments/payment-intents).
        public let paymentIntent: StripeKit.PaymentIntent?

        public init(string: String? = nil, paymentIntent: StripeKit.PaymentIntent? = nil) {
            self.string = string
            self.paymentIntent = paymentIntent
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.paymentIntent = try? container.decode(StripeKit.PaymentIntent.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = paymentIntent { try container.encode(value) }
        }
    }

    public init(isActionable: Bool, charge: Charge, created: Int, fraudType: String, id: String, isLivemode: Bool, object: Object, paymentIntent: PaymentIntent? = nil) {
        self.isActionable = isActionable
        self.charge = charge
        self.created = created
        self.fraudType = fraudType
        self.id = id
        self.isLivemode = isLivemode
        self.object = object
        self.paymentIntent = paymentIntent
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.isActionable = try values.decode(Bool.self, forKey: "actionable")
        self.charge = try values.decode(Charge.self, forKey: "charge")
        self.created = try values.decode(Int.self, forKey: "created")
        self.fraudType = try values.decode(String.self, forKey: "fraud_type")
        self.id = try values.decode(String.self, forKey: "id")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.object = try values.decode(Object.self, forKey: "object")
        self.paymentIntent = try values.decodeIfPresent(PaymentIntent.self, forKey: "payment_intent")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(isActionable, forKey: "actionable")
        try values.encode(charge, forKey: "charge")
        try values.encode(created, forKey: "created")
        try values.encode(fraudType, forKey: "fraud_type")
        try values.encode(id, forKey: "id")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(paymentIntent, forKey: "payment_intent")
    }
}
