// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct PlanTier: Codable {
    /// Price for the entire tier.
    public var flatAmount: Int?
    /// Same as `flat_amount`, but contains a decimal value with at most 12 decimal places.
    public var flatAmountDecimal: String?
    /// Per unit price for units relevant to the tier.
    public var unitAmount: Int?
    /// Same as `unit_amount`, but contains a decimal value with at most 12 decimal places.
    public var unitAmountDecimal: String?
    /// Up to and including to this quantity will be contained in the tier.
    public var upTo: Int?

    public init(flatAmount: Int? = nil, flatAmountDecimal: String? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil, upTo: Int? = nil) {
        self.flatAmount = flatAmount
        self.flatAmountDecimal = flatAmountDecimal
        self.unitAmount = unitAmount
        self.unitAmountDecimal = unitAmountDecimal
        self.upTo = upTo
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.flatAmount = try values.decodeIfPresent(Int.self, forKey: "flat_amount")
        self.flatAmountDecimal = try values.decodeIfPresent(String.self, forKey: "flat_amount_decimal")
        self.unitAmount = try values.decodeIfPresent(Int.self, forKey: "unit_amount")
        self.unitAmountDecimal = try values.decodeIfPresent(String.self, forKey: "unit_amount_decimal")
        self.upTo = try values.decodeIfPresent(Int.self, forKey: "up_to")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(flatAmount, forKey: "flat_amount")
        try values.encodeIfPresent(flatAmountDecimal, forKey: "flat_amount_decimal")
        try values.encodeIfPresent(unitAmount, forKey: "unit_amount")
        try values.encodeIfPresent(unitAmountDecimal, forKey: "unit_amount_decimal")
        try values.encodeIfPresent(upTo, forKey: "up_to")
    }
}
