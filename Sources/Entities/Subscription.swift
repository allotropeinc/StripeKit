// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Subscriptions allow you to charge a customer on a recurring basis.
/// 
/// Related guide: [Creating Subscriptions](https://stripe.com/docs/billing/subscriptions/creating).
public struct Subscription: Codable {
    /// ID of the Connect Application that created the subscription.
    public var application: Application?
    /// A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account.
    public var applicationFeePercent: Double?
    /// SubscriptionAutomaticTax
    public var automaticTax: SubscriptionAutomaticTax
    /// Determines the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices. The timestamp is in UTC format.
    public var billingCycleAnchor: Int
    /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period
    public var billingThresholds: SubscriptionBillingThresholds?
    /// A date in the future at which the subscription will automatically get canceled
    public var cancelAt: Int?
    /// If the subscription has been canceled with the `at_period_end` flag set to `true`, `cancel_at_period_end` on the subscription will be true. You can use this attribute to determine whether a subscription that has a status of active is scheduled to be canceled at the end of the current period.
    public var isCancelAtPeriodEnd: Bool
    /// If the subscription has been canceled, the date of that cancellation. If the subscription was canceled with `cancel_at_period_end`, `canceled_at` will reflect the time of the most recent update request, not the end of the subscription period when the subscription is automatically moved to a canceled state.
    public var canceledAt: Int?
    /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions.
    public var collectionMethod: CollectionMethod
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public var created: Int
    /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    public var currency: String?
    /// End of the current period that the subscription has been invoiced for. At the end of this period, a new invoice will be created.
    public var currentPeriodEnd: Int
    /// Start of the current period that the subscription has been invoiced for.
    public var currentPeriodStart: Int
    /// ID of the customer who owns the subscription.
    public var customer: Customer
    /// Number of days a customer has to pay invoices generated by this subscription. This value will be `null` for subscriptions where `collection_method=charge_automatically`.
    public var daysUntilDue: Int?
    /// ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over `default_source`. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    public var defaultPaymentMethod: DefaultPaymentMethod?
    /// ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If `default_payment_method` is also set, `default_payment_method` will take precedence. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    public var defaultSource: DefaultSource?
    /// The tax rates that will apply to any subscription item that does not have `tax_rates` set. Invoices created will have their `default_tax_rates` populated from the subscription.
    public var defaultTaxRates: [TaxRate]?
    /// The subscription's description, meant to be displayable to the customer. Use this field to optionally store an explanation of the subscription for rendering in Stripe surfaces.
    public var description: String?
    /// Describes the current discount applied to this subscription, if there is one. When billing, a discount applied to a subscription overrides a discount applied on a customer-wide basis.
    public var discount: Discount?
    /// If the subscription has ended, the date the subscription ended.
    public var endedAt: Int?
    /// Unique identifier for the object.
    public var id: String
    /// SubscriptionItemList
    ///
    /// List of subscription items, each with an attached price.
    public var items: Items
    /// The most recent invoice this subscription has generated.
    public var latestInvoice: LatestInvoice?
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    public var metadata: [String: String]
    /// Specifies the approximate timestamp on which any pending invoice items will be billed according to the schedule provided at `pending_invoice_item_interval`.
    public var nextPendingInvoiceItemInvoice: Int?
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// If specified, payment collection for this subscription will be paused.
    public var pauseCollection: SubscriptionsResourcePauseCollection?
    /// Payment settings passed on to invoices created by the subscription.
    public var paymentSettings: SubscriptionsResourcePaymentSettings?
    /// Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling [Create an invoice](https://stripe.com/docs/api#create_invoice) for the given subscription at the specified interval.
    public var pendingInvoiceItemInterval: SubscriptionPendingInvoiceItemInterval?
    /// You can use this [SetupIntent](https://stripe.com/docs/api/setup_intents) to collect user authentication when creating a subscription without immediate payment or updating a subscription's payment method, allowing you to optimize for off-session payments. Learn more in the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication#scenario-2).
    public var pendingSetupIntent: PendingSetupIntent?
    /// If specified, [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates) that will be applied to the subscription once the `latest_invoice` has been paid.
    public var pendingUpdate: SubscriptionsResourcePendingUpdate?
    /// The schedule attached to the subscription
    public var schedule: Schedule?
    /// Date when the subscription was first created. The date might differ from the `created` date due to backdating.
    public var startDate: Int
    /// Possible values are `incomplete`, `incomplete_expired`, `trialing`, `active`, `past_due`, `canceled`, or `unpaid`. 
    /// 
    /// For `collection_method=charge_automatically` a subscription moves into `incomplete` if the initial payment attempt fails. A subscription in this state can only have metadata and default_source updated. Once the first invoice is paid, the subscription moves into an `active` state. If the first invoice is not paid within 23 hours, the subscription transitions to `incomplete_expired`. This is a terminal state, the open invoice will be voided and no further invoices will be generated. 
    /// 
    /// A subscription that is currently in a trial period is `trialing` and moves to `active` when the trial period is over. 
    /// 
    /// If subscription `collection_method=charge_automatically` it becomes `past_due` when payment to renew it fails and `canceled` or `unpaid` (depending on your subscriptions settings) when Stripe has exhausted all payment retry attempts. 
    /// 
    /// If subscription `collection_method=send_invoice` it becomes `past_due` when its invoice is not paid by the due date, and `canceled` or `unpaid` if it is still not paid by an additional deadline after that. Note that when a subscription has a status of `unpaid`, no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed). After receiving updated payment information from a customer, you may choose to reopen and pay their closed invoices.
    public var status: Status
    /// ID of the test clock this subscription belongs to.
    public var testClock: TestClock?
    /// The account (if any) the subscription's payments will be attributed to for tax reporting, and where funds from each payment will be transferred to for each of the subscription's invoices.
    public var transferData: SubscriptionTransferData?
    /// If the subscription has a trial, the end of that trial.
    public var trialEnd: Int?
    /// If the subscription has a trial, the beginning of that trial.
    public var trialStart: Int?

    /// ID of the Connect Application that created the subscription.
    public final class Application: Codable {
        public let string: String?
        public let application: StripeKit.Application?
        public let deletedApplication: DeletedApplication?

        public init(string: String? = nil, application: StripeKit.Application? = nil, deletedApplication: DeletedApplication? = nil) {
            self.string = string
            self.application = application
            self.deletedApplication = deletedApplication
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.application = try? container.decode(StripeKit.Application.self)
            self.deletedApplication = try? container.decode(DeletedApplication.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = application { try container.encode(value) }
            if let value = deletedApplication { try container.encode(value) }
        }
    }

    /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions.
    public enum CollectionMethod: String, Codable, CaseIterable {
        case chargeAutomatically = "charge_automatically"
        case sendInvoice = "send_invoice"
    }

    /// ID of the customer who owns the subscription.
    public final class Customer: Codable {
        public let string: String?
        /// This object represents a customer of your business. It lets you create recurring charges and track payments that belong to the same customer.
        /// 
        /// Related guide: [Save a card during payment](https://stripe.com/docs/payments/save-during-payment).
        public let customer: StripeKit.Customer?
        public let deletedCustomer: DeletedCustomer?

        public init(string: String? = nil, customer: StripeKit.Customer? = nil, deletedCustomer: DeletedCustomer? = nil) {
            self.string = string
            self.customer = customer
            self.deletedCustomer = deletedCustomer
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.customer = try? container.decode(StripeKit.Customer.self)
            self.deletedCustomer = try? container.decode(DeletedCustomer.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = customer { try container.encode(value) }
            if let value = deletedCustomer { try container.encode(value) }
        }
    }

    /// ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over `default_source`. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    public struct DefaultPaymentMethod: Codable {
        public var string: String?
        /// PaymentMethod objects represent your customer's payment instruments.
        /// You can use them with [PaymentIntents](https://stripe.com/docs/payments/payment-intents) to collect payments or save them to
        /// Customer objects to store instrument details for future payments.
        /// 
        /// Related guides: [Payment Methods](https://stripe.com/docs/payments/payment-methods) and [More Payment Scenarios](https://stripe.com/docs/payments/more-payment-scenarios).
        public var paymentMethod: PaymentMethod?

        public init(string: String? = nil, paymentMethod: PaymentMethod? = nil) {
            self.string = string
            self.paymentMethod = paymentMethod
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.paymentMethod = try? container.decode(PaymentMethod.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = paymentMethod { try container.encode(value) }
        }
    }

    /// ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If `default_payment_method` is also set, `default_payment_method` will take precedence. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    public struct DefaultSource: Codable {
        public var string: String?
        /// These bank accounts are payment methods on `Customer` objects.
        /// 
        /// On the other hand [External Accounts](https://stripe.com/docs/api#external_accounts) are transfer
        /// destinations on `Account` objects for [Custom accounts](https://stripe.com/docs/connect/custom-accounts).
        /// They can be bank accounts or debit cards as well, and are documented in the links above.
        /// 
        /// Related guide: [Bank Debits and Transfers](https://stripe.com/docs/payments/bank-debits-transfers).
        public var bankAccount: BankAccount?
        /// You can store multiple cards on a customer in order to charge the customer
        /// later. You can also store multiple debit cards on a recipient in order to
        /// transfer to those cards later.
        /// 
        /// Related guide: [Card Payments with Sources](https://stripe.com/docs/sources/cards).
        public var card: Card?
        /// `Source` objects allow you to accept a variety of payment methods. They
        /// represent a customer's payment instrument, and can be used with the Stripe API
        /// just like a `Card` object: once chargeable, they can be charged, or can be
        /// attached to customers.
        /// 
        /// Related guides: [Sources API](https://stripe.com/docs/sources) and [Sources & Customers](https://stripe.com/docs/sources/customers).
        public var source: Source?

        public init(string: String? = nil, bankAccount: BankAccount? = nil, card: Card? = nil, source: Source? = nil) {
            self.string = string
            self.bankAccount = bankAccount
            self.card = card
            self.source = source
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.bankAccount = try? container.decode(BankAccount.self)
            self.card = try? container.decode(Card.self)
            self.source = try? container.decode(Source.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = bankAccount { try container.encode(value) }
            if let value = card { try container.encode(value) }
            if let value = source { try container.encode(value) }
        }
    }

    /// SubscriptionItemList
    ///
    /// List of subscription items, each with an attached price.
    public struct Items: Codable {
        /// Details about each object.
        public var data: [SubscriptionItem]
        /// True if this list has another page of items after this one that can be fetched.
        public var hasMore: Bool
        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public var object: Object
        /// The URL where this list can be accessed.
        public var url: String

        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public enum Object: String, Codable, CaseIterable {
            case list
        }

        public init(data: [SubscriptionItem], hasMore: Bool, object: Object, url: String) {
            self.data = data
            self.hasMore = hasMore
            self.object = object
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.data = try values.decode([SubscriptionItem].self, forKey: "data")
            self.hasMore = try values.decode(Bool.self, forKey: "has_more")
            self.object = try values.decode(Object.self, forKey: "object")
            self.url = try values.decode(String.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(data, forKey: "data")
            try values.encode(hasMore, forKey: "has_more")
            try values.encode(object, forKey: "object")
            try values.encode(url, forKey: "url")
        }
    }

    /// The most recent invoice this subscription has generated.
    public struct LatestInvoice: Codable {
        public var string: String?
        /// Invoices are statements of amounts owed by a customer, and are either
        /// generated one-off, or generated periodically from a subscription.
        /// 
        /// They contain [invoice items](https://stripe.com/docs/api#invoiceitems), and proration adjustments
        /// that may be caused by subscription upgrades/downgrades (if necessary).
        /// 
        /// If your invoice is configured to be billed through automatic charges,
        /// Stripe automatically finalizes your invoice and attempts payment. Note
        /// that finalizing the invoice,
        /// [when automatic](https://stripe.com/docs/billing/invoices/workflow/#auto_advance), does
        /// not happen immediately as the invoice is created. Stripe waits
        /// until one hour after the last webhook was successfully sent (or the last
        /// webhook timed out after failing). If you (and the platforms you may have
        /// connected to) have no webhooks configured, Stripe waits one hour after
        /// creation to finalize the invoice.
        /// 
        /// If your invoice is configured to be billed by sending an email, then based on your
        /// [email settings](https://dashboard.stripe.com/account/billing/automatic),
        /// Stripe will email the invoice to your customer and await payment. These
        /// emails can contain a link to a hosted page to pay the invoice.
        /// 
        /// Stripe applies any customer credit on the account before determining the
        /// amount due for the invoice (i.e., the amount that will be actually
        /// charged). If the amount due for the invoice is less than Stripe's [minimum allowed charge
        /// per currency](/docs/currencies#minimum-and-maximum-charge-amounts), the
        /// invoice is automatically marked paid, and we add the amount due to the
        /// customer's credit balance which is applied to the next invoice.
        /// 
        /// More details on the customer's credit balance are
        /// [here](https://stripe.com/docs/billing/customer/balance).
        /// 
        /// Related guide: [Send Invoices to Customers](https://stripe.com/docs/billing/invoices/sending).
        public var invoice: Invoice?

        public init(string: String? = nil, invoice: Invoice? = nil) {
            self.string = string
            self.invoice = invoice
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.invoice = try? container.decode(Invoice.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = invoice { try container.encode(value) }
        }
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case subscription
    }

    /// You can use this [SetupIntent](https://stripe.com/docs/api/setup_intents) to collect user authentication when creating a subscription without immediate payment or updating a subscription's payment method, allowing you to optimize for off-session payments. Learn more in the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication#scenario-2).
    public struct PendingSetupIntent: Codable {
        public var string: String?
        /// A SetupIntent guides you through the process of setting up and saving a customer's payment credentials for future payments.
        /// For example, you could use a SetupIntent to set up and save your customer's card without immediately collecting a payment.
        /// Later, you can use [PaymentIntents](https://stripe.com/docs/api#payment_intents) to drive the payment flow.
        /// 
        /// Create a SetupIntent as soon as you're ready to collect your customer's payment credentials.
        /// Do not maintain long-lived, unconfirmed SetupIntents as they may no longer be valid.
        /// The SetupIntent then transitions through multiple [statuses](https://stripe.com/docs/payments/intents#intent-statuses) as it guides
        /// you through the setup process.
        /// 
        /// Successful SetupIntents result in payment credentials that are optimized for future payments.
        /// For example, cardholders in [certain regions](/guides/strong-customer-authentication) may need to be run through
        /// [Strong Customer Authentication](https://stripe.com/docs/strong-customer-authentication) at the time of payment method collection
        /// in order to streamline later [off-session payments](https://stripe.com/docs/payments/setup-intents).
        /// If the SetupIntent is used with a [Customer](https://stripe.com/docs/api#setup_intent_object-customer), upon success,
        /// it will automatically attach the resulting payment method to that Customer.
        /// We recommend using SetupIntents or [setup_future_usage](https://stripe.com/docs/api#payment_intent_object-setup_future_usage) on
        /// PaymentIntents to save payment methods in order to prevent saving invalid or unoptimized payment methods.
        /// 
        /// By using SetupIntents, you ensure that your customers experience the minimum set of required friction,
        /// even as regulations change over time.
        /// 
        /// Related guide: [Setup Intents API](https://stripe.com/docs/payments/setup-intents).
        public var setupIntent: SetupIntent?

        public init(string: String? = nil, setupIntent: SetupIntent? = nil) {
            self.string = string
            self.setupIntent = setupIntent
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.setupIntent = try? container.decode(SetupIntent.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = setupIntent { try container.encode(value) }
        }
    }

    /// The schedule attached to the subscription
    public struct Schedule: Codable {
        public var string: String?
        /// A subscription schedule allows you to create and manage the lifecycle of a subscription by predefining expected changes.
        /// 
        /// Related guide: [Subscription Schedules](https://stripe.com/docs/billing/subscriptions/subscription-schedules).
        public var subscriptionSchedule: SubscriptionSchedule?

        public init(string: String? = nil, subscriptionSchedule: SubscriptionSchedule? = nil) {
            self.string = string
            self.subscriptionSchedule = subscriptionSchedule
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.subscriptionSchedule = try? container.decode(SubscriptionSchedule.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = subscriptionSchedule { try container.encode(value) }
        }
    }

    /// Possible values are `incomplete`, `incomplete_expired`, `trialing`, `active`, `past_due`, `canceled`, or `unpaid`. 
    /// 
    /// For `collection_method=charge_automatically` a subscription moves into `incomplete` if the initial payment attempt fails. A subscription in this state can only have metadata and default_source updated. Once the first invoice is paid, the subscription moves into an `active` state. If the first invoice is not paid within 23 hours, the subscription transitions to `incomplete_expired`. This is a terminal state, the open invoice will be voided and no further invoices will be generated. 
    /// 
    /// A subscription that is currently in a trial period is `trialing` and moves to `active` when the trial period is over. 
    /// 
    /// If subscription `collection_method=charge_automatically` it becomes `past_due` when payment to renew it fails and `canceled` or `unpaid` (depending on your subscriptions settings) when Stripe has exhausted all payment retry attempts. 
    /// 
    /// If subscription `collection_method=send_invoice` it becomes `past_due` when its invoice is not paid by the due date, and `canceled` or `unpaid` if it is still not paid by an additional deadline after that. Note that when a subscription has a status of `unpaid`, no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed). After receiving updated payment information from a customer, you may choose to reopen and pay their closed invoices.
    public enum Status: String, Codable, CaseIterable {
        case active
        case canceled
        case incomplete
        case incompleteExpired = "incomplete_expired"
        case pastDue = "past_due"
        case trialing
        case unpaid
    }

    /// ID of the test clock this subscription belongs to.
    public struct TestClock: Codable {
        public var string: String?
        /// TestClock
        ///
        /// A test clock enables deterministic control over objects in testmode. With a test clock, you can create
        /// objects at a frozen time in the past or future, and advance to a specific future time to observe webhooks and state changes. After the clock advances,
        /// you can either validate the current state of your scenario (and test your assumptions), change the current state of your scenario (and test more complex scenarios), or keep advancing forward in time.
        public var testHelpersTestClock: TestHelpersTestClock?

        public init(string: String? = nil, testHelpersTestClock: TestHelpersTestClock? = nil) {
            self.string = string
            self.testHelpersTestClock = testHelpersTestClock
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.testHelpersTestClock = try? container.decode(TestHelpersTestClock.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = testHelpersTestClock { try container.encode(value) }
        }
    }

    public init(application: Application? = nil, applicationFeePercent: Double? = nil, automaticTax: SubscriptionAutomaticTax, billingCycleAnchor: Int, billingThresholds: SubscriptionBillingThresholds? = nil, cancelAt: Int? = nil, isCancelAtPeriodEnd: Bool, canceledAt: Int? = nil, collectionMethod: CollectionMethod, created: Int, currency: String? = nil, currentPeriodEnd: Int, currentPeriodStart: Int, customer: Customer, daysUntilDue: Int? = nil, defaultPaymentMethod: DefaultPaymentMethod? = nil, defaultSource: DefaultSource? = nil, defaultTaxRates: [TaxRate]? = nil, description: String? = nil, discount: Discount? = nil, endedAt: Int? = nil, id: String, items: Items, latestInvoice: LatestInvoice? = nil, isLivemode: Bool, metadata: [String: String], nextPendingInvoiceItemInvoice: Int? = nil, object: Object, pauseCollection: SubscriptionsResourcePauseCollection? = nil, paymentSettings: SubscriptionsResourcePaymentSettings? = nil, pendingInvoiceItemInterval: SubscriptionPendingInvoiceItemInterval? = nil, pendingSetupIntent: PendingSetupIntent? = nil, pendingUpdate: SubscriptionsResourcePendingUpdate? = nil, schedule: Schedule? = nil, startDate: Int, status: Status, testClock: TestClock? = nil, transferData: SubscriptionTransferData? = nil, trialEnd: Int? = nil, trialStart: Int? = nil) {
        self.application = application
        self.applicationFeePercent = applicationFeePercent
        self.automaticTax = automaticTax
        self.billingCycleAnchor = billingCycleAnchor
        self.billingThresholds = billingThresholds
        self.cancelAt = cancelAt
        self.isCancelAtPeriodEnd = isCancelAtPeriodEnd
        self.canceledAt = canceledAt
        self.collectionMethod = collectionMethod
        self.created = created
        self.currency = currency
        self.currentPeriodEnd = currentPeriodEnd
        self.currentPeriodStart = currentPeriodStart
        self.customer = customer
        self.daysUntilDue = daysUntilDue
        self.defaultPaymentMethod = defaultPaymentMethod
        self.defaultSource = defaultSource
        self.defaultTaxRates = defaultTaxRates
        self.description = description
        self.discount = discount
        self.endedAt = endedAt
        self.id = id
        self.items = items
        self.latestInvoice = latestInvoice
        self.isLivemode = isLivemode
        self.metadata = metadata
        self.nextPendingInvoiceItemInvoice = nextPendingInvoiceItemInvoice
        self.object = object
        self.pauseCollection = pauseCollection
        self.paymentSettings = paymentSettings
        self.pendingInvoiceItemInterval = pendingInvoiceItemInterval
        self.pendingSetupIntent = pendingSetupIntent
        self.pendingUpdate = pendingUpdate
        self.schedule = schedule
        self.startDate = startDate
        self.status = status
        self.testClock = testClock
        self.transferData = transferData
        self.trialEnd = trialEnd
        self.trialStart = trialStart
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.application = try values.decodeIfPresent(Application.self, forKey: "application")
        self.applicationFeePercent = try values.decodeIfPresent(Double.self, forKey: "application_fee_percent")
        self.automaticTax = try values.decode(SubscriptionAutomaticTax.self, forKey: "automatic_tax")
        self.billingCycleAnchor = try values.decode(Int.self, forKey: "billing_cycle_anchor")
        self.billingThresholds = try values.decodeIfPresent(SubscriptionBillingThresholds.self, forKey: "billing_thresholds")
        self.cancelAt = try values.decodeIfPresent(Int.self, forKey: "cancel_at")
        self.isCancelAtPeriodEnd = try values.decode(Bool.self, forKey: "cancel_at_period_end")
        self.canceledAt = try values.decodeIfPresent(Int.self, forKey: "canceled_at")
        self.collectionMethod = try values.decode(CollectionMethod.self, forKey: "collection_method")
        self.created = try values.decode(Int.self, forKey: "created")
        self.currency = try values.decodeIfPresent(String.self, forKey: "currency")
        self.currentPeriodEnd = try values.decode(Int.self, forKey: "current_period_end")
        self.currentPeriodStart = try values.decode(Int.self, forKey: "current_period_start")
        self.customer = try values.decode(Customer.self, forKey: "customer")
        self.daysUntilDue = try values.decodeIfPresent(Int.self, forKey: "days_until_due")
        self.defaultPaymentMethod = try values.decodeIfPresent(DefaultPaymentMethod.self, forKey: "default_payment_method")
        self.defaultSource = try values.decodeIfPresent(DefaultSource.self, forKey: "default_source")
        self.defaultTaxRates = try values.decodeIfPresent([TaxRate].self, forKey: "default_tax_rates")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.discount = try values.decodeIfPresent(Discount.self, forKey: "discount")
        self.endedAt = try values.decodeIfPresent(Int.self, forKey: "ended_at")
        self.id = try values.decode(String.self, forKey: "id")
        self.items = try values.decode(Items.self, forKey: "items")
        self.latestInvoice = try values.decodeIfPresent(LatestInvoice.self, forKey: "latest_invoice")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.metadata = try values.decode([String: String].self, forKey: "metadata")
        self.nextPendingInvoiceItemInvoice = try values.decodeIfPresent(Int.self, forKey: "next_pending_invoice_item_invoice")
        self.object = try values.decode(Object.self, forKey: "object")
        self.pauseCollection = try values.decodeIfPresent(SubscriptionsResourcePauseCollection.self, forKey: "pause_collection")
        self.paymentSettings = try values.decodeIfPresent(SubscriptionsResourcePaymentSettings.self, forKey: "payment_settings")
        self.pendingInvoiceItemInterval = try values.decodeIfPresent(SubscriptionPendingInvoiceItemInterval.self, forKey: "pending_invoice_item_interval")
        self.pendingSetupIntent = try values.decodeIfPresent(PendingSetupIntent.self, forKey: "pending_setup_intent")
        self.pendingUpdate = try values.decodeIfPresent(SubscriptionsResourcePendingUpdate.self, forKey: "pending_update")
        self.schedule = try values.decodeIfPresent(Schedule.self, forKey: "schedule")
        self.startDate = try values.decode(Int.self, forKey: "start_date")
        self.status = try values.decode(Status.self, forKey: "status")
        self.testClock = try values.decodeIfPresent(TestClock.self, forKey: "test_clock")
        self.transferData = try values.decodeIfPresent(SubscriptionTransferData.self, forKey: "transfer_data")
        self.trialEnd = try values.decodeIfPresent(Int.self, forKey: "trial_end")
        self.trialStart = try values.decodeIfPresent(Int.self, forKey: "trial_start")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(application, forKey: "application")
        try values.encodeIfPresent(applicationFeePercent, forKey: "application_fee_percent")
        try values.encode(automaticTax, forKey: "automatic_tax")
        try values.encode(billingCycleAnchor, forKey: "billing_cycle_anchor")
        try values.encodeIfPresent(billingThresholds, forKey: "billing_thresholds")
        try values.encodeIfPresent(cancelAt, forKey: "cancel_at")
        try values.encode(isCancelAtPeriodEnd, forKey: "cancel_at_period_end")
        try values.encodeIfPresent(canceledAt, forKey: "canceled_at")
        try values.encode(collectionMethod, forKey: "collection_method")
        try values.encode(created, forKey: "created")
        try values.encodeIfPresent(currency, forKey: "currency")
        try values.encode(currentPeriodEnd, forKey: "current_period_end")
        try values.encode(currentPeriodStart, forKey: "current_period_start")
        try values.encode(customer, forKey: "customer")
        try values.encodeIfPresent(daysUntilDue, forKey: "days_until_due")
        try values.encodeIfPresent(defaultPaymentMethod, forKey: "default_payment_method")
        try values.encodeIfPresent(defaultSource, forKey: "default_source")
        try values.encodeIfPresent(defaultTaxRates, forKey: "default_tax_rates")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(discount, forKey: "discount")
        try values.encodeIfPresent(endedAt, forKey: "ended_at")
        try values.encode(id, forKey: "id")
        try values.encode(items, forKey: "items")
        try values.encodeIfPresent(latestInvoice, forKey: "latest_invoice")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encode(metadata, forKey: "metadata")
        try values.encodeIfPresent(nextPendingInvoiceItemInvoice, forKey: "next_pending_invoice_item_invoice")
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(pauseCollection, forKey: "pause_collection")
        try values.encodeIfPresent(paymentSettings, forKey: "payment_settings")
        try values.encodeIfPresent(pendingInvoiceItemInterval, forKey: "pending_invoice_item_interval")
        try values.encodeIfPresent(pendingSetupIntent, forKey: "pending_setup_intent")
        try values.encodeIfPresent(pendingUpdate, forKey: "pending_update")
        try values.encodeIfPresent(schedule, forKey: "schedule")
        try values.encode(startDate, forKey: "start_date")
        try values.encode(status, forKey: "status")
        try values.encodeIfPresent(testClock, forKey: "test_clock")
        try values.encodeIfPresent(transferData, forKey: "transfer_data")
        try values.encodeIfPresent(trialEnd, forKey: "trial_end")
        try values.encodeIfPresent(trialStart, forKey: "trial_start")
    }
}
