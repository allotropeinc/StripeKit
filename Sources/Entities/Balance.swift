// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// This is an object representing your Stripe balance. You can retrieve it to see
/// the balance currently on your Stripe account.
/// 
/// You can also retrieve the balance history, which contains a list of
/// [transactions](https://stripe.com/docs/reporting/balance-transaction-types) that contributed to the balance
/// (charges, payouts, and so forth).
/// 
/// The available and pending amounts for each currency are broken down further by
/// payment source types.
/// 
/// Related guide: [Understanding Connect Account Balances](https://stripe.com/docs/connect/account-balances).
public struct Balance: Codable {
    /// Funds that are available to be transferred or paid out, whether automatically by Stripe or explicitly via the [Transfers API](https://stripe.com/docs/api#transfers) or [Payouts API](https://stripe.com/docs/api#payouts). The available balance for each currency and payment type can be found in the `source_types` property.
    public var available: [BalanceAmount]
    /// Funds held due to negative balances on connected Custom accounts. The connect reserve balance for each currency and payment type can be found in the `source_types` property.
    public var connectReserved: [BalanceAmount]?
    /// Funds that can be paid out using Instant Payouts.
    public var instantAvailable: [BalanceAmount]?
    /// BalanceDetail
    public var issuing: BalanceDetail?
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// Funds that are not yet available in the balance, due to the 7-day rolling pay cycle. The pending balance for each currency, and for each payment type, can be found in the `source_types` property.
    public var pending: [BalanceAmount]

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case balance
    }

    public init(available: [BalanceAmount], connectReserved: [BalanceAmount]? = nil, instantAvailable: [BalanceAmount]? = nil, issuing: BalanceDetail? = nil, isLivemode: Bool, object: Object, pending: [BalanceAmount]) {
        self.available = available
        self.connectReserved = connectReserved
        self.instantAvailable = instantAvailable
        self.issuing = issuing
        self.isLivemode = isLivemode
        self.object = object
        self.pending = pending
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.available = try values.decode([BalanceAmount].self, forKey: "available")
        self.connectReserved = try values.decodeIfPresent([BalanceAmount].self, forKey: "connect_reserved")
        self.instantAvailable = try values.decodeIfPresent([BalanceAmount].self, forKey: "instant_available")
        self.issuing = try values.decodeIfPresent(BalanceDetail.self, forKey: "issuing")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.object = try values.decode(Object.self, forKey: "object")
        self.pending = try values.decode([BalanceAmount].self, forKey: "pending")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(available, forKey: "available")
        try values.encodeIfPresent(connectReserved, forKey: "connect_reserved")
        try values.encodeIfPresent(instantAvailable, forKey: "instant_available")
        try values.encodeIfPresent(issuing, forKey: "issuing")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encode(object, forKey: "object")
        try values.encode(pending, forKey: "pending")
    }
}
