// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct OrdersV2ResourcePayment: Codable {
    /// ID of the payment intent associated with this order. Null when the order is `open`.
    public var paymentIntent: PaymentIntent?
    /// Settings describing how the order should configure generated PaymentIntents.
    public var settings: OrdersV2ResourcePaymentSettings?
    /// The status of the underlying payment associated with this order, if any. Null when the order is `open`.
    public var status: Status?

    /// ID of the payment intent associated with this order. Null when the order is `open`.
    public final class PaymentIntent: Codable {
        public let string: String?
        /// A PaymentIntent guides you through the process of collecting a payment from your customer.
        /// We recommend that you create exactly one PaymentIntent for each order or
        /// customer session in your system. You can reference the PaymentIntent later to
        /// see the history of payment attempts for a particular session.
        /// 
        /// A PaymentIntent transitions through
        /// [multiple statuses](https://stripe.com/docs/payments/intents#intent-statuses)
        /// throughout its lifetime as it interfaces with Stripe.js to perform
        /// authentication flows and ultimately creates at most one successful charge.
        /// 
        /// Related guide: [Payment Intents API](https://stripe.com/docs/payments/payment-intents).
        public let paymentIntent: StripeKit.PaymentIntent?

        public init(string: String? = nil, paymentIntent: StripeKit.PaymentIntent? = nil) {
            self.string = string
            self.paymentIntent = paymentIntent
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.paymentIntent = try? container.decode(StripeKit.PaymentIntent.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = paymentIntent { try container.encode(value) }
        }
    }

    /// The status of the underlying payment associated with this order, if any. Null when the order is `open`.
    public enum Status: String, Codable, CaseIterable {
        case canceled
        case complete
        case notRequired = "not_required"
        case processing
        case requiresAction = "requires_action"
        case requiresCapture = "requires_capture"
        case requiresConfirmation = "requires_confirmation"
        case requiresPaymentMethod = "requires_payment_method"
    }

    public init(paymentIntent: PaymentIntent? = nil, settings: OrdersV2ResourcePaymentSettings? = nil, status: Status? = nil) {
        self.paymentIntent = paymentIntent
        self.settings = settings
        self.status = status
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.paymentIntent = try values.decodeIfPresent(PaymentIntent.self, forKey: "payment_intent")
        self.settings = try values.decodeIfPresent(OrdersV2ResourcePaymentSettings.self, forKey: "settings")
        self.status = try values.decodeIfPresent(Status.self, forKey: "status")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(paymentIntent, forKey: "payment_intent")
        try values.encodeIfPresent(settings, forKey: "settings")
        try values.encodeIfPresent(status, forKey: "status")
    }
}
