// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct CreditNoteLineItem: Codable {
    /// The integer amount in %s representing the gross amount being credited for this line item, excluding (exclusive) tax and discounts.
    public var amount: Int
    /// The integer amount in %s representing the amount being credited for this line item, excluding all tax and discounts.
    public var amountExcludingTax: Int?
    /// Description of the item being credited.
    public var description: String?
    /// The integer amount in %s representing the discount being credited for this line item.
    public var discountAmount: Int
    /// The amount of discount calculated per discount for this line item
    public var discountAmounts: [DiscountsResourceDiscountAmount]
    /// Unique identifier for the object.
    public var id: String
    /// ID of the invoice line item being credited
    public var invoiceLineItem: String?
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// The number of units of product being credited.
    public var quantity: Int?
    /// The amount of tax calculated per tax rate for this line item
    public var taxAmounts: [CreditNoteTaxAmount]
    /// The tax rates which apply to the line item.
    public var taxRates: [TaxRate]
    /// The type of the credit note line item, one of `invoice_line_item` or `custom_line_item`. When the type is `invoice_line_item` there is an additional `invoice_line_item` property on the resource the value of which is the id of the credited line item on the invoice.
    public var type: `Type`
    /// The cost of each unit of product being credited.
    public var unitAmount: Int?
    /// Same as `unit_amount`, but contains a decimal value with at most 12 decimal places.
    public var unitAmountDecimal: String?
    /// The amount in %s representing the unit amount being credited for this line item, excluding all tax and discounts.
    public var unitAmountExcludingTax: String?

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case creditNoteLineItem = "credit_note_line_item"
    }

    /// The type of the credit note line item, one of `invoice_line_item` or `custom_line_item`. When the type is `invoice_line_item` there is an additional `invoice_line_item` property on the resource the value of which is the id of the credited line item on the invoice.
    public enum `Type`: String, Codable, CaseIterable {
        case customLineItem = "custom_line_item"
        case invoiceLineItem = "invoice_line_item"
    }

    public init(amount: Int, amountExcludingTax: Int? = nil, description: String? = nil, discountAmount: Int, discountAmounts: [DiscountsResourceDiscountAmount], id: String, invoiceLineItem: String? = nil, isLivemode: Bool, object: Object, quantity: Int? = nil, taxAmounts: [CreditNoteTaxAmount], taxRates: [TaxRate], type: `Type`, unitAmount: Int? = nil, unitAmountDecimal: String? = nil, unitAmountExcludingTax: String? = nil) {
        self.amount = amount
        self.amountExcludingTax = amountExcludingTax
        self.description = description
        self.discountAmount = discountAmount
        self.discountAmounts = discountAmounts
        self.id = id
        self.invoiceLineItem = invoiceLineItem
        self.isLivemode = isLivemode
        self.object = object
        self.quantity = quantity
        self.taxAmounts = taxAmounts
        self.taxRates = taxRates
        self.type = type
        self.unitAmount = unitAmount
        self.unitAmountDecimal = unitAmountDecimal
        self.unitAmountExcludingTax = unitAmountExcludingTax
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.amount = try values.decode(Int.self, forKey: "amount")
        self.amountExcludingTax = try values.decodeIfPresent(Int.self, forKey: "amount_excluding_tax")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.discountAmount = try values.decode(Int.self, forKey: "discount_amount")
        self.discountAmounts = try values.decode([DiscountsResourceDiscountAmount].self, forKey: "discount_amounts")
        self.id = try values.decode(String.self, forKey: "id")
        self.invoiceLineItem = try values.decodeIfPresent(String.self, forKey: "invoice_line_item")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.object = try values.decode(Object.self, forKey: "object")
        self.quantity = try values.decodeIfPresent(Int.self, forKey: "quantity")
        self.taxAmounts = try values.decode([CreditNoteTaxAmount].self, forKey: "tax_amounts")
        self.taxRates = try values.decode([TaxRate].self, forKey: "tax_rates")
        self.type = try values.decode(`Type`.self, forKey: "type")
        self.unitAmount = try values.decodeIfPresent(Int.self, forKey: "unit_amount")
        self.unitAmountDecimal = try values.decodeIfPresent(String.self, forKey: "unit_amount_decimal")
        self.unitAmountExcludingTax = try values.decodeIfPresent(String.self, forKey: "unit_amount_excluding_tax")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(amount, forKey: "amount")
        try values.encodeIfPresent(amountExcludingTax, forKey: "amount_excluding_tax")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(discountAmount, forKey: "discount_amount")
        try values.encode(discountAmounts, forKey: "discount_amounts")
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(invoiceLineItem, forKey: "invoice_line_item")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(quantity, forKey: "quantity")
        try values.encode(taxAmounts, forKey: "tax_amounts")
        try values.encode(taxRates, forKey: "tax_rates")
        try values.encode(type, forKey: "type")
        try values.encodeIfPresent(unitAmount, forKey: "unit_amount")
        try values.encodeIfPresent(unitAmountDecimal, forKey: "unit_amount_decimal")
        try values.encodeIfPresent(unitAmountExcludingTax, forKey: "unit_amount_excluding_tax")
    }
}
