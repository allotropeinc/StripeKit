// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// An Issuing `Cardholder` object represents an individual or business entity who is [issued](https://stripe.com/docs/issuing) cards.
/// 
/// Related guide: [How to create a Cardholder](https://stripe.com/docs/issuing/cards#create-cardholder)
public struct IssuingCardholder: Codable {
    /// IssuingCardholderAddress
    public var billing: IssuingCardholderAddress
    /// Additional information about a `company` cardholder.
    public var company: IssuingCardholderCompany?
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public var created: Int
    /// The cardholder's email address.
    public var email: String?
    /// Unique identifier for the object.
    public var id: String
    /// Additional information about an `individual` cardholder.
    public var individual: IssuingCardholderIndividual?
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    public var metadata: [String: String]
    /// The cardholder's name. This will be printed on cards issued to them.
    public var name: String
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// The cardholder's phone number. This is required for all cardholders who will be creating EU cards. See the [3D Secure documentation](https://stripe.com/docs/issuing/3d-secure#when-is-3d-secure-applied) for more details.
    public var phoneNumber: String?
    /// IssuingCardholderRequirements
    public var requirements: IssuingCardholderRequirements
    /// Rules that control spending across this cardholder's cards. Refer to our [documentation](https://stripe.com/docs/issuing/controls/spending-controls) for more details.
    public var spendingControls: IssuingCardholderAuthorizationControls?
    /// Specifies whether to permit authorizations on this cardholder's cards.
    public var status: Status
    /// One of `individual` or `company`.
    public var type: `Type`

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case issuingCardholder = "issuing.cardholder"
    }

    /// Specifies whether to permit authorizations on this cardholder's cards.
    public enum Status: String, Codable, CaseIterable {
        case active
        case blocked
        case inactive
    }

    /// One of `individual` or `company`.
    public enum `Type`: String, Codable, CaseIterable {
        case company
        case individual
    }

    public init(billing: IssuingCardholderAddress, company: IssuingCardholderCompany? = nil, created: Int, email: String? = nil, id: String, individual: IssuingCardholderIndividual? = nil, isLivemode: Bool, metadata: [String: String], name: String, object: Object, phoneNumber: String? = nil, requirements: IssuingCardholderRequirements, spendingControls: IssuingCardholderAuthorizationControls? = nil, status: Status, type: `Type`) {
        self.billing = billing
        self.company = company
        self.created = created
        self.email = email
        self.id = id
        self.individual = individual
        self.isLivemode = isLivemode
        self.metadata = metadata
        self.name = name
        self.object = object
        self.phoneNumber = phoneNumber
        self.requirements = requirements
        self.spendingControls = spendingControls
        self.status = status
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.billing = try values.decode(IssuingCardholderAddress.self, forKey: "billing")
        self.company = try values.decodeIfPresent(IssuingCardholderCompany.self, forKey: "company")
        self.created = try values.decode(Int.self, forKey: "created")
        self.email = try values.decodeIfPresent(String.self, forKey: "email")
        self.id = try values.decode(String.self, forKey: "id")
        self.individual = try values.decodeIfPresent(IssuingCardholderIndividual.self, forKey: "individual")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.metadata = try values.decode([String: String].self, forKey: "metadata")
        self.name = try values.decode(String.self, forKey: "name")
        self.object = try values.decode(Object.self, forKey: "object")
        self.phoneNumber = try values.decodeIfPresent(String.self, forKey: "phone_number")
        self.requirements = try values.decode(IssuingCardholderRequirements.self, forKey: "requirements")
        self.spendingControls = try values.decodeIfPresent(IssuingCardholderAuthorizationControls.self, forKey: "spending_controls")
        self.status = try values.decode(Status.self, forKey: "status")
        self.type = try values.decode(`Type`.self, forKey: "type")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(billing, forKey: "billing")
        try values.encodeIfPresent(company, forKey: "company")
        try values.encode(created, forKey: "created")
        try values.encodeIfPresent(email, forKey: "email")
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(individual, forKey: "individual")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encode(metadata, forKey: "metadata")
        try values.encode(name, forKey: "name")
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(phoneNumber, forKey: "phone_number")
        try values.encode(requirements, forKey: "requirements")
        try values.encodeIfPresent(spendingControls, forKey: "spending_controls")
        try values.encode(status, forKey: "status")
        try values.encode(type, forKey: "type")
    }
}
