// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// This object represents a customer of your business. It lets you create recurring charges and track payments that belong to the same customer.
/// 
/// Related guide: [Save a card during payment](https://stripe.com/docs/payments/save-during-payment).
public struct Customer: Codable {
    /// The customer's address.
    public var address: Address?
    /// Current balance, if any, being stored on the customer. If negative, the customer has credit to apply to their next invoice. If positive, the customer has an amount owed that will be added to their next invoice. The balance does not refer to any unpaid invoices; it solely takes into account amounts that have yet to be successfully applied to any invoice. This balance is only taken into account as invoices are finalized.
    public var balance: Int?
    /// The current funds being held by Stripe on behalf of the customer. These funds can be applied towards payment intents with source "cash_balance".The settings[reconciliation_mode] field describes whether these funds are applied to such payment intents manually or automatically.
    public var cashBalance: CashBalance?
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public var created: Int
    /// Three-letter [ISO code for the currency](https://stripe.com/docs/currencies) the customer can be charged in for recurring billing purposes.
    public var currency: String?
    /// ID of the default payment source for the customer.
    /// 
    /// If you are using payment methods created via the PaymentMethods API, see the [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) field instead.
    public var defaultSource: DefaultSource?
    /// When the customer's latest invoice is billed by charging automatically, `delinquent` is `true` if the invoice's latest charge failed. When the customer's latest invoice is billed by sending an invoice, `delinquent` is `true` if the invoice isn't paid by its due date.
    /// 
    /// If an invoice is marked uncollectible by [dunning](https://stripe.com/docs/billing/automatic-collection), `delinquent` doesn't get reset to `false`.
    public var isDelinquent: Bool?
    /// An arbitrary string attached to the object. Often useful for displaying to users.
    public var description: String?
    /// Describes the current discount active on the customer, if there is one.
    public var discount: Discount?
    /// The customer's email address.
    public var email: String?
    /// Unique identifier for the object.
    public var id: String
    /// The current multi-currency balances, if any, being stored on the customer.If positive in a currency, the customer has a credit to apply to their next invoice denominated in that currency.If negative, the customer has an amount owed that will be added to their next invoice denominated in that currency. These balances do not refer to any unpaid invoices.They solely track amounts that have yet to be successfully applied to any invoice. A balance in a particular currency is only applied to any invoice as an invoice in that currency is finalized.
    public var invoiceCreditBalance: [String: Int]?
    /// The prefix for the customer used to generate unique invoice numbers.
    public var invoicePrefix: String?
    /// InvoiceSettingCustomerSetting
    public var invoiceSettings: InvoiceSettingCustomerSetting?
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    public var metadata: [String: String]?
    /// The customer's full name or business name.
    public var name: String?
    /// The suffix of the customer's next invoice number, e.g., 0001.
    public var nextInvoiceSequence: Int?
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// The customer's phone number.
    public var phone: String?
    /// The customer's preferred locales (languages), ordered by preference.
    public var preferredLocales: [String]?
    /// Mailing and shipping address for the customer. Appears on invoices emailed to this customer.
    public var shipping: Shipping?
    /// ApmsSourcesSourceList
    ///
    /// The customer's payment sources, if any.
    public var sources: Sources?
    /// SubscriptionList
    ///
    /// The customer's current subscriptions, if any.
    public var subscriptions: Subscriptions?
    /// CustomerTax
    public var tax: CustomerTax?
    /// Describes the customer's tax exemption status. One of `none`, `exempt`, or `reverse`. When set to `reverse`, invoice and receipt PDFs include the text **"Reverse charge"**.
    public var taxExempt: TaxExempt?
    /// TaxIDsList
    ///
    /// The customer's tax IDs.
    public var taxIDs: TaxIDs?
    /// ID of the test clock this customer belongs to.
    public var testClock: TestClock?

    /// ID of the default payment source for the customer.
    /// 
    /// If you are using payment methods created via the PaymentMethods API, see the [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) field instead.
    public struct DefaultSource: Codable {
        public var string: String?
        /// These bank accounts are payment methods on `Customer` objects.
        /// 
        /// On the other hand [External Accounts](https://stripe.com/docs/api#external_accounts) are transfer
        /// destinations on `Account` objects for [Custom accounts](https://stripe.com/docs/connect/custom-accounts).
        /// They can be bank accounts or debit cards as well, and are documented in the links above.
        /// 
        /// Related guide: [Bank Debits and Transfers](https://stripe.com/docs/payments/bank-debits-transfers).
        public var bankAccount: BankAccount?
        /// You can store multiple cards on a customer in order to charge the customer
        /// later. You can also store multiple debit cards on a recipient in order to
        /// transfer to those cards later.
        /// 
        /// Related guide: [Card Payments with Sources](https://stripe.com/docs/sources/cards).
        public var card: Card?
        /// `Source` objects allow you to accept a variety of payment methods. They
        /// represent a customer's payment instrument, and can be used with the Stripe API
        /// just like a `Card` object: once chargeable, they can be charged, or can be
        /// attached to customers.
        /// 
        /// Related guides: [Sources API](https://stripe.com/docs/sources) and [Sources & Customers](https://stripe.com/docs/sources/customers).
        public var source: Source?

        public init(string: String? = nil, bankAccount: BankAccount? = nil, card: Card? = nil, source: Source? = nil) {
            self.string = string
            self.bankAccount = bankAccount
            self.card = card
            self.source = source
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.bankAccount = try? container.decode(BankAccount.self)
            self.card = try? container.decode(Card.self)
            self.source = try? container.decode(Source.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = bankAccount { try container.encode(value) }
            if let value = card { try container.encode(value) }
            if let value = source { try container.encode(value) }
        }
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case customer
    }

    /// ApmsSourcesSourceList
    ///
    /// The customer's payment sources, if any.
    public struct Sources: Codable {
        /// Details about each object.
        public var data: [Datum]
        /// True if this list has another page of items after this one that can be fetched.
        public var hasMore: Bool
        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public var object: Object
        /// The URL where this list can be accessed.
        public var url: String

        /// Polymorphic
        public struct Datum: Codable {
            /// These bank accounts are payment methods on `Customer` objects.
            /// 
            /// On the other hand [External Accounts](https://stripe.com/docs/api#external_accounts) are transfer
            /// destinations on `Account` objects for [Custom accounts](https://stripe.com/docs/connect/custom-accounts).
            /// They can be bank accounts or debit cards as well, and are documented in the links above.
            /// 
            /// Related guide: [Bank Debits and Transfers](https://stripe.com/docs/payments/bank-debits-transfers).
            public var bankAccount: BankAccount?
            /// You can store multiple cards on a customer in order to charge the customer
            /// later. You can also store multiple debit cards on a recipient in order to
            /// transfer to those cards later.
            /// 
            /// Related guide: [Card Payments with Sources](https://stripe.com/docs/sources/cards).
            public var card: Card?
            /// `Source` objects allow you to accept a variety of payment methods. They
            /// represent a customer's payment instrument, and can be used with the Stripe API
            /// just like a `Card` object: once chargeable, they can be charged, or can be
            /// attached to customers.
            /// 
            /// Related guides: [Sources API](https://stripe.com/docs/sources) and [Sources & Customers](https://stripe.com/docs/sources/customers).
            public var source: Source?

            public init(bankAccount: BankAccount? = nil, card: Card? = nil, source: Source? = nil) {
                self.bankAccount = bankAccount
                self.card = card
                self.source = source
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                self.bankAccount = try? container.decode(BankAccount.self)
                self.card = try? container.decode(Card.self)
                self.source = try? container.decode(Source.self)
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                if let value = bankAccount { try container.encode(value) }
                if let value = card { try container.encode(value) }
                if let value = source { try container.encode(value) }
            }
        }

        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public enum Object: String, Codable, CaseIterable {
            case list
        }

        public init(data: [Datum], hasMore: Bool, object: Object, url: String) {
            self.data = data
            self.hasMore = hasMore
            self.object = object
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.data = try values.decode([Datum].self, forKey: "data")
            self.hasMore = try values.decode(Bool.self, forKey: "has_more")
            self.object = try values.decode(Object.self, forKey: "object")
            self.url = try values.decode(String.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(data, forKey: "data")
            try values.encode(hasMore, forKey: "has_more")
            try values.encode(object, forKey: "object")
            try values.encode(url, forKey: "url")
        }
    }

    /// SubscriptionList
    ///
    /// The customer's current subscriptions, if any.
    public struct Subscriptions: Codable {
        /// Details about each object.
        public var data: [Subscription]
        /// True if this list has another page of items after this one that can be fetched.
        public var hasMore: Bool
        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public var object: Object
        /// The URL where this list can be accessed.
        public var url: String

        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public enum Object: String, Codable, CaseIterable {
            case list
        }

        public init(data: [Subscription], hasMore: Bool, object: Object, url: String) {
            self.data = data
            self.hasMore = hasMore
            self.object = object
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.data = try values.decode([Subscription].self, forKey: "data")
            self.hasMore = try values.decode(Bool.self, forKey: "has_more")
            self.object = try values.decode(Object.self, forKey: "object")
            self.url = try values.decode(String.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(data, forKey: "data")
            try values.encode(hasMore, forKey: "has_more")
            try values.encode(object, forKey: "object")
            try values.encode(url, forKey: "url")
        }
    }

    /// Describes the customer's tax exemption status. One of `none`, `exempt`, or `reverse`. When set to `reverse`, invoice and receipt PDFs include the text **"Reverse charge"**.
    public enum TaxExempt: String, Codable, CaseIterable {
        case exempt
        case `none`
        case reverse
    }

    /// TaxIDsList
    ///
    /// The customer's tax IDs.
    public struct TaxIDs: Codable {
        /// Details about each object.
        public var data: [TaxID]
        /// True if this list has another page of items after this one that can be fetched.
        public var hasMore: Bool
        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public var object: Object
        /// The URL where this list can be accessed.
        public var url: String

        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public enum Object: String, Codable, CaseIterable {
            case list
        }

        public init(data: [TaxID], hasMore: Bool, object: Object, url: String) {
            self.data = data
            self.hasMore = hasMore
            self.object = object
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.data = try values.decode([TaxID].self, forKey: "data")
            self.hasMore = try values.decode(Bool.self, forKey: "has_more")
            self.object = try values.decode(Object.self, forKey: "object")
            self.url = try values.decode(String.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(data, forKey: "data")
            try values.encode(hasMore, forKey: "has_more")
            try values.encode(object, forKey: "object")
            try values.encode(url, forKey: "url")
        }
    }

    /// ID of the test clock this customer belongs to.
    public struct TestClock: Codable {
        public var string: String?
        /// TestClock
        ///
        /// A test clock enables deterministic control over objects in testmode. With a test clock, you can create
        /// objects at a frozen time in the past or future, and advance to a specific future time to observe webhooks and state changes. After the clock advances,
        /// you can either validate the current state of your scenario (and test your assumptions), change the current state of your scenario (and test more complex scenarios), or keep advancing forward in time.
        public var testHelpersTestClock: TestHelpersTestClock?

        public init(string: String? = nil, testHelpersTestClock: TestHelpersTestClock? = nil) {
            self.string = string
            self.testHelpersTestClock = testHelpersTestClock
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.testHelpersTestClock = try? container.decode(TestHelpersTestClock.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = testHelpersTestClock { try container.encode(value) }
        }
    }

    public init(address: Address? = nil, balance: Int? = nil, cashBalance: CashBalance? = nil, created: Int, currency: String? = nil, defaultSource: DefaultSource? = nil, isDelinquent: Bool? = nil, description: String? = nil, discount: Discount? = nil, email: String? = nil, id: String, invoiceCreditBalance: [String: Int]? = nil, invoicePrefix: String? = nil, invoiceSettings: InvoiceSettingCustomerSetting? = nil, isLivemode: Bool, metadata: [String: String]? = nil, name: String? = nil, nextInvoiceSequence: Int? = nil, object: Object, phone: String? = nil, preferredLocales: [String]? = nil, shipping: Shipping? = nil, sources: Sources? = nil, subscriptions: Subscriptions? = nil, tax: CustomerTax? = nil, taxExempt: TaxExempt? = nil, taxIDs: TaxIDs? = nil, testClock: TestClock? = nil) {
        self.address = address
        self.balance = balance
        self.cashBalance = cashBalance
        self.created = created
        self.currency = currency
        self.defaultSource = defaultSource
        self.isDelinquent = isDelinquent
        self.description = description
        self.discount = discount
        self.email = email
        self.id = id
        self.invoiceCreditBalance = invoiceCreditBalance
        self.invoicePrefix = invoicePrefix
        self.invoiceSettings = invoiceSettings
        self.isLivemode = isLivemode
        self.metadata = metadata
        self.name = name
        self.nextInvoiceSequence = nextInvoiceSequence
        self.object = object
        self.phone = phone
        self.preferredLocales = preferredLocales
        self.shipping = shipping
        self.sources = sources
        self.subscriptions = subscriptions
        self.tax = tax
        self.taxExempt = taxExempt
        self.taxIDs = taxIDs
        self.testClock = testClock
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.address = try values.decodeIfPresent(Address.self, forKey: "address")
        self.balance = try values.decodeIfPresent(Int.self, forKey: "balance")
        self.cashBalance = try values.decodeIfPresent(CashBalance.self, forKey: "cash_balance")
        self.created = try values.decode(Int.self, forKey: "created")
        self.currency = try values.decodeIfPresent(String.self, forKey: "currency")
        self.defaultSource = try values.decodeIfPresent(DefaultSource.self, forKey: "default_source")
        self.isDelinquent = try values.decodeIfPresent(Bool.self, forKey: "delinquent")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.discount = try values.decodeIfPresent(Discount.self, forKey: "discount")
        self.email = try values.decodeIfPresent(String.self, forKey: "email")
        self.id = try values.decode(String.self, forKey: "id")
        self.invoiceCreditBalance = try values.decodeIfPresent([String: Int].self, forKey: "invoice_credit_balance")
        self.invoicePrefix = try values.decodeIfPresent(String.self, forKey: "invoice_prefix")
        self.invoiceSettings = try values.decodeIfPresent(InvoiceSettingCustomerSetting.self, forKey: "invoice_settings")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.metadata = try values.decodeIfPresent([String: String].self, forKey: "metadata")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.nextInvoiceSequence = try values.decodeIfPresent(Int.self, forKey: "next_invoice_sequence")
        self.object = try values.decode(Object.self, forKey: "object")
        self.phone = try values.decodeIfPresent(String.self, forKey: "phone")
        self.preferredLocales = try values.decodeIfPresent([String].self, forKey: "preferred_locales")
        self.shipping = try values.decodeIfPresent(Shipping.self, forKey: "shipping")
        self.sources = try values.decodeIfPresent(Sources.self, forKey: "sources")
        self.subscriptions = try values.decodeIfPresent(Subscriptions.self, forKey: "subscriptions")
        self.tax = try values.decodeIfPresent(CustomerTax.self, forKey: "tax")
        self.taxExempt = try values.decodeIfPresent(TaxExempt.self, forKey: "tax_exempt")
        self.taxIDs = try values.decodeIfPresent(TaxIDs.self, forKey: "tax_ids")
        self.testClock = try values.decodeIfPresent(TestClock.self, forKey: "test_clock")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(address, forKey: "address")
        try values.encodeIfPresent(balance, forKey: "balance")
        try values.encodeIfPresent(cashBalance, forKey: "cash_balance")
        try values.encode(created, forKey: "created")
        try values.encodeIfPresent(currency, forKey: "currency")
        try values.encodeIfPresent(defaultSource, forKey: "default_source")
        try values.encodeIfPresent(isDelinquent, forKey: "delinquent")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(discount, forKey: "discount")
        try values.encodeIfPresent(email, forKey: "email")
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(invoiceCreditBalance, forKey: "invoice_credit_balance")
        try values.encodeIfPresent(invoicePrefix, forKey: "invoice_prefix")
        try values.encodeIfPresent(invoiceSettings, forKey: "invoice_settings")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(nextInvoiceSequence, forKey: "next_invoice_sequence")
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(phone, forKey: "phone")
        try values.encodeIfPresent(preferredLocales, forKey: "preferred_locales")
        try values.encodeIfPresent(shipping, forKey: "shipping")
        try values.encodeIfPresent(sources, forKey: "sources")
        try values.encodeIfPresent(subscriptions, forKey: "subscriptions")
        try values.encodeIfPresent(tax, forKey: "tax")
        try values.encodeIfPresent(taxExempt, forKey: "tax_exempt")
        try values.encodeIfPresent(taxIDs, forKey: "tax_ids")
        try values.encodeIfPresent(testClock, forKey: "test_clock")
    }
}
