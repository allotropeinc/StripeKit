// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Invoices are statements of amounts owed by a customer, and are either
/// generated one-off, or generated periodically from a subscription.
/// 
/// They contain [invoice items](https://stripe.com/docs/api#invoiceitems), and proration adjustments
/// that may be caused by subscription upgrades/downgrades (if necessary).
/// 
/// If your invoice is configured to be billed through automatic charges,
/// Stripe automatically finalizes your invoice and attempts payment. Note
/// that finalizing the invoice,
/// [when automatic](https://stripe.com/docs/billing/invoices/workflow/#auto_advance), does
/// not happen immediately as the invoice is created. Stripe waits
/// until one hour after the last webhook was successfully sent (or the last
/// webhook timed out after failing). If you (and the platforms you may have
/// connected to) have no webhooks configured, Stripe waits one hour after
/// creation to finalize the invoice.
/// 
/// If your invoice is configured to be billed by sending an email, then based on your
/// [email settings](https://dashboard.stripe.com/account/billing/automatic),
/// Stripe will email the invoice to your customer and await payment. These
/// emails can contain a link to a hosted page to pay the invoice.
/// 
/// Stripe applies any customer credit on the account before determining the
/// amount due for the invoice (i.e., the amount that will be actually
/// charged). If the amount due for the invoice is less than Stripe's [minimum allowed charge
/// per currency](/docs/currencies#minimum-and-maximum-charge-amounts), the
/// invoice is automatically marked paid, and we add the amount due to the
/// customer's credit balance which is applied to the next invoice.
/// 
/// More details on the customer's credit balance are
/// [here](https://stripe.com/docs/billing/customer/balance).
/// 
/// Related guide: [Send Invoices to Customers](https://stripe.com/docs/billing/invoices/sending).
public struct Invoice: Codable {
    /// The country of the business associated with this invoice, most often the business creating the invoice.
    public var accountCountry: String?
    /// The public name of the business associated with this invoice, most often the business creating the invoice.
    public var accountName: String?
    /// The account tax IDs associated with the invoice. Only editable when the invoice is a draft.
    public var accountTaxIDs: [AccountTaxID]?
    /// Final amount due at this time for this invoice. If the invoice's total is smaller than the minimum charge amount, for example, or if there is account credit that can be applied to the invoice, the `amount_due` may be 0. If there is a positive `starting_balance` for the invoice (the customer owes money), the `amount_due` will also take that into account. The charge that gets generated for the invoice will be for the amount specified in `amount_due`.
    public var amountDue: Int
    /// The amount, in %s, that was paid.
    public var amountPaid: Int
    /// The difference between amount_due and amount_paid, in %s.
    public var amountRemaining: Int
    /// ID of the Connect Application that created the invoice.
    public var application: Application?
    /// The fee in %s that will be applied to the invoice and transferred to the application owner's Stripe account when the invoice is paid.
    public var applicationFeeAmount: Int?
    /// Number of payment attempts made for this invoice, from the perspective of the payment retry schedule. Any payment attempt counts as the first attempt, and subsequently only automatic retries increment the attempt count. In other words, manual payment attempts after the first attempt do not affect the retry schedule.
    public var attemptCount: Int
    /// Whether an attempt has been made to pay the invoice. An invoice is not attempted until 1 hour after the `invoice.created` webhook, for example, so you might not want to display that invoice as unpaid to your users.
    public var isAttempted: Bool
    /// Controls whether Stripe will perform [automatic collection](https://stripe.com/docs/billing/invoices/workflow/#auto_advance) of the invoice. When `false`, the invoice's state will not automatically advance without an explicit action.
    public var isAutoAdvance: Bool?
    public var automaticTax: AutomaticTax
    /// Indicates the reason why the invoice was created. `subscription_cycle` indicates an invoice created by a subscription advancing into a new period. `subscription_create` indicates an invoice created due to creating a subscription. `subscription_update` indicates an invoice created due to updating a subscription. `subscription` is set for all old invoices to indicate either a change to a subscription or a period advancement. `manual` is set for all invoices unrelated to a subscription (for example: created via the invoice editor). The `upcoming` value is reserved for simulated invoices per the upcoming invoice endpoint. `subscription_threshold` indicates an invoice created due to a billing threshold being reached.
    public var billingReason: BillingReason?
    /// ID of the latest charge generated for this invoice, if any.
    public var charge: Charge?
    /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this invoice using the default source attached to the customer. When sending an invoice, Stripe will email this invoice to the customer with payment instructions.
    public var collectionMethod: CollectionMethod
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public var created: Int
    /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    public var currency: String
    /// Custom fields displayed on the invoice.
    public var customFields: [InvoiceSettingCustomField]?
    /// The ID of the customer who will be billed.
    public var customer: Customer?
    /// The customer's address. Until the invoice is finalized, this field will equal `customer.address`. Once the invoice is finalized, this field will no longer be updated.
    public var customerAddress: Address?
    /// The customer's email. Until the invoice is finalized, this field will equal `customer.email`. Once the invoice is finalized, this field will no longer be updated.
    public var customerEmail: String?
    /// The customer's name. Until the invoice is finalized, this field will equal `customer.name`. Once the invoice is finalized, this field will no longer be updated.
    public var customerName: String?
    /// The customer's phone number. Until the invoice is finalized, this field will equal `customer.phone`. Once the invoice is finalized, this field will no longer be updated.
    public var customerPhone: String?
    /// The customer's shipping information. Until the invoice is finalized, this field will equal `customer.shipping`. Once the invoice is finalized, this field will no longer be updated.
    public var customerShipping: Shipping?
    /// The customer's tax exempt status. Until the invoice is finalized, this field will equal `customer.tax_exempt`. Once the invoice is finalized, this field will no longer be updated.
    public var customerTaxExempt: CustomerTaxExempt?
    /// The customer's tax IDs. Until the invoice is finalized, this field will contain the same tax IDs as `customer.tax_ids`. Once the invoice is finalized, this field will no longer be updated.
    public var customerTaxIDs: [InvoicesResourceInvoiceTaxID]?
    /// ID of the default payment method for the invoice. It must belong to the customer associated with the invoice. If not set, defaults to the subscription's default payment method, if any, or to the default payment method in the customer's invoice settings.
    public var defaultPaymentMethod: DefaultPaymentMethod?
    /// ID of the default payment source for the invoice. It must belong to the customer associated with the invoice and be in a chargeable state. If not set, defaults to the subscription's default source, if any, or to the customer's default source.
    public var defaultSource: DefaultSource?
    /// The tax rates applied to this invoice, if any.
    public var defaultTaxRates: [TaxRate]
    /// An arbitrary string attached to the object. Often useful for displaying to users. Referenced as 'memo' in the Dashboard.
    public var description: String?
    /// Describes the current discount applied to this invoice, if there is one. Not populated if there are multiple discounts.
    public var discount: Discount?
    /// The discounts applied to the invoice. Line item discounts are applied before invoice discounts. Use `expand[]=discounts` to expand each discount.
    public var discounts: [DiscountsItem]?
    /// The date on which payment for this invoice is due. This value will be `null` for invoices where `collection_method=charge_automatically`.
    public var dueDate: Int?
    /// Ending customer balance after the invoice is finalized. Invoices are finalized approximately an hour after successful webhook delivery or when payment collection is attempted for the invoice. If the invoice has not been finalized yet, this will be null.
    public var endingBalance: Int?
    /// Footer displayed on the invoice.
    public var footer: String?
    /// The URL for the hosted invoice page, which allows customers to view and pay an invoice. If the invoice has not been finalized yet, this will be null.
    public var hostedInvoiceURL: String?
    /// Unique identifier for the object.
    public var id: String?
    /// The link to download the PDF for the invoice. If the invoice has not been finalized yet, this will be null.
    public var invoicePdf: String?
    /// The error encountered during the previous attempt to finalize the invoice. This field is cleared when the invoice is successfully finalized.
    public var lastFinalizationError: APIErrors?
    /// InvoiceLinesList
    ///
    /// The individual line items that make up the invoice. `lines` is sorted as follows: invoice items in reverse chronological order, followed by the subscription, if any.
    public var lines: Lines
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    public var metadata: [String: String]?
    /// The time at which payment will next be attempted. This value will be `null` for invoices where `collection_method=send_invoice`.
    public var nextPaymentAttempt: Int?
    /// A unique, identifying string that appears on emails sent to the customer for this invoice. This starts with the customer's unique invoice_prefix if it is specified.
    public var number: String?
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// The account (if any) for which the funds of the invoice payment are intended. If set, the invoice will be presented with the branding and support information of the specified account. See the [Invoices with Connect](https://stripe.com/docs/billing/invoices/connect) documentation for details.
    public var onBehalfOf: OnBehalfOf?
    /// Whether payment was successfully collected for this invoice. An invoice can be paid (most commonly) with a charge or with credit from the customer's account balance.
    public var isPaid: Bool
    /// Returns true if the invoice was manually marked paid, returns false if the invoice hasn't been paid yet or was paid on Stripe.
    public var isPaidOutOfBand: Bool
    /// The PaymentIntent associated with this invoice. The PaymentIntent is generated when the invoice is finalized, and can then be used to pay the invoice. Note that voiding an invoice will cancel the PaymentIntent.
    public var paymentIntent: PaymentIntent?
    /// InvoicesPaymentSettings
    public var paymentSettings: InvoicesPaymentSettings
    /// End of the usage period during which invoice items were added to this invoice.
    public var periodEnd: Int
    /// Start of the usage period during which invoice items were added to this invoice.
    public var periodStart: Int
    /// Total amount of all post-payment credit notes issued for this invoice.
    public var postPaymentCreditNotesAmount: Int
    /// Total amount of all pre-payment credit notes issued for this invoice.
    public var prePaymentCreditNotesAmount: Int
    /// The quote this invoice was generated from.
    public var quote: Quote?
    /// This is the transaction number that appears on email receipts sent for this invoice.
    public var receiptNumber: String?
    /// Options for invoice PDF rendering.
    public var renderingOptions: InvoiceSettingRenderingOptions?
    /// Starting customer balance before the invoice is finalized. If the invoice has not been finalized yet, this will be the current customer balance.
    public var startingBalance: Int
    /// Extra information about an invoice for the customer's credit card statement.
    public var statementDescriptor: String?
    /// The status of the invoice, one of `draft`, `open`, `paid`, `uncollectible`, or `void`. [Learn more](https://stripe.com/docs/billing/invoices/workflow#workflow-overview)
    public var status: Status?
    /// InvoicesStatusTransitions
    public var statusTransitions: InvoicesStatusTransitions
    /// The subscription that this invoice was prepared for, if any.
    public var subscription: Subscription?
    /// Only set for upcoming invoices that preview prorations. The time used to calculate prorations.
    public var subscriptionProrationDate: Int?
    /// Total of all subscriptions, invoice items, and prorations on the invoice before any invoice level discount or exclusive tax is applied. Item discounts are already incorporated
    public var subtotal: Int
    /// The integer amount in %s representing the subtotal of the invoice before any invoice level discount or tax is applied. Item discounts are already incorporated
    public var subtotalExcludingTax: Int?
    /// The amount of tax on this invoice. This is the sum of all the tax amounts on this invoice.
    public var tax: Int?
    /// ID of the test clock this invoice belongs to.
    public var testClock: TestClock?
    /// InvoiceThresholdReason
    public var thresholdReason: InvoiceThresholdReason?
    /// Total after discounts and taxes.
    public var total: Int
    /// The aggregate amounts calculated per discount across all line items.
    public var totalDiscountAmounts: [DiscountsResourceDiscountAmount]?
    /// The integer amount in %s representing the total amount of the invoice including all discounts but excluding all tax.
    public var totalExcludingTax: Int?
    /// The aggregate amounts calculated per tax rate for all line items.
    public var totalTaxAmounts: [InvoiceTaxAmount]
    /// The account (if any) the payment will be attributed to for tax reporting, and where funds from the payment will be transferred to for the invoice.
    public var transferData: InvoiceTransferData?
    /// Invoices are automatically paid or sent 1 hour after webhooks are delivered, or until all webhook delivery attempts have [been exhausted](https://stripe.com/docs/billing/webhooks#understand). This field tracks the time when webhooks for this invoice were successfully delivered. If the invoice had no webhooks to deliver, this will be set while the invoice is being created.
    public var webhooksDeliveredAt: Int?

    public struct AccountTaxID: Codable {
        public var string: String?
        /// Tax_id
        ///
        /// You can add one or multiple tax IDs to a [customer](https://stripe.com/docs/api/customers).
        /// A customer's tax IDs are displayed on invoices and credit notes issued for the customer.
        /// 
        /// Related guide: [Customer Tax Identification Numbers](https://stripe.com/docs/billing/taxes/tax-ids).
        public var taxID: TaxID?
        /// Deleted_tax_id
        public var deletedTaxID: DeletedTaxID?

        public init(string: String? = nil, taxID: TaxID? = nil, deletedTaxID: DeletedTaxID? = nil) {
            self.string = string
            self.taxID = taxID
            self.deletedTaxID = deletedTaxID
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.taxID = try? container.decode(TaxID.self)
            self.deletedTaxID = try? container.decode(DeletedTaxID.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = taxID { try container.encode(value) }
            if let value = deletedTaxID { try container.encode(value) }
        }
    }

    /// ID of the Connect Application that created the invoice.
    public final class Application: Codable {
        public let string: String?
        public let application: StripeKit.Application?
        public let deletedApplication: DeletedApplication?

        public init(string: String? = nil, application: StripeKit.Application? = nil, deletedApplication: DeletedApplication? = nil) {
            self.string = string
            self.application = application
            self.deletedApplication = deletedApplication
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.application = try? container.decode(StripeKit.Application.self)
            self.deletedApplication = try? container.decode(DeletedApplication.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = application { try container.encode(value) }
            if let value = deletedApplication { try container.encode(value) }
        }
    }

    /// Indicates the reason why the invoice was created. `subscription_cycle` indicates an invoice created by a subscription advancing into a new period. `subscription_create` indicates an invoice created due to creating a subscription. `subscription_update` indicates an invoice created due to updating a subscription. `subscription` is set for all old invoices to indicate either a change to a subscription or a period advancement. `manual` is set for all invoices unrelated to a subscription (for example: created via the invoice editor). The `upcoming` value is reserved for simulated invoices per the upcoming invoice endpoint. `subscription_threshold` indicates an invoice created due to a billing threshold being reached.
    public enum BillingReason: String, Codable, CaseIterable {
        case automaticPendingInvoiceItemInvoice = "automatic_pending_invoice_item_invoice"
        case manual
        case quoteAccept = "quote_accept"
        case subscription
        case subscriptionCreate = "subscription_create"
        case subscriptionCycle = "subscription_cycle"
        case subscriptionThreshold = "subscription_threshold"
        case subscriptionUpdate = "subscription_update"
        case upcoming
    }

    /// ID of the latest charge generated for this invoice, if any.
    public final class Charge: Codable {
        public let string: String?
        /// To charge a credit or a debit card, you create a `Charge` object. You can
        /// retrieve and refund individual charges as well as list all charges. Charges
        /// are identified by a unique, random ID.
        /// 
        /// Related guide: [Accept a payment with the Charges API](https://stripe.com/docs/payments/accept-a-payment-charges).
        public let charge: StripeKit.Charge?

        public init(string: String? = nil, charge: StripeKit.Charge? = nil) {
            self.string = string
            self.charge = charge
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.charge = try? container.decode(StripeKit.Charge.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = charge { try container.encode(value) }
        }
    }

    /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this invoice using the default source attached to the customer. When sending an invoice, Stripe will email this invoice to the customer with payment instructions.
    public enum CollectionMethod: String, Codable, CaseIterable {
        case chargeAutomatically = "charge_automatically"
        case sendInvoice = "send_invoice"
    }

    /// The ID of the customer who will be billed.
    public final class Customer: Codable {
        public let string: String?
        /// This object represents a customer of your business. It lets you create recurring charges and track payments that belong to the same customer.
        /// 
        /// Related guide: [Save a card during payment](https://stripe.com/docs/payments/save-during-payment).
        public let customer: StripeKit.Customer?
        public let deletedCustomer: DeletedCustomer?

        public init(string: String? = nil, customer: StripeKit.Customer? = nil, deletedCustomer: DeletedCustomer? = nil) {
            self.string = string
            self.customer = customer
            self.deletedCustomer = deletedCustomer
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.customer = try? container.decode(StripeKit.Customer.self)
            self.deletedCustomer = try? container.decode(DeletedCustomer.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = customer { try container.encode(value) }
            if let value = deletedCustomer { try container.encode(value) }
        }
    }

    /// The customer's tax exempt status. Until the invoice is finalized, this field will equal `customer.tax_exempt`. Once the invoice is finalized, this field will no longer be updated.
    public enum CustomerTaxExempt: String, Codable, CaseIterable {
        case exempt
        case `none`
        case reverse
    }

    /// ID of the default payment method for the invoice. It must belong to the customer associated with the invoice. If not set, defaults to the subscription's default payment method, if any, or to the default payment method in the customer's invoice settings.
    public struct DefaultPaymentMethod: Codable {
        public var string: String?
        /// PaymentMethod objects represent your customer's payment instruments.
        /// You can use them with [PaymentIntents](https://stripe.com/docs/payments/payment-intents) to collect payments or save them to
        /// Customer objects to store instrument details for future payments.
        /// 
        /// Related guides: [Payment Methods](https://stripe.com/docs/payments/payment-methods) and [More Payment Scenarios](https://stripe.com/docs/payments/more-payment-scenarios).
        public var paymentMethod: PaymentMethod?

        public init(string: String? = nil, paymentMethod: PaymentMethod? = nil) {
            self.string = string
            self.paymentMethod = paymentMethod
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.paymentMethod = try? container.decode(PaymentMethod.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = paymentMethod { try container.encode(value) }
        }
    }

    /// ID of the default payment source for the invoice. It must belong to the customer associated with the invoice and be in a chargeable state. If not set, defaults to the subscription's default source, if any, or to the customer's default source.
    public struct DefaultSource: Codable {
        public var string: String?
        /// These bank accounts are payment methods on `Customer` objects.
        /// 
        /// On the other hand [External Accounts](https://stripe.com/docs/api#external_accounts) are transfer
        /// destinations on `Account` objects for [Custom accounts](https://stripe.com/docs/connect/custom-accounts).
        /// They can be bank accounts or debit cards as well, and are documented in the links above.
        /// 
        /// Related guide: [Bank Debits and Transfers](https://stripe.com/docs/payments/bank-debits-transfers).
        public var bankAccount: BankAccount?
        /// You can store multiple cards on a customer in order to charge the customer
        /// later. You can also store multiple debit cards on a recipient in order to
        /// transfer to those cards later.
        /// 
        /// Related guide: [Card Payments with Sources](https://stripe.com/docs/sources/cards).
        public var card: Card?
        /// `Source` objects allow you to accept a variety of payment methods. They
        /// represent a customer's payment instrument, and can be used with the Stripe API
        /// just like a `Card` object: once chargeable, they can be charged, or can be
        /// attached to customers.
        /// 
        /// Related guides: [Sources API](https://stripe.com/docs/sources) and [Sources & Customers](https://stripe.com/docs/sources/customers).
        public var source: Source?

        public init(string: String? = nil, bankAccount: BankAccount? = nil, card: Card? = nil, source: Source? = nil) {
            self.string = string
            self.bankAccount = bankAccount
            self.card = card
            self.source = source
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.bankAccount = try? container.decode(BankAccount.self)
            self.card = try? container.decode(Card.self)
            self.source = try? container.decode(Source.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = bankAccount { try container.encode(value) }
            if let value = card { try container.encode(value) }
            if let value = source { try container.encode(value) }
        }
    }

    public struct DiscountsItem: Codable {
        public var string: String?
        /// A discount represents the actual application of a [coupon](https://stripe.com/docs/api#coupons) or [promotion code](https://stripe.com/docs/api#promotion_codes).
        /// It contains information about when the discount began, when it will end, and what it is applied to.
        /// 
        /// Related guide: [Applying Discounts to Subscriptions](https://stripe.com/docs/billing/subscriptions/discounts).
        public var discount: Discount?
        public var deletedDiscount: DeletedDiscount?

        public init(string: String? = nil, discount: Discount? = nil, deletedDiscount: DeletedDiscount? = nil) {
            self.string = string
            self.discount = discount
            self.deletedDiscount = deletedDiscount
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.discount = try? container.decode(Discount.self)
            self.deletedDiscount = try? container.decode(DeletedDiscount.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = discount { try container.encode(value) }
            if let value = deletedDiscount { try container.encode(value) }
        }
    }

    /// InvoiceLinesList
    ///
    /// The individual line items that make up the invoice. `lines` is sorted as follows: invoice items in reverse chronological order, followed by the subscription, if any.
    public struct Lines: Codable {
        /// Details about each object.
        public var data: [LineItem]
        /// True if this list has another page of items after this one that can be fetched.
        public var hasMore: Bool
        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public var object: Object
        /// The URL where this list can be accessed.
        public var url: String

        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public enum Object: String, Codable, CaseIterable {
            case list
        }

        public init(data: [LineItem], hasMore: Bool, object: Object, url: String) {
            self.data = data
            self.hasMore = hasMore
            self.object = object
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.data = try values.decode([LineItem].self, forKey: "data")
            self.hasMore = try values.decode(Bool.self, forKey: "has_more")
            self.object = try values.decode(Object.self, forKey: "object")
            self.url = try values.decode(String.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(data, forKey: "data")
            try values.encode(hasMore, forKey: "has_more")
            try values.encode(object, forKey: "object")
            try values.encode(url, forKey: "url")
        }
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case invoice
    }

    /// The account (if any) for which the funds of the invoice payment are intended. If set, the invoice will be presented with the branding and support information of the specified account. See the [Invoices with Connect](https://stripe.com/docs/billing/invoices/connect) documentation for details.
    public struct OnBehalfOf: Codable {
        public var string: String?
        /// This is an object representing a Stripe account. You can retrieve it to see
        /// properties on the account like its current e-mail address or if the account is
        /// enabled yet to make live charges.
        /// 
        /// Some properties, marked below, are available only to platforms that want to
        /// [create and manage Express or Custom accounts](https://stripe.com/docs/connect/accounts).
        public var account: Account?

        public init(string: String? = nil, account: Account? = nil) {
            self.string = string
            self.account = account
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.account = try? container.decode(Account.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = account { try container.encode(value) }
        }
    }

    /// The PaymentIntent associated with this invoice. The PaymentIntent is generated when the invoice is finalized, and can then be used to pay the invoice. Note that voiding an invoice will cancel the PaymentIntent.
    public final class PaymentIntent: Codable {
        public let string: String?
        /// A PaymentIntent guides you through the process of collecting a payment from your customer.
        /// We recommend that you create exactly one PaymentIntent for each order or
        /// customer session in your system. You can reference the PaymentIntent later to
        /// see the history of payment attempts for a particular session.
        /// 
        /// A PaymentIntent transitions through
        /// [multiple statuses](https://stripe.com/docs/payments/intents#intent-statuses)
        /// throughout its lifetime as it interfaces with Stripe.js to perform
        /// authentication flows and ultimately creates at most one successful charge.
        /// 
        /// Related guide: [Payment Intents API](https://stripe.com/docs/payments/payment-intents).
        public let paymentIntent: StripeKit.PaymentIntent?

        public init(string: String? = nil, paymentIntent: StripeKit.PaymentIntent? = nil) {
            self.string = string
            self.paymentIntent = paymentIntent
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.paymentIntent = try? container.decode(StripeKit.PaymentIntent.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = paymentIntent { try container.encode(value) }
        }
    }

    /// The quote this invoice was generated from.
    public final class Quote: Codable {
        public let string: String?
        /// A Quote is a way to model prices that you'd like to provide to a customer.
        /// Once accepted, it will automatically create an invoice, subscription or subscription schedule.
        public let quote: StripeKit.Quote?

        public init(string: String? = nil, quote: StripeKit.Quote? = nil) {
            self.string = string
            self.quote = quote
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.quote = try? container.decode(StripeKit.Quote.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = quote { try container.encode(value) }
        }
    }

    /// The status of the invoice, one of `draft`, `open`, `paid`, `uncollectible`, or `void`. [Learn more](https://stripe.com/docs/billing/invoices/workflow#workflow-overview)
    public enum Status: String, Codable, CaseIterable {
        case deleted
        case draft
        case `open`
        case paid
        case uncollectible
        case void
    }

    /// The subscription that this invoice was prepared for, if any.
    public final class Subscription: Codable {
        public let string: String?
        /// Subscriptions allow you to charge a customer on a recurring basis.
        /// 
        /// Related guide: [Creating Subscriptions](https://stripe.com/docs/billing/subscriptions/creating).
        public let subscription: StripeKit.Subscription?

        public init(string: String? = nil, subscription: StripeKit.Subscription? = nil) {
            self.string = string
            self.subscription = subscription
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.subscription = try? container.decode(StripeKit.Subscription.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = subscription { try container.encode(value) }
        }
    }

    /// ID of the test clock this invoice belongs to.
    public struct TestClock: Codable {
        public var string: String?
        /// TestClock
        ///
        /// A test clock enables deterministic control over objects in testmode. With a test clock, you can create
        /// objects at a frozen time in the past or future, and advance to a specific future time to observe webhooks and state changes. After the clock advances,
        /// you can either validate the current state of your scenario (and test your assumptions), change the current state of your scenario (and test more complex scenarios), or keep advancing forward in time.
        public var testHelpersTestClock: TestHelpersTestClock?

        public init(string: String? = nil, testHelpersTestClock: TestHelpersTestClock? = nil) {
            self.string = string
            self.testHelpersTestClock = testHelpersTestClock
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.testHelpersTestClock = try? container.decode(TestHelpersTestClock.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = testHelpersTestClock { try container.encode(value) }
        }
    }

    public init(accountCountry: String? = nil, accountName: String? = nil, accountTaxIDs: [AccountTaxID]? = nil, amountDue: Int, amountPaid: Int, amountRemaining: Int, application: Application? = nil, applicationFeeAmount: Int? = nil, attemptCount: Int, isAttempted: Bool, isAutoAdvance: Bool? = nil, automaticTax: AutomaticTax, billingReason: BillingReason? = nil, charge: Charge? = nil, collectionMethod: CollectionMethod, created: Int, currency: String, customFields: [InvoiceSettingCustomField]? = nil, customer: Customer? = nil, customerAddress: Address? = nil, customerEmail: String? = nil, customerName: String? = nil, customerPhone: String? = nil, customerShipping: Shipping? = nil, customerTaxExempt: CustomerTaxExempt? = nil, customerTaxIDs: [InvoicesResourceInvoiceTaxID]? = nil, defaultPaymentMethod: DefaultPaymentMethod? = nil, defaultSource: DefaultSource? = nil, defaultTaxRates: [TaxRate], description: String? = nil, discount: Discount? = nil, discounts: [DiscountsItem]? = nil, dueDate: Int? = nil, endingBalance: Int? = nil, footer: String? = nil, hostedInvoiceURL: String? = nil, id: String? = nil, invoicePdf: String? = nil, lastFinalizationError: APIErrors? = nil, lines: Lines, isLivemode: Bool, metadata: [String: String]? = nil, nextPaymentAttempt: Int? = nil, number: String? = nil, object: Object, onBehalfOf: OnBehalfOf? = nil, isPaid: Bool, isPaidOutOfBand: Bool, paymentIntent: PaymentIntent? = nil, paymentSettings: InvoicesPaymentSettings, periodEnd: Int, periodStart: Int, postPaymentCreditNotesAmount: Int, prePaymentCreditNotesAmount: Int, quote: Quote? = nil, receiptNumber: String? = nil, renderingOptions: InvoiceSettingRenderingOptions? = nil, startingBalance: Int, statementDescriptor: String? = nil, status: Status? = nil, statusTransitions: InvoicesStatusTransitions, subscription: Subscription? = nil, subscriptionProrationDate: Int? = nil, subtotal: Int, subtotalExcludingTax: Int? = nil, tax: Int? = nil, testClock: TestClock? = nil, thresholdReason: InvoiceThresholdReason? = nil, total: Int, totalDiscountAmounts: [DiscountsResourceDiscountAmount]? = nil, totalExcludingTax: Int? = nil, totalTaxAmounts: [InvoiceTaxAmount], transferData: InvoiceTransferData? = nil, webhooksDeliveredAt: Int? = nil) {
        self.accountCountry = accountCountry
        self.accountName = accountName
        self.accountTaxIDs = accountTaxIDs
        self.amountDue = amountDue
        self.amountPaid = amountPaid
        self.amountRemaining = amountRemaining
        self.application = application
        self.applicationFeeAmount = applicationFeeAmount
        self.attemptCount = attemptCount
        self.isAttempted = isAttempted
        self.isAutoAdvance = isAutoAdvance
        self.automaticTax = automaticTax
        self.billingReason = billingReason
        self.charge = charge
        self.collectionMethod = collectionMethod
        self.created = created
        self.currency = currency
        self.customFields = customFields
        self.customer = customer
        self.customerAddress = customerAddress
        self.customerEmail = customerEmail
        self.customerName = customerName
        self.customerPhone = customerPhone
        self.customerShipping = customerShipping
        self.customerTaxExempt = customerTaxExempt
        self.customerTaxIDs = customerTaxIDs
        self.defaultPaymentMethod = defaultPaymentMethod
        self.defaultSource = defaultSource
        self.defaultTaxRates = defaultTaxRates
        self.description = description
        self.discount = discount
        self.discounts = discounts
        self.dueDate = dueDate
        self.endingBalance = endingBalance
        self.footer = footer
        self.hostedInvoiceURL = hostedInvoiceURL
        self.id = id
        self.invoicePdf = invoicePdf
        self.lastFinalizationError = lastFinalizationError
        self.lines = lines
        self.isLivemode = isLivemode
        self.metadata = metadata
        self.nextPaymentAttempt = nextPaymentAttempt
        self.number = number
        self.object = object
        self.onBehalfOf = onBehalfOf
        self.isPaid = isPaid
        self.isPaidOutOfBand = isPaidOutOfBand
        self.paymentIntent = paymentIntent
        self.paymentSettings = paymentSettings
        self.periodEnd = periodEnd
        self.periodStart = periodStart
        self.postPaymentCreditNotesAmount = postPaymentCreditNotesAmount
        self.prePaymentCreditNotesAmount = prePaymentCreditNotesAmount
        self.quote = quote
        self.receiptNumber = receiptNumber
        self.renderingOptions = renderingOptions
        self.startingBalance = startingBalance
        self.statementDescriptor = statementDescriptor
        self.status = status
        self.statusTransitions = statusTransitions
        self.subscription = subscription
        self.subscriptionProrationDate = subscriptionProrationDate
        self.subtotal = subtotal
        self.subtotalExcludingTax = subtotalExcludingTax
        self.tax = tax
        self.testClock = testClock
        self.thresholdReason = thresholdReason
        self.total = total
        self.totalDiscountAmounts = totalDiscountAmounts
        self.totalExcludingTax = totalExcludingTax
        self.totalTaxAmounts = totalTaxAmounts
        self.transferData = transferData
        self.webhooksDeliveredAt = webhooksDeliveredAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.accountCountry = try values.decodeIfPresent(String.self, forKey: "account_country")
        self.accountName = try values.decodeIfPresent(String.self, forKey: "account_name")
        self.accountTaxIDs = try values.decodeIfPresent([AccountTaxID].self, forKey: "account_tax_ids")
        self.amountDue = try values.decode(Int.self, forKey: "amount_due")
        self.amountPaid = try values.decode(Int.self, forKey: "amount_paid")
        self.amountRemaining = try values.decode(Int.self, forKey: "amount_remaining")
        self.application = try values.decodeIfPresent(Application.self, forKey: "application")
        self.applicationFeeAmount = try values.decodeIfPresent(Int.self, forKey: "application_fee_amount")
        self.attemptCount = try values.decode(Int.self, forKey: "attempt_count")
        self.isAttempted = try values.decode(Bool.self, forKey: "attempted")
        self.isAutoAdvance = try values.decodeIfPresent(Bool.self, forKey: "auto_advance")
        self.automaticTax = try values.decode(AutomaticTax.self, forKey: "automatic_tax")
        self.billingReason = try values.decodeIfPresent(BillingReason.self, forKey: "billing_reason")
        self.charge = try values.decodeIfPresent(Charge.self, forKey: "charge")
        self.collectionMethod = try values.decode(CollectionMethod.self, forKey: "collection_method")
        self.created = try values.decode(Int.self, forKey: "created")
        self.currency = try values.decode(String.self, forKey: "currency")
        self.customFields = try values.decodeIfPresent([InvoiceSettingCustomField].self, forKey: "custom_fields")
        self.customer = try values.decodeIfPresent(Customer.self, forKey: "customer")
        self.customerAddress = try values.decodeIfPresent(Address.self, forKey: "customer_address")
        self.customerEmail = try values.decodeIfPresent(String.self, forKey: "customer_email")
        self.customerName = try values.decodeIfPresent(String.self, forKey: "customer_name")
        self.customerPhone = try values.decodeIfPresent(String.self, forKey: "customer_phone")
        self.customerShipping = try values.decodeIfPresent(Shipping.self, forKey: "customer_shipping")
        self.customerTaxExempt = try values.decodeIfPresent(CustomerTaxExempt.self, forKey: "customer_tax_exempt")
        self.customerTaxIDs = try values.decodeIfPresent([InvoicesResourceInvoiceTaxID].self, forKey: "customer_tax_ids")
        self.defaultPaymentMethod = try values.decodeIfPresent(DefaultPaymentMethod.self, forKey: "default_payment_method")
        self.defaultSource = try values.decodeIfPresent(DefaultSource.self, forKey: "default_source")
        self.defaultTaxRates = try values.decode([TaxRate].self, forKey: "default_tax_rates")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.discount = try values.decodeIfPresent(Discount.self, forKey: "discount")
        self.discounts = try values.decodeIfPresent([DiscountsItem].self, forKey: "discounts")
        self.dueDate = try values.decodeIfPresent(Int.self, forKey: "due_date")
        self.endingBalance = try values.decodeIfPresent(Int.self, forKey: "ending_balance")
        self.footer = try values.decodeIfPresent(String.self, forKey: "footer")
        self.hostedInvoiceURL = try values.decodeIfPresent(String.self, forKey: "hosted_invoice_url")
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.invoicePdf = try values.decodeIfPresent(String.self, forKey: "invoice_pdf")
        self.lastFinalizationError = try values.decodeIfPresent(APIErrors.self, forKey: "last_finalization_error")
        self.lines = try values.decode(Lines.self, forKey: "lines")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.metadata = try values.decodeIfPresent([String: String].self, forKey: "metadata")
        self.nextPaymentAttempt = try values.decodeIfPresent(Int.self, forKey: "next_payment_attempt")
        self.number = try values.decodeIfPresent(String.self, forKey: "number")
        self.object = try values.decode(Object.self, forKey: "object")
        self.onBehalfOf = try values.decodeIfPresent(OnBehalfOf.self, forKey: "on_behalf_of")
        self.isPaid = try values.decode(Bool.self, forKey: "paid")
        self.isPaidOutOfBand = try values.decode(Bool.self, forKey: "paid_out_of_band")
        self.paymentIntent = try values.decodeIfPresent(PaymentIntent.self, forKey: "payment_intent")
        self.paymentSettings = try values.decode(InvoicesPaymentSettings.self, forKey: "payment_settings")
        self.periodEnd = try values.decode(Int.self, forKey: "period_end")
        self.periodStart = try values.decode(Int.self, forKey: "period_start")
        self.postPaymentCreditNotesAmount = try values.decode(Int.self, forKey: "post_payment_credit_notes_amount")
        self.prePaymentCreditNotesAmount = try values.decode(Int.self, forKey: "pre_payment_credit_notes_amount")
        self.quote = try values.decodeIfPresent(Quote.self, forKey: "quote")
        self.receiptNumber = try values.decodeIfPresent(String.self, forKey: "receipt_number")
        self.renderingOptions = try values.decodeIfPresent(InvoiceSettingRenderingOptions.self, forKey: "rendering_options")
        self.startingBalance = try values.decode(Int.self, forKey: "starting_balance")
        self.statementDescriptor = try values.decodeIfPresent(String.self, forKey: "statement_descriptor")
        self.status = try values.decodeIfPresent(Status.self, forKey: "status")
        self.statusTransitions = try values.decode(InvoicesStatusTransitions.self, forKey: "status_transitions")
        self.subscription = try values.decodeIfPresent(Subscription.self, forKey: "subscription")
        self.subscriptionProrationDate = try values.decodeIfPresent(Int.self, forKey: "subscription_proration_date")
        self.subtotal = try values.decode(Int.self, forKey: "subtotal")
        self.subtotalExcludingTax = try values.decodeIfPresent(Int.self, forKey: "subtotal_excluding_tax")
        self.tax = try values.decodeIfPresent(Int.self, forKey: "tax")
        self.testClock = try values.decodeIfPresent(TestClock.self, forKey: "test_clock")
        self.thresholdReason = try values.decodeIfPresent(InvoiceThresholdReason.self, forKey: "threshold_reason")
        self.total = try values.decode(Int.self, forKey: "total")
        self.totalDiscountAmounts = try values.decodeIfPresent([DiscountsResourceDiscountAmount].self, forKey: "total_discount_amounts")
        self.totalExcludingTax = try values.decodeIfPresent(Int.self, forKey: "total_excluding_tax")
        self.totalTaxAmounts = try values.decode([InvoiceTaxAmount].self, forKey: "total_tax_amounts")
        self.transferData = try values.decodeIfPresent(InvoiceTransferData.self, forKey: "transfer_data")
        self.webhooksDeliveredAt = try values.decodeIfPresent(Int.self, forKey: "webhooks_delivered_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(accountCountry, forKey: "account_country")
        try values.encodeIfPresent(accountName, forKey: "account_name")
        try values.encodeIfPresent(accountTaxIDs, forKey: "account_tax_ids")
        try values.encode(amountDue, forKey: "amount_due")
        try values.encode(amountPaid, forKey: "amount_paid")
        try values.encode(amountRemaining, forKey: "amount_remaining")
        try values.encodeIfPresent(application, forKey: "application")
        try values.encodeIfPresent(applicationFeeAmount, forKey: "application_fee_amount")
        try values.encode(attemptCount, forKey: "attempt_count")
        try values.encode(isAttempted, forKey: "attempted")
        try values.encodeIfPresent(isAutoAdvance, forKey: "auto_advance")
        try values.encode(automaticTax, forKey: "automatic_tax")
        try values.encodeIfPresent(billingReason, forKey: "billing_reason")
        try values.encodeIfPresent(charge, forKey: "charge")
        try values.encode(collectionMethod, forKey: "collection_method")
        try values.encode(created, forKey: "created")
        try values.encode(currency, forKey: "currency")
        try values.encodeIfPresent(customFields, forKey: "custom_fields")
        try values.encodeIfPresent(customer, forKey: "customer")
        try values.encodeIfPresent(customerAddress, forKey: "customer_address")
        try values.encodeIfPresent(customerEmail, forKey: "customer_email")
        try values.encodeIfPresent(customerName, forKey: "customer_name")
        try values.encodeIfPresent(customerPhone, forKey: "customer_phone")
        try values.encodeIfPresent(customerShipping, forKey: "customer_shipping")
        try values.encodeIfPresent(customerTaxExempt, forKey: "customer_tax_exempt")
        try values.encodeIfPresent(customerTaxIDs, forKey: "customer_tax_ids")
        try values.encodeIfPresent(defaultPaymentMethod, forKey: "default_payment_method")
        try values.encodeIfPresent(defaultSource, forKey: "default_source")
        try values.encode(defaultTaxRates, forKey: "default_tax_rates")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(discount, forKey: "discount")
        try values.encodeIfPresent(discounts, forKey: "discounts")
        try values.encodeIfPresent(dueDate, forKey: "due_date")
        try values.encodeIfPresent(endingBalance, forKey: "ending_balance")
        try values.encodeIfPresent(footer, forKey: "footer")
        try values.encodeIfPresent(hostedInvoiceURL, forKey: "hosted_invoice_url")
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(invoicePdf, forKey: "invoice_pdf")
        try values.encodeIfPresent(lastFinalizationError, forKey: "last_finalization_error")
        try values.encode(lines, forKey: "lines")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encodeIfPresent(nextPaymentAttempt, forKey: "next_payment_attempt")
        try values.encodeIfPresent(number, forKey: "number")
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(onBehalfOf, forKey: "on_behalf_of")
        try values.encode(isPaid, forKey: "paid")
        try values.encode(isPaidOutOfBand, forKey: "paid_out_of_band")
        try values.encodeIfPresent(paymentIntent, forKey: "payment_intent")
        try values.encode(paymentSettings, forKey: "payment_settings")
        try values.encode(periodEnd, forKey: "period_end")
        try values.encode(periodStart, forKey: "period_start")
        try values.encode(postPaymentCreditNotesAmount, forKey: "post_payment_credit_notes_amount")
        try values.encode(prePaymentCreditNotesAmount, forKey: "pre_payment_credit_notes_amount")
        try values.encodeIfPresent(quote, forKey: "quote")
        try values.encodeIfPresent(receiptNumber, forKey: "receipt_number")
        try values.encodeIfPresent(renderingOptions, forKey: "rendering_options")
        try values.encode(startingBalance, forKey: "starting_balance")
        try values.encodeIfPresent(statementDescriptor, forKey: "statement_descriptor")
        try values.encodeIfPresent(status, forKey: "status")
        try values.encode(statusTransitions, forKey: "status_transitions")
        try values.encodeIfPresent(subscription, forKey: "subscription")
        try values.encodeIfPresent(subscriptionProrationDate, forKey: "subscription_proration_date")
        try values.encode(subtotal, forKey: "subtotal")
        try values.encodeIfPresent(subtotalExcludingTax, forKey: "subtotal_excluding_tax")
        try values.encodeIfPresent(tax, forKey: "tax")
        try values.encodeIfPresent(testClock, forKey: "test_clock")
        try values.encodeIfPresent(thresholdReason, forKey: "threshold_reason")
        try values.encode(total, forKey: "total")
        try values.encodeIfPresent(totalDiscountAmounts, forKey: "total_discount_amounts")
        try values.encodeIfPresent(totalExcludingTax, forKey: "total_excluding_tax")
        try values.encode(totalTaxAmounts, forKey: "total_tax_amounts")
        try values.encodeIfPresent(transferData, forKey: "transfer_data")
        try values.encodeIfPresent(webhooksDeliveredAt, forKey: "webhooks_delivered_at")
    }
}
