// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// RadarReview
///
/// Reviews can be used to supplement automated fraud detection with human expertise.
/// 
/// Learn more about [Radar](/radar) and reviewing payments
/// [here](https://stripe.com/docs/radar/reviews).
public struct Review: Codable {
    /// The ZIP or postal code of the card used, if applicable.
    public var billingZip: String?
    /// The charge associated with this review.
    public var charge: Charge?
    /// The reason the review was closed, or null if it has not yet been closed. One of `approved`, `refunded`, `refunded_as_fraud`, `disputed`, or `redacted`.
    public var closedReason: ClosedReason?
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public var created: Int
    /// Unique identifier for the object.
    public var id: String
    /// The IP address where the payment originated.
    public var ipAddress: String?
    /// Information related to the location of the payment. Note that this information is an approximation and attempts to locate the nearest population center - it should not be used to determine a specific address.
    public var ipAddressLocation: RadarReviewResourceLocation?
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// If `true`, the review needs action.
    public var isOpen: Bool
    /// The reason the review was opened. One of `rule` or `manual`.
    public var openedReason: OpenedReason
    /// The PaymentIntent ID associated with this review, if one exists.
    public var paymentIntent: PaymentIntent?
    /// The reason the review is currently open or closed. One of `rule`, `manual`, `approved`, `refunded`, `refunded_as_fraud`, `disputed`, or `redacted`.
    public var reason: String
    /// Information related to the browsing session of the user who initiated the payment.
    public var session: RadarReviewResourceSession?

    /// The charge associated with this review.
    public final class Charge: Codable {
        public let string: String?
        /// To charge a credit or a debit card, you create a `Charge` object. You can
        /// retrieve and refund individual charges as well as list all charges. Charges
        /// are identified by a unique, random ID.
        /// 
        /// Related guide: [Accept a payment with the Charges API](https://stripe.com/docs/payments/accept-a-payment-charges).
        public let charge: StripeKit.Charge?

        public init(string: String? = nil, charge: StripeKit.Charge? = nil) {
            self.string = string
            self.charge = charge
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.charge = try? container.decode(StripeKit.Charge.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = charge { try container.encode(value) }
        }
    }

    /// The reason the review was closed, or null if it has not yet been closed. One of `approved`, `refunded`, `refunded_as_fraud`, `disputed`, or `redacted`.
    public enum ClosedReason: String, Codable, CaseIterable {
        case approved
        case disputed
        case redacted
        case refunded
        case refundedAsFraud = "refunded_as_fraud"
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case review
    }

    /// The reason the review was opened. One of `rule` or `manual`.
    public enum OpenedReason: String, Codable, CaseIterable {
        case manual
        case rule
    }

    /// The PaymentIntent ID associated with this review, if one exists.
    public final class PaymentIntent: Codable {
        public let string: String?
        /// A PaymentIntent guides you through the process of collecting a payment from your customer.
        /// We recommend that you create exactly one PaymentIntent for each order or
        /// customer session in your system. You can reference the PaymentIntent later to
        /// see the history of payment attempts for a particular session.
        /// 
        /// A PaymentIntent transitions through
        /// [multiple statuses](https://stripe.com/docs/payments/intents#intent-statuses)
        /// throughout its lifetime as it interfaces with Stripe.js to perform
        /// authentication flows and ultimately creates at most one successful charge.
        /// 
        /// Related guide: [Payment Intents API](https://stripe.com/docs/payments/payment-intents).
        public let paymentIntent: StripeKit.PaymentIntent?

        public init(string: String? = nil, paymentIntent: StripeKit.PaymentIntent? = nil) {
            self.string = string
            self.paymentIntent = paymentIntent
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.paymentIntent = try? container.decode(StripeKit.PaymentIntent.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = paymentIntent { try container.encode(value) }
        }
    }

    public init(billingZip: String? = nil, charge: Charge? = nil, closedReason: ClosedReason? = nil, created: Int, id: String, ipAddress: String? = nil, ipAddressLocation: RadarReviewResourceLocation? = nil, isLivemode: Bool, object: Object, isOpen: Bool, openedReason: OpenedReason, paymentIntent: PaymentIntent? = nil, reason: String, session: RadarReviewResourceSession? = nil) {
        self.billingZip = billingZip
        self.charge = charge
        self.closedReason = closedReason
        self.created = created
        self.id = id
        self.ipAddress = ipAddress
        self.ipAddressLocation = ipAddressLocation
        self.isLivemode = isLivemode
        self.object = object
        self.isOpen = isOpen
        self.openedReason = openedReason
        self.paymentIntent = paymentIntent
        self.reason = reason
        self.session = session
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.billingZip = try values.decodeIfPresent(String.self, forKey: "billing_zip")
        self.charge = try values.decodeIfPresent(Charge.self, forKey: "charge")
        self.closedReason = try values.decodeIfPresent(ClosedReason.self, forKey: "closed_reason")
        self.created = try values.decode(Int.self, forKey: "created")
        self.id = try values.decode(String.self, forKey: "id")
        self.ipAddress = try values.decodeIfPresent(String.self, forKey: "ip_address")
        self.ipAddressLocation = try values.decodeIfPresent(RadarReviewResourceLocation.self, forKey: "ip_address_location")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.object = try values.decode(Object.self, forKey: "object")
        self.isOpen = try values.decode(Bool.self, forKey: "open")
        self.openedReason = try values.decode(OpenedReason.self, forKey: "opened_reason")
        self.paymentIntent = try values.decodeIfPresent(PaymentIntent.self, forKey: "payment_intent")
        self.reason = try values.decode(String.self, forKey: "reason")
        self.session = try values.decodeIfPresent(RadarReviewResourceSession.self, forKey: "session")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(billingZip, forKey: "billing_zip")
        try values.encodeIfPresent(charge, forKey: "charge")
        try values.encodeIfPresent(closedReason, forKey: "closed_reason")
        try values.encode(created, forKey: "created")
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(ipAddress, forKey: "ip_address")
        try values.encodeIfPresent(ipAddressLocation, forKey: "ip_address_location")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encode(object, forKey: "object")
        try values.encode(isOpen, forKey: "open")
        try values.encode(openedReason, forKey: "opened_reason")
        try values.encodeIfPresent(paymentIntent, forKey: "payment_intent")
        try values.encode(reason, forKey: "reason")
        try values.encodeIfPresent(session, forKey: "session")
    }
}
