// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// A SetupIntent guides you through the process of setting up and saving a customer's payment credentials for future payments.
/// For example, you could use a SetupIntent to set up and save your customer's card without immediately collecting a payment.
/// Later, you can use [PaymentIntents](https://stripe.com/docs/api#payment_intents) to drive the payment flow.
/// 
/// Create a SetupIntent as soon as you're ready to collect your customer's payment credentials.
/// Do not maintain long-lived, unconfirmed SetupIntents as they may no longer be valid.
/// The SetupIntent then transitions through multiple [statuses](https://stripe.com/docs/payments/intents#intent-statuses) as it guides
/// you through the setup process.
/// 
/// Successful SetupIntents result in payment credentials that are optimized for future payments.
/// For example, cardholders in [certain regions](/guides/strong-customer-authentication) may need to be run through
/// [Strong Customer Authentication](https://stripe.com/docs/strong-customer-authentication) at the time of payment method collection
/// in order to streamline later [off-session payments](https://stripe.com/docs/payments/setup-intents).
/// If the SetupIntent is used with a [Customer](https://stripe.com/docs/api#setup_intent_object-customer), upon success,
/// it will automatically attach the resulting payment method to that Customer.
/// We recommend using SetupIntents or [setup_future_usage](https://stripe.com/docs/api#payment_intent_object-setup_future_usage) on
/// PaymentIntents to save payment methods in order to prevent saving invalid or unoptimized payment methods.
/// 
/// By using SetupIntents, you ensure that your customers experience the minimum set of required friction,
/// even as regulations change over time.
/// 
/// Related guide: [Setup Intents API](https://stripe.com/docs/payments/setup-intents).
public struct SetupIntent: Codable {
    /// ID of the Connect application that created the SetupIntent.
    public var application: Application?
    /// If present, the SetupIntent's payment method will be attached to the in-context Stripe Account.
    /// 
    /// It can only be used for this Stripe Accountâ€™s own money movement flows like InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a Customer.
    public var isAttachToSelf: Bool?
    /// Reason for cancellation of this SetupIntent, one of `abandoned`, `requested_by_customer`, or `duplicate`.
    public var cancellationReason: CancellationReason?
    /// The client secret of this SetupIntent. Used for client-side retrieval using a publishable key.
    /// 
    /// The client secret can be used to complete payment setup from your frontend. It should not be stored, logged, or exposed to anyone other than the customer. Make sure that you have TLS enabled on any page that includes the client secret.
    public var clientSecret: String?
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public var created: Int
    /// ID of the Customer this SetupIntent belongs to, if one exists.
    /// 
    /// If present, the SetupIntent's payment method will be attached to the Customer on successful setup. Payment methods attached to other Customers cannot be used with this SetupIntent.
    public var customer: Customer?
    /// An arbitrary string attached to the object. Often useful for displaying to users.
    public var description: String?
    /// Indicates the directions of money movement for which this payment method is intended to be used.
    /// 
    /// Include `inbound` if you intend to use the payment method as the origin to pull funds from. Include `outbound` if you intend to use the payment method as the destination to send funds to. You can include both if you intend to use the payment method for both purposes.
    public var flowDirections: [FlowDirection]?
    /// Unique identifier for the object.
    public var id: String
    /// The error encountered in the previous SetupIntent confirmation.
    public var lastSetupError: APIErrors?
    /// The most recent SetupAttempt for this SetupIntent.
    public var latestAttempt: LatestAttempt?
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// ID of the multi use Mandate generated by the SetupIntent.
    public var mandate: Mandate?
    /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    public var metadata: [String: String]?
    /// If present, this property tells you what actions you need to take in order for your customer to continue payment setup.
    public var nextAction: SetupIntentNextAction?
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// The account (if any) for which the setup is intended.
    public var onBehalfOf: OnBehalfOf?
    /// ID of the payment method used with this SetupIntent.
    public var paymentMethod: PaymentMethod?
    /// Payment-method-specific configuration for this SetupIntent.
    public var paymentMethodOptions: SetupIntentPaymentMethodOptions?
    /// The list of payment method types (e.g. card) that this SetupIntent is allowed to set up.
    public var paymentMethodTypes: [String]
    /// ID of the single_use Mandate generated by the SetupIntent.
    public var singleUseMandate: SingleUseMandate?
    /// [Status](https://stripe.com/docs/payments/intents#intent-statuses) of this SetupIntent, one of `requires_payment_method`, `requires_confirmation`, `requires_action`, `processing`, `canceled`, or `succeeded`.
    public var status: Status
    /// Indicates how the payment method is intended to be used in the future.
    /// 
    /// Use `on_session` if you intend to only reuse the payment method when the customer is in your checkout flow. Use `off_session` if your customer may or may not be in your checkout flow. If not provided, this value defaults to `off_session`.
    public var usage: String

    /// ID of the Connect application that created the SetupIntent.
    public final class Application: Codable {
        public let string: String?
        public let application: StripeKit.Application?

        public init(string: String? = nil, application: StripeKit.Application? = nil) {
            self.string = string
            self.application = application
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.application = try? container.decode(StripeKit.Application.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = application { try container.encode(value) }
        }
    }

    /// Reason for cancellation of this SetupIntent, one of `abandoned`, `requested_by_customer`, or `duplicate`.
    public enum CancellationReason: String, Codable, CaseIterable {
        case abandoned
        case duplicate
        case requestedByCustomer = "requested_by_customer"
    }

    /// ID of the Customer this SetupIntent belongs to, if one exists.
    /// 
    /// If present, the SetupIntent's payment method will be attached to the Customer on successful setup. Payment methods attached to other Customers cannot be used with this SetupIntent.
    public final class Customer: Codable {
        public let string: String?
        /// This object represents a customer of your business. It lets you create recurring charges and track payments that belong to the same customer.
        /// 
        /// Related guide: [Save a card during payment](https://stripe.com/docs/payments/save-during-payment).
        public let customer: StripeKit.Customer?
        public let deletedCustomer: DeletedCustomer?

        public init(string: String? = nil, customer: StripeKit.Customer? = nil, deletedCustomer: DeletedCustomer? = nil) {
            self.string = string
            self.customer = customer
            self.deletedCustomer = deletedCustomer
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.customer = try? container.decode(StripeKit.Customer.self)
            self.deletedCustomer = try? container.decode(DeletedCustomer.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = customer { try container.encode(value) }
            if let value = deletedCustomer { try container.encode(value) }
        }
    }

    public enum FlowDirection: String, Codable, CaseIterable {
        case inbound
        case outbound
    }

    /// The most recent SetupAttempt for this SetupIntent.
    public struct LatestAttempt: Codable {
        public var string: String?
        /// PaymentFlowsSetupIntentSetupAttempt
        ///
        /// A SetupAttempt describes one attempted confirmation of a SetupIntent,
        /// whether that confirmation was successful or unsuccessful. You can use
        /// SetupAttempts to inspect details of a specific attempt at setting up a
        /// payment method using a SetupIntent.
        public var setupAttempt: SetupAttempt?

        public init(string: String? = nil, setupAttempt: SetupAttempt? = nil) {
            self.string = string
            self.setupAttempt = setupAttempt
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.setupAttempt = try? container.decode(SetupAttempt.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = setupAttempt { try container.encode(value) }
        }
    }

    /// ID of the multi use Mandate generated by the SetupIntent.
    public final class Mandate: Codable {
        public let string: String?
        /// A Mandate is a record of the permission a customer has given you to debit their payment method.
        public let mandate: StripeKit.Mandate?

        public init(string: String? = nil, mandate: StripeKit.Mandate? = nil) {
            self.string = string
            self.mandate = mandate
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.mandate = try? container.decode(StripeKit.Mandate.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = mandate { try container.encode(value) }
        }
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case setupIntent = "setup_intent"
    }

    /// The account (if any) for which the setup is intended.
    public struct OnBehalfOf: Codable {
        public var string: String?
        /// This is an object representing a Stripe account. You can retrieve it to see
        /// properties on the account like its current e-mail address or if the account is
        /// enabled yet to make live charges.
        /// 
        /// Some properties, marked below, are available only to platforms that want to
        /// [create and manage Express or Custom accounts](https://stripe.com/docs/connect/accounts).
        public var account: Account?

        public init(string: String? = nil, account: Account? = nil) {
            self.string = string
            self.account = account
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.account = try? container.decode(Account.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = account { try container.encode(value) }
        }
    }

    /// ID of the payment method used with this SetupIntent.
    public final class PaymentMethod: Codable {
        public let string: String?
        /// PaymentMethod objects represent your customer's payment instruments.
        /// You can use them with [PaymentIntents](https://stripe.com/docs/payments/payment-intents) to collect payments or save them to
        /// Customer objects to store instrument details for future payments.
        /// 
        /// Related guides: [Payment Methods](https://stripe.com/docs/payments/payment-methods) and [More Payment Scenarios](https://stripe.com/docs/payments/more-payment-scenarios).
        public let paymentMethod: StripeKit.PaymentMethod?

        public init(string: String? = nil, paymentMethod: StripeKit.PaymentMethod? = nil) {
            self.string = string
            self.paymentMethod = paymentMethod
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.paymentMethod = try? container.decode(StripeKit.PaymentMethod.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = paymentMethod { try container.encode(value) }
        }
    }

    /// ID of the single_use Mandate generated by the SetupIntent.
    public struct SingleUseMandate: Codable {
        public var string: String?
        /// A Mandate is a record of the permission a customer has given you to debit their payment method.
        public var mandate: Mandate?

        public init(string: String? = nil, mandate: Mandate? = nil) {
            self.string = string
            self.mandate = mandate
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.mandate = try? container.decode(Mandate.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = mandate { try container.encode(value) }
        }
    }

    /// [Status](https://stripe.com/docs/payments/intents#intent-statuses) of this SetupIntent, one of `requires_payment_method`, `requires_confirmation`, `requires_action`, `processing`, `canceled`, or `succeeded`.
    public enum Status: String, Codable, CaseIterable {
        case canceled
        case processing
        case requiresAction = "requires_action"
        case requiresConfirmation = "requires_confirmation"
        case requiresPaymentMethod = "requires_payment_method"
        case succeeded
    }

    public init(application: Application? = nil, isAttachToSelf: Bool? = nil, cancellationReason: CancellationReason? = nil, clientSecret: String? = nil, created: Int, customer: Customer? = nil, description: String? = nil, flowDirections: [FlowDirection]? = nil, id: String, lastSetupError: APIErrors? = nil, latestAttempt: LatestAttempt? = nil, isLivemode: Bool, mandate: Mandate? = nil, metadata: [String: String]? = nil, nextAction: SetupIntentNextAction? = nil, object: Object, onBehalfOf: OnBehalfOf? = nil, paymentMethod: PaymentMethod? = nil, paymentMethodOptions: SetupIntentPaymentMethodOptions? = nil, paymentMethodTypes: [String], singleUseMandate: SingleUseMandate? = nil, status: Status, usage: String) {
        self.application = application
        self.isAttachToSelf = isAttachToSelf
        self.cancellationReason = cancellationReason
        self.clientSecret = clientSecret
        self.created = created
        self.customer = customer
        self.description = description
        self.flowDirections = flowDirections
        self.id = id
        self.lastSetupError = lastSetupError
        self.latestAttempt = latestAttempt
        self.isLivemode = isLivemode
        self.mandate = mandate
        self.metadata = metadata
        self.nextAction = nextAction
        self.object = object
        self.onBehalfOf = onBehalfOf
        self.paymentMethod = paymentMethod
        self.paymentMethodOptions = paymentMethodOptions
        self.paymentMethodTypes = paymentMethodTypes
        self.singleUseMandate = singleUseMandate
        self.status = status
        self.usage = usage
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.application = try values.decodeIfPresent(Application.self, forKey: "application")
        self.isAttachToSelf = try values.decodeIfPresent(Bool.self, forKey: "attach_to_self")
        self.cancellationReason = try values.decodeIfPresent(CancellationReason.self, forKey: "cancellation_reason")
        self.clientSecret = try values.decodeIfPresent(String.self, forKey: "client_secret")
        self.created = try values.decode(Int.self, forKey: "created")
        self.customer = try values.decodeIfPresent(Customer.self, forKey: "customer")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.flowDirections = try values.decodeIfPresent([FlowDirection].self, forKey: "flow_directions")
        self.id = try values.decode(String.self, forKey: "id")
        self.lastSetupError = try values.decodeIfPresent(APIErrors.self, forKey: "last_setup_error")
        self.latestAttempt = try values.decodeIfPresent(LatestAttempt.self, forKey: "latest_attempt")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.mandate = try values.decodeIfPresent(Mandate.self, forKey: "mandate")
        self.metadata = try values.decodeIfPresent([String: String].self, forKey: "metadata")
        self.nextAction = try values.decodeIfPresent(SetupIntentNextAction.self, forKey: "next_action")
        self.object = try values.decode(Object.self, forKey: "object")
        self.onBehalfOf = try values.decodeIfPresent(OnBehalfOf.self, forKey: "on_behalf_of")
        self.paymentMethod = try values.decodeIfPresent(PaymentMethod.self, forKey: "payment_method")
        self.paymentMethodOptions = try values.decodeIfPresent(SetupIntentPaymentMethodOptions.self, forKey: "payment_method_options")
        self.paymentMethodTypes = try values.decode([String].self, forKey: "payment_method_types")
        self.singleUseMandate = try values.decodeIfPresent(SingleUseMandate.self, forKey: "single_use_mandate")
        self.status = try values.decode(Status.self, forKey: "status")
        self.usage = try values.decode(String.self, forKey: "usage")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(application, forKey: "application")
        try values.encodeIfPresent(isAttachToSelf, forKey: "attach_to_self")
        try values.encodeIfPresent(cancellationReason, forKey: "cancellation_reason")
        try values.encodeIfPresent(clientSecret, forKey: "client_secret")
        try values.encode(created, forKey: "created")
        try values.encodeIfPresent(customer, forKey: "customer")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(flowDirections, forKey: "flow_directions")
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(lastSetupError, forKey: "last_setup_error")
        try values.encodeIfPresent(latestAttempt, forKey: "latest_attempt")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encodeIfPresent(mandate, forKey: "mandate")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encodeIfPresent(nextAction, forKey: "next_action")
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(onBehalfOf, forKey: "on_behalf_of")
        try values.encodeIfPresent(paymentMethod, forKey: "payment_method")
        try values.encodeIfPresent(paymentMethodOptions, forKey: "payment_method_options")
        try values.encode(paymentMethodTypes, forKey: "payment_method_types")
        try values.encodeIfPresent(singleUseMandate, forKey: "single_use_mandate")
        try values.encode(status, forKey: "status")
        try values.encode(usage, forKey: "usage")
    }
}
