// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct CurrencyOption: Codable {
    /// When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
    public var customUnitAmount: CustomUnitAmount?
    /// Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it cannot be changed.
    public var taxBehavior: TaxBehavior?
    /// Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`. See also the documentation for `billing_scheme`.
    public var tiers: [PriceTier]?
    /// The unit amount in %s to be charged, represented as a whole integer if possible. Only set if `billing_scheme=per_unit`.
    public var unitAmount: Int?
    /// The unit amount in %s to be charged, represented as a decimal string with at most 12 decimal places. Only set if `billing_scheme=per_unit`.
    public var unitAmountDecimal: String?

    /// Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it cannot be changed.
    public enum TaxBehavior: String, Codable, CaseIterable {
        case exclusive
        case inclusive
        case unspecified
    }

    public init(customUnitAmount: CustomUnitAmount? = nil, taxBehavior: TaxBehavior? = nil, tiers: [PriceTier]? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
        self.customUnitAmount = customUnitAmount
        self.taxBehavior = taxBehavior
        self.tiers = tiers
        self.unitAmount = unitAmount
        self.unitAmountDecimal = unitAmountDecimal
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.customUnitAmount = try values.decodeIfPresent(CustomUnitAmount.self, forKey: "custom_unit_amount")
        self.taxBehavior = try values.decodeIfPresent(TaxBehavior.self, forKey: "tax_behavior")
        self.tiers = try values.decodeIfPresent([PriceTier].self, forKey: "tiers")
        self.unitAmount = try values.decodeIfPresent(Int.self, forKey: "unit_amount")
        self.unitAmountDecimal = try values.decodeIfPresent(String.self, forKey: "unit_amount_decimal")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(customUnitAmount, forKey: "custom_unit_amount")
        try values.encodeIfPresent(taxBehavior, forKey: "tax_behavior")
        try values.encodeIfPresent(tiers, forKey: "tiers")
        try values.encodeIfPresent(unitAmount, forKey: "unit_amount")
        try values.encodeIfPresent(unitAmountDecimal, forKey: "unit_amount_decimal")
    }
}
