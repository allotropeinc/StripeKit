// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// To top up your Stripe balance, you create a top-up object. You can retrieve
/// individual top-ups, as well as list all top-ups. Top-ups are identified by a
/// unique, random ID.
/// 
/// Related guide: [Topping Up your Platform Account](https://stripe.com/docs/connect/top-ups).
public struct Topup: Codable {
    /// Amount transferred.
    public var amount: Int
    /// ID of the balance transaction that describes the impact of this top-up on your account balance. May not be specified depending on status of top-up.
    public var balanceTransaction: BalanceTransaction?
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public var created: Int
    /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    public var currency: String
    /// An arbitrary string attached to the object. Often useful for displaying to users.
    public var description: String?
    /// Date the funds are expected to arrive in your Stripe account for payouts. This factors in delays like weekends or bank holidays. May not be specified depending on status of top-up.
    public var expectedAvailabilityDate: Int?
    /// Error code explaining reason for top-up failure if available (see [the errors section](https://stripe.com/docs/api#errors) for a list of codes).
    public var failureCode: String?
    /// Message to user further explaining reason for top-up failure if available.
    public var failureMessage: String?
    /// Unique identifier for the object.
    public var id: String
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    public var metadata: [String: String]
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// For most Stripe users, the source of every top-up is a bank account. This hash is then the [source object](https://stripe.com/docs/api#source_object) describing that bank account.
    public var source: Source?
    /// Extra information about a top-up. This will appear on your source's bank statement. It must contain at least one letter.
    public var statementDescriptor: String?
    /// The status of the top-up is either `canceled`, `failed`, `pending`, `reversed`, or `succeeded`.
    public var status: Status
    /// A string that identifies this top-up as part of a group.
    public var transferGroup: String?

    /// ID of the balance transaction that describes the impact of this top-up on your account balance. May not be specified depending on status of top-up.
    public final class BalanceTransaction: Codable {
        public let string: String?
        /// Balance transactions represent funds moving through your Stripe account.
        /// They're created for every type of transaction that comes into or flows out of your Stripe account balance.
        /// 
        /// Related guide: [Balance Transaction Types](https://stripe.com/docs/reports/balance-transaction-types).
        public let balanceTransaction: StripeKit.BalanceTransaction?

        public init(string: String? = nil, balanceTransaction: StripeKit.BalanceTransaction? = nil) {
            self.string = string
            self.balanceTransaction = balanceTransaction
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.balanceTransaction = try? container.decode(StripeKit.BalanceTransaction.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = balanceTransaction { try container.encode(value) }
        }
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case topup
    }

    /// The status of the top-up is either `canceled`, `failed`, `pending`, `reversed`, or `succeeded`.
    public enum Status: String, Codable, CaseIterable {
        case canceled
        case failed
        case pending
        case reversed
        case succeeded
    }

    public init(amount: Int, balanceTransaction: BalanceTransaction? = nil, created: Int, currency: String, description: String? = nil, expectedAvailabilityDate: Int? = nil, failureCode: String? = nil, failureMessage: String? = nil, id: String, isLivemode: Bool, metadata: [String: String], object: Object, source: Source? = nil, statementDescriptor: String? = nil, status: Status, transferGroup: String? = nil) {
        self.amount = amount
        self.balanceTransaction = balanceTransaction
        self.created = created
        self.currency = currency
        self.description = description
        self.expectedAvailabilityDate = expectedAvailabilityDate
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.isLivemode = isLivemode
        self.metadata = metadata
        self.object = object
        self.source = source
        self.statementDescriptor = statementDescriptor
        self.status = status
        self.transferGroup = transferGroup
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.amount = try values.decode(Int.self, forKey: "amount")
        self.balanceTransaction = try values.decodeIfPresent(BalanceTransaction.self, forKey: "balance_transaction")
        self.created = try values.decode(Int.self, forKey: "created")
        self.currency = try values.decode(String.self, forKey: "currency")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.expectedAvailabilityDate = try values.decodeIfPresent(Int.self, forKey: "expected_availability_date")
        self.failureCode = try values.decodeIfPresent(String.self, forKey: "failure_code")
        self.failureMessage = try values.decodeIfPresent(String.self, forKey: "failure_message")
        self.id = try values.decode(String.self, forKey: "id")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.metadata = try values.decode([String: String].self, forKey: "metadata")
        self.object = try values.decode(Object.self, forKey: "object")
        self.source = try values.decodeIfPresent(Source.self, forKey: "source")
        self.statementDescriptor = try values.decodeIfPresent(String.self, forKey: "statement_descriptor")
        self.status = try values.decode(Status.self, forKey: "status")
        self.transferGroup = try values.decodeIfPresent(String.self, forKey: "transfer_group")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(amount, forKey: "amount")
        try values.encodeIfPresent(balanceTransaction, forKey: "balance_transaction")
        try values.encode(created, forKey: "created")
        try values.encode(currency, forKey: "currency")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(expectedAvailabilityDate, forKey: "expected_availability_date")
        try values.encodeIfPresent(failureCode, forKey: "failure_code")
        try values.encodeIfPresent(failureMessage, forKey: "failure_message")
        try values.encode(id, forKey: "id")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encode(metadata, forKey: "metadata")
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(source, forKey: "source")
        try values.encodeIfPresent(statementDescriptor, forKey: "statement_descriptor")
        try values.encode(status, forKey: "status")
        try values.encodeIfPresent(transferGroup, forKey: "transfer_group")
    }
}
