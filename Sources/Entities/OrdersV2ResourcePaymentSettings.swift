// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct OrdersV2ResourcePaymentSettings: Codable {
    /// The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account.
    public var applicationFeeAmount: Int?
    /// Indicates whether order has been opted into using [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods) to manage payment method types.
    public var automaticPaymentMethods: OrdersV2ResourceAutomaticPaymentMethods?
    /// PaymentMethod-specific configuration to provide to the order's PaymentIntent.
    public var paymentMethodOptions: OrdersV2ResourcePaymentMethodOptions?
    /// The list of [payment method types](https://stripe.com/docs/payments/payment-methods/overview) to provide to the order's PaymentIntent. Do not include this attribute if you prefer to manage your payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods).
    public var paymentMethodTypes: [PaymentMethodType]?
    /// The URL to redirect the customer to after they authenticate their payment.
    public var returnURL: String?
    /// For non-card charges, you can use this value as the complete description that appears on your customers' statements. Must contain at least one letter, maximum 22 characters.
    public var statementDescriptor: String?
    /// Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor thatâ€™s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    public var statementDescriptorSuffix: String?
    /// Provides configuration for completing a transfer for the order after it is paid.
    public var transferData: OrdersV2ResourceTransferData?

    public enum PaymentMethodType: String, Codable, CaseIterable {
        case acssDebit = "acss_debit"
        case afterpayClearpay = "afterpay_clearpay"
        case alipay
        case auBecsDebit = "au_becs_debit"
        case bacsDebit = "bacs_debit"
        case bancontact
        case card
        case customerBalance = "customer_balance"
        case eps
        case fpx
        case giropay
        case grabpay
        case ideal
        case klarna
        case link
        case oxxo
        case p24
        case paypal
        case sepaDebit = "sepa_debit"
        case sofort
        case wechatPay = "wechat_pay"
    }

    public init(applicationFeeAmount: Int? = nil, automaticPaymentMethods: OrdersV2ResourceAutomaticPaymentMethods? = nil, paymentMethodOptions: OrdersV2ResourcePaymentMethodOptions? = nil, paymentMethodTypes: [PaymentMethodType]? = nil, returnURL: String? = nil, statementDescriptor: String? = nil, statementDescriptorSuffix: String? = nil, transferData: OrdersV2ResourceTransferData? = nil) {
        self.applicationFeeAmount = applicationFeeAmount
        self.automaticPaymentMethods = automaticPaymentMethods
        self.paymentMethodOptions = paymentMethodOptions
        self.paymentMethodTypes = paymentMethodTypes
        self.returnURL = returnURL
        self.statementDescriptor = statementDescriptor
        self.statementDescriptorSuffix = statementDescriptorSuffix
        self.transferData = transferData
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.applicationFeeAmount = try values.decodeIfPresent(Int.self, forKey: "application_fee_amount")
        self.automaticPaymentMethods = try values.decodeIfPresent(OrdersV2ResourceAutomaticPaymentMethods.self, forKey: "automatic_payment_methods")
        self.paymentMethodOptions = try values.decodeIfPresent(OrdersV2ResourcePaymentMethodOptions.self, forKey: "payment_method_options")
        self.paymentMethodTypes = try values.decodeIfPresent([PaymentMethodType].self, forKey: "payment_method_types")
        self.returnURL = try values.decodeIfPresent(String.self, forKey: "return_url")
        self.statementDescriptor = try values.decodeIfPresent(String.self, forKey: "statement_descriptor")
        self.statementDescriptorSuffix = try values.decodeIfPresent(String.self, forKey: "statement_descriptor_suffix")
        self.transferData = try values.decodeIfPresent(OrdersV2ResourceTransferData.self, forKey: "transfer_data")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(applicationFeeAmount, forKey: "application_fee_amount")
        try values.encodeIfPresent(automaticPaymentMethods, forKey: "automatic_payment_methods")
        try values.encodeIfPresent(paymentMethodOptions, forKey: "payment_method_options")
        try values.encodeIfPresent(paymentMethodTypes, forKey: "payment_method_types")
        try values.encodeIfPresent(returnURL, forKey: "return_url")
        try values.encodeIfPresent(statementDescriptor, forKey: "statement_descriptor")
        try values.encodeIfPresent(statementDescriptorSuffix, forKey: "statement_descriptor_suffix")
        try values.encodeIfPresent(transferData, forKey: "transfer_data")
    }
}
