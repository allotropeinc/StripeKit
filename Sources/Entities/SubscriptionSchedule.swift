// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// A subscription schedule allows you to create and manage the lifecycle of a subscription by predefining expected changes.
/// 
/// Related guide: [Subscription Schedules](https://stripe.com/docs/billing/subscriptions/subscription-schedules).
public struct SubscriptionSchedule: Codable {
    /// ID of the Connect Application that created the schedule.
    public var application: Application?
    /// Time at which the subscription schedule was canceled. Measured in seconds since the Unix epoch.
    public var canceledAt: Int?
    /// Time at which the subscription schedule was completed. Measured in seconds since the Unix epoch.
    public var completedAt: Int?
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public var created: Int
    /// Object representing the start and end dates for the current phase of the subscription schedule, if it is `active`.
    public var currentPhase: SubscriptionScheduleCurrentPhase?
    /// ID of the customer who owns the subscription schedule.
    public var customer: Customer
    /// SubscriptionSchedulesResourceDefaultSettings
    public var defaultSettings: SubscriptionSchedulesResourceDefaultSettings
    /// Behavior of the subscription schedule and underlying subscription when it ends. Possible values are `release` and `cancel`.
    public var endBehavior: EndBehavior
    /// Unique identifier for the object.
    public var id: String
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    public var metadata: [String: String]?
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// Configuration for the subscription schedule's phases.
    public var phases: [SubscriptionSchedulePhaseConfiguration]
    /// Time at which the subscription schedule was released. Measured in seconds since the Unix epoch.
    public var releasedAt: Int?
    /// ID of the subscription once managed by the subscription schedule (if it is released).
    public var releasedSubscription: String?
    /// The present status of the subscription schedule. Possible values are `not_started`, `active`, `completed`, `released`, and `canceled`. You can read more about the different states in our [behavior guide](https://stripe.com/docs/billing/subscriptions/subscription-schedules).
    public var status: Status
    /// ID of the subscription managed by the subscription schedule.
    public var subscription: Subscription?
    /// ID of the test clock this subscription schedule belongs to.
    public var testClock: TestClock?

    /// ID of the Connect Application that created the schedule.
    public final class Application: Codable {
        public let string: String?
        public let application: StripeKit.Application?
        public let deletedApplication: DeletedApplication?

        public init(string: String? = nil, application: StripeKit.Application? = nil, deletedApplication: DeletedApplication? = nil) {
            self.string = string
            self.application = application
            self.deletedApplication = deletedApplication
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.application = try? container.decode(StripeKit.Application.self)
            self.deletedApplication = try? container.decode(DeletedApplication.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = application { try container.encode(value) }
            if let value = deletedApplication { try container.encode(value) }
        }
    }

    /// ID of the customer who owns the subscription schedule.
    public final class Customer: Codable {
        public let string: String?
        /// This object represents a customer of your business. It lets you create recurring charges and track payments that belong to the same customer.
        /// 
        /// Related guide: [Save a card during payment](https://stripe.com/docs/payments/save-during-payment).
        public let customer: StripeKit.Customer?
        public let deletedCustomer: DeletedCustomer?

        public init(string: String? = nil, customer: StripeKit.Customer? = nil, deletedCustomer: DeletedCustomer? = nil) {
            self.string = string
            self.customer = customer
            self.deletedCustomer = deletedCustomer
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.customer = try? container.decode(StripeKit.Customer.self)
            self.deletedCustomer = try? container.decode(DeletedCustomer.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = customer { try container.encode(value) }
            if let value = deletedCustomer { try container.encode(value) }
        }
    }

    /// Behavior of the subscription schedule and underlying subscription when it ends. Possible values are `release` and `cancel`.
    public enum EndBehavior: String, Codable, CaseIterable {
        case cancel
        case `none`
        case release
        case renew
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case subscriptionSchedule = "subscription_schedule"
    }

    /// The present status of the subscription schedule. Possible values are `not_started`, `active`, `completed`, `released`, and `canceled`. You can read more about the different states in our [behavior guide](https://stripe.com/docs/billing/subscriptions/subscription-schedules).
    public enum Status: String, Codable, CaseIterable {
        case active
        case canceled
        case completed
        case notStarted = "not_started"
        case released
    }

    /// ID of the subscription managed by the subscription schedule.
    public final class Subscription: Codable {
        public let string: String?
        /// Subscriptions allow you to charge a customer on a recurring basis.
        /// 
        /// Related guide: [Creating Subscriptions](https://stripe.com/docs/billing/subscriptions/creating).
        public let subscription: StripeKit.Subscription?

        public init(string: String? = nil, subscription: StripeKit.Subscription? = nil) {
            self.string = string
            self.subscription = subscription
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.subscription = try? container.decode(StripeKit.Subscription.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = subscription { try container.encode(value) }
        }
    }

    /// ID of the test clock this subscription schedule belongs to.
    public struct TestClock: Codable {
        public var string: String?
        /// TestClock
        ///
        /// A test clock enables deterministic control over objects in testmode. With a test clock, you can create
        /// objects at a frozen time in the past or future, and advance to a specific future time to observe webhooks and state changes. After the clock advances,
        /// you can either validate the current state of your scenario (and test your assumptions), change the current state of your scenario (and test more complex scenarios), or keep advancing forward in time.
        public var testHelpersTestClock: TestHelpersTestClock?

        public init(string: String? = nil, testHelpersTestClock: TestHelpersTestClock? = nil) {
            self.string = string
            self.testHelpersTestClock = testHelpersTestClock
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.testHelpersTestClock = try? container.decode(TestHelpersTestClock.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = testHelpersTestClock { try container.encode(value) }
        }
    }

    public init(application: Application? = nil, canceledAt: Int? = nil, completedAt: Int? = nil, created: Int, currentPhase: SubscriptionScheduleCurrentPhase? = nil, customer: Customer, defaultSettings: SubscriptionSchedulesResourceDefaultSettings, endBehavior: EndBehavior, id: String, isLivemode: Bool, metadata: [String: String]? = nil, object: Object, phases: [SubscriptionSchedulePhaseConfiguration], releasedAt: Int? = nil, releasedSubscription: String? = nil, status: Status, subscription: Subscription? = nil, testClock: TestClock? = nil) {
        self.application = application
        self.canceledAt = canceledAt
        self.completedAt = completedAt
        self.created = created
        self.currentPhase = currentPhase
        self.customer = customer
        self.defaultSettings = defaultSettings
        self.endBehavior = endBehavior
        self.id = id
        self.isLivemode = isLivemode
        self.metadata = metadata
        self.object = object
        self.phases = phases
        self.releasedAt = releasedAt
        self.releasedSubscription = releasedSubscription
        self.status = status
        self.subscription = subscription
        self.testClock = testClock
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.application = try values.decodeIfPresent(Application.self, forKey: "application")
        self.canceledAt = try values.decodeIfPresent(Int.self, forKey: "canceled_at")
        self.completedAt = try values.decodeIfPresent(Int.self, forKey: "completed_at")
        self.created = try values.decode(Int.self, forKey: "created")
        self.currentPhase = try values.decodeIfPresent(SubscriptionScheduleCurrentPhase.self, forKey: "current_phase")
        self.customer = try values.decode(Customer.self, forKey: "customer")
        self.defaultSettings = try values.decode(SubscriptionSchedulesResourceDefaultSettings.self, forKey: "default_settings")
        self.endBehavior = try values.decode(EndBehavior.self, forKey: "end_behavior")
        self.id = try values.decode(String.self, forKey: "id")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.metadata = try values.decodeIfPresent([String: String].self, forKey: "metadata")
        self.object = try values.decode(Object.self, forKey: "object")
        self.phases = try values.decode([SubscriptionSchedulePhaseConfiguration].self, forKey: "phases")
        self.releasedAt = try values.decodeIfPresent(Int.self, forKey: "released_at")
        self.releasedSubscription = try values.decodeIfPresent(String.self, forKey: "released_subscription")
        self.status = try values.decode(Status.self, forKey: "status")
        self.subscription = try values.decodeIfPresent(Subscription.self, forKey: "subscription")
        self.testClock = try values.decodeIfPresent(TestClock.self, forKey: "test_clock")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(application, forKey: "application")
        try values.encodeIfPresent(canceledAt, forKey: "canceled_at")
        try values.encodeIfPresent(completedAt, forKey: "completed_at")
        try values.encode(created, forKey: "created")
        try values.encodeIfPresent(currentPhase, forKey: "current_phase")
        try values.encode(customer, forKey: "customer")
        try values.encode(defaultSettings, forKey: "default_settings")
        try values.encode(endBehavior, forKey: "end_behavior")
        try values.encode(id, forKey: "id")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encode(object, forKey: "object")
        try values.encode(phases, forKey: "phases")
        try values.encodeIfPresent(releasedAt, forKey: "released_at")
        try values.encodeIfPresent(releasedSubscription, forKey: "released_subscription")
        try values.encode(status, forKey: "status")
        try values.encodeIfPresent(subscription, forKey: "subscription")
        try values.encodeIfPresent(testClock, forKey: "test_clock")
    }
}
