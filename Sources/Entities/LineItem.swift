// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// InvoiceLineItem
public struct LineItem: Codable {
    /// The amount, in %s.
    public var amount: Int
    /// The integer amount in %s representing the amount for this line item, excluding all tax and discounts.
    public var amountExcludingTax: Int?
    /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    public var currency: String
    /// An arbitrary string attached to the object. Often useful for displaying to users.
    public var description: String?
    /// The amount of discount calculated per discount for this line item.
    public var discountAmounts: [DiscountsResourceDiscountAmount]?
    /// If true, discounts will apply to this line item. Always false for prorations.
    public var isDiscountable: Bool
    /// The discounts applied to the invoice line item. Line item discounts are applied before invoice discounts. Use `expand[]=discounts` to expand each discount.
    public var discounts: [Discount]?
    /// Unique identifier for the object.
    public var id: String
    /// The ID of the [invoice item](https://stripe.com/docs/api/invoiceitems) associated with this line item if any.
    public var invoiceItem: String?
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Note that for line items with `type=subscription` this will reflect the metadata of the subscription that caused the line item to be created.
    public var metadata: [String: String]
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// InvoiceLineItemPeriod
    public var period: InvoiceLineItemPeriod
    /// The price of the line item.
    public var price: Price?
    /// Whether this is a proration.
    public var isProration: Bool
    /// Additional details for proration line items
    public var prorationDetails: InvoicesLineItemsProrationDetails?
    /// The quantity of the subscription, if the line item is a subscription or a proration.
    public var quantity: Int?
    /// The subscription that the invoice item pertains to, if any.
    public var subscription: String?
    /// The subscription item that generated this invoice item. Left empty if the line item is not an explicit result of a subscription.
    public var subscriptionItem: String?
    /// The amount of tax calculated per tax rate for this line item
    public var taxAmounts: [InvoiceTaxAmount]?
    /// The tax rates which apply to the line item.
    public var taxRates: [TaxRate]?
    /// A string identifying the type of the source of this line item, either an `invoiceitem` or a `subscription`.
    public var type: `Type`
    /// The amount in %s representing the unit amount for this line item, excluding all tax and discounts.
    public var unitAmountExcludingTax: String?

    public final class Discount: Codable {
        public let string: String?
        /// A discount represents the actual application of a [coupon](https://stripe.com/docs/api#coupons) or [promotion code](https://stripe.com/docs/api#promotion_codes).
        /// It contains information about when the discount began, when it will end, and what it is applied to.
        /// 
        /// Related guide: [Applying Discounts to Subscriptions](https://stripe.com/docs/billing/subscriptions/discounts).
        public let discount: StripeKit.Discount?

        public init(string: String? = nil, discount: StripeKit.Discount? = nil) {
            self.string = string
            self.discount = discount
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.discount = try? container.decode(StripeKit.Discount.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = discount { try container.encode(value) }
        }
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case lineItem = "line_item"
    }

    /// A string identifying the type of the source of this line item, either an `invoiceitem` or a `subscription`.
    public enum `Type`: String, Codable, CaseIterable {
        case invoiceitem
        case subscription
    }

    public init(amount: Int, amountExcludingTax: Int? = nil, currency: String, description: String? = nil, discountAmounts: [DiscountsResourceDiscountAmount]? = nil, isDiscountable: Bool, discounts: [Discount]? = nil, id: String, invoiceItem: String? = nil, isLivemode: Bool, metadata: [String: String], object: Object, period: InvoiceLineItemPeriod, price: Price? = nil, isProration: Bool, prorationDetails: InvoicesLineItemsProrationDetails? = nil, quantity: Int? = nil, subscription: String? = nil, subscriptionItem: String? = nil, taxAmounts: [InvoiceTaxAmount]? = nil, taxRates: [TaxRate]? = nil, type: `Type`, unitAmountExcludingTax: String? = nil) {
        self.amount = amount
        self.amountExcludingTax = amountExcludingTax
        self.currency = currency
        self.description = description
        self.discountAmounts = discountAmounts
        self.isDiscountable = isDiscountable
        self.discounts = discounts
        self.id = id
        self.invoiceItem = invoiceItem
        self.isLivemode = isLivemode
        self.metadata = metadata
        self.object = object
        self.period = period
        self.price = price
        self.isProration = isProration
        self.prorationDetails = prorationDetails
        self.quantity = quantity
        self.subscription = subscription
        self.subscriptionItem = subscriptionItem
        self.taxAmounts = taxAmounts
        self.taxRates = taxRates
        self.type = type
        self.unitAmountExcludingTax = unitAmountExcludingTax
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.amount = try values.decode(Int.self, forKey: "amount")
        self.amountExcludingTax = try values.decodeIfPresent(Int.self, forKey: "amount_excluding_tax")
        self.currency = try values.decode(String.self, forKey: "currency")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.discountAmounts = try values.decodeIfPresent([DiscountsResourceDiscountAmount].self, forKey: "discount_amounts")
        self.isDiscountable = try values.decode(Bool.self, forKey: "discountable")
        self.discounts = try values.decodeIfPresent([Discount].self, forKey: "discounts")
        self.id = try values.decode(String.self, forKey: "id")
        self.invoiceItem = try values.decodeIfPresent(String.self, forKey: "invoice_item")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.metadata = try values.decode([String: String].self, forKey: "metadata")
        self.object = try values.decode(Object.self, forKey: "object")
        self.period = try values.decode(InvoiceLineItemPeriod.self, forKey: "period")
        self.price = try values.decodeIfPresent(Price.self, forKey: "price")
        self.isProration = try values.decode(Bool.self, forKey: "proration")
        self.prorationDetails = try values.decodeIfPresent(InvoicesLineItemsProrationDetails.self, forKey: "proration_details")
        self.quantity = try values.decodeIfPresent(Int.self, forKey: "quantity")
        self.subscription = try values.decodeIfPresent(String.self, forKey: "subscription")
        self.subscriptionItem = try values.decodeIfPresent(String.self, forKey: "subscription_item")
        self.taxAmounts = try values.decodeIfPresent([InvoiceTaxAmount].self, forKey: "tax_amounts")
        self.taxRates = try values.decodeIfPresent([TaxRate].self, forKey: "tax_rates")
        self.type = try values.decode(`Type`.self, forKey: "type")
        self.unitAmountExcludingTax = try values.decodeIfPresent(String.self, forKey: "unit_amount_excluding_tax")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(amount, forKey: "amount")
        try values.encodeIfPresent(amountExcludingTax, forKey: "amount_excluding_tax")
        try values.encode(currency, forKey: "currency")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(discountAmounts, forKey: "discount_amounts")
        try values.encode(isDiscountable, forKey: "discountable")
        try values.encodeIfPresent(discounts, forKey: "discounts")
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(invoiceItem, forKey: "invoice_item")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encode(metadata, forKey: "metadata")
        try values.encode(object, forKey: "object")
        try values.encode(period, forKey: "period")
        try values.encodeIfPresent(price, forKey: "price")
        try values.encode(isProration, forKey: "proration")
        try values.encodeIfPresent(prorationDetails, forKey: "proration_details")
        try values.encodeIfPresent(quantity, forKey: "quantity")
        try values.encodeIfPresent(subscription, forKey: "subscription")
        try values.encodeIfPresent(subscriptionItem, forKey: "subscription_item")
        try values.encodeIfPresent(taxAmounts, forKey: "tax_amounts")
        try values.encodeIfPresent(taxRates, forKey: "tax_rates")
        try values.encode(type, forKey: "type")
        try values.encodeIfPresent(unitAmountExcludingTax, forKey: "unit_amount_excluding_tax")
    }
}
