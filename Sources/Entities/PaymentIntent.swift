// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// A PaymentIntent guides you through the process of collecting a payment from your customer.
/// We recommend that you create exactly one PaymentIntent for each order or
/// customer session in your system. You can reference the PaymentIntent later to
/// see the history of payment attempts for a particular session.
/// 
/// A PaymentIntent transitions through
/// [multiple statuses](https://stripe.com/docs/payments/intents#intent-statuses)
/// throughout its lifetime as it interfaces with Stripe.js to perform
/// authentication flows and ultimately creates at most one successful charge.
/// 
/// Related guide: [Payment Intents API](https://stripe.com/docs/payments/payment-intents).
public final class PaymentIntent: Codable {
    /// Amount intended to be collected by this PaymentIntent. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
    public let amount: Int
    /// Amount that can be captured from this PaymentIntent.
    public let amountCapturable: Int?
    /// PaymentFlowsAmountDetails
    public let amountDetails: PaymentFlowsAmountDetails?
    /// Amount that was collected by this PaymentIntent.
    public let amountReceived: Int?
    /// ID of the Connect application that created the PaymentIntent.
    public let application: Application?
    /// The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
    public let applicationFeeAmount: Int?
    /// Settings to configure compatible payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods)
    public let automaticPaymentMethods: PaymentFlowsAutomaticPaymentMethodsPaymentIntent?
    /// Populated when `status` is `canceled`, this is the time at which the PaymentIntent was canceled. Measured in seconds since the Unix epoch.
    public let canceledAt: Int?
    /// Reason for cancellation of this PaymentIntent, either user-provided (`duplicate`, `fraudulent`, `requested_by_customer`, or `abandoned`) or generated by Stripe internally (`failed_invoice`, `void_invoice`, or `automatic`).
    public let cancellationReason: CancellationReason?
    /// Controls when the funds will be captured from the customer's account.
    public let captureMethod: CaptureMethod
    /// PaymentFlowsPaymentIntentResourceChargeList
    ///
    /// Charges that were created by this PaymentIntent, if any.
    public let charges: Charges?
    /// The client secret of this PaymentIntent. Used for client-side retrieval using a publishable key. 
    /// 
    /// The client secret can be used to complete a payment from your frontend. It should not be stored, logged, or exposed to anyone other than the customer. Make sure that you have TLS enabled on any page that includes the client secret.
    /// 
    /// Refer to our docs to [accept a payment](https://stripe.com/docs/payments/accept-a-payment?ui=elements) and learn about how `client_secret` should be handled.
    public let clientSecret: String?
    public let confirmationMethod: ConfirmationMethod
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public let created: Int
    /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    public let currency: String
    /// ID of the Customer this PaymentIntent belongs to, if one exists.
    /// 
    /// Payment methods attached to other Customers cannot be used with this PaymentIntent.
    /// 
    /// If present in combination with [setup_future_usage](https://stripe.com/docs/api#payment_intent_object-setup_future_usage), this PaymentIntent's payment method will be attached to the Customer after the PaymentIntent has been confirmed and any required actions from the user are complete.
    public let customer: Customer?
    /// An arbitrary string attached to the object. Often useful for displaying to users.
    public let description: String?
    /// Unique identifier for the object.
    public let id: String
    /// ID of the invoice that created this PaymentIntent, if it exists.
    public let invoice: Invoice?
    /// The payment error encountered in the previous PaymentIntent confirmation. It will be cleared if the PaymentIntent is later updated for any reason.
    public let lastPaymentError: APIErrors?
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public let isLivemode: Bool
    /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. For more information, see the [documentation](https://stripe.com/docs/payments/payment-intents/creating-payment-intents#storing-information-in-metadata).
    public let metadata: [String: String]?
    /// If present, this property tells you what actions you need to take in order for your customer to fulfill a payment using the provided source.
    public let nextAction: PaymentIntentNextAction?
    /// String representing the object's type. Objects of the same type share the same value.
    public let object: Object
    /// The account (if any) for which the funds of the PaymentIntent are intended. See the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts) for details.
    public let onBehalfOf: OnBehalfOf?
    /// ID of the payment method used in this PaymentIntent.
    public let paymentMethod: PaymentMethod?
    /// Payment-method-specific configuration for this PaymentIntent.
    public let paymentMethodOptions: PaymentIntentPaymentMethodOptions?
    /// The list of payment method types (e.g. card) that this PaymentIntent is allowed to use.
    public let paymentMethodTypes: [String]
    /// If present, this property tells you about the processing state of the payment.
    public let processing: PaymentIntentProcessing?
    /// Email address that the receipt for the resulting payment will be sent to. If `receipt_email` is specified for a payment in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
    public let receiptEmail: String?
    /// ID of the review associated with this PaymentIntent, if any.
    public let review: Review?
    /// Indicates that you intend to make future payments with this PaymentIntent's payment method.
    /// 
    /// Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.
    /// 
    /// When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).
    public let setupFutureUsage: SetupFutureUsage?
    /// Shipping information for this PaymentIntent.
    public let shipping: Shipping?
    /// For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    public let statementDescriptor: String?
    /// Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    public let statementDescriptorSuffix: String?
    /// Status of this PaymentIntent, one of `requires_payment_method`, `requires_confirmation`, `requires_action`, `processing`, `requires_capture`, `canceled`, or `succeeded`. Read more about each PaymentIntent [status](https://stripe.com/docs/payments/intents#intent-statuses).
    public let status: Status
    /// The data with which to automatically create a Transfer when the payment is finalized. See the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts) for details.
    public let transferData: TransferData?
    /// A string that identifies the resulting payment as part of a group. See the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts) for details.
    public let transferGroup: String?

    /// ID of the Connect application that created the PaymentIntent.
    public final class Application: Codable {
        public let string: String?
        public let application: StripeKit.Application?

        public init(string: String? = nil, application: StripeKit.Application? = nil) {
            self.string = string
            self.application = application
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.application = try? container.decode(StripeKit.Application.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = application { try container.encode(value) }
        }
    }

    /// Reason for cancellation of this PaymentIntent, either user-provided (`duplicate`, `fraudulent`, `requested_by_customer`, or `abandoned`) or generated by Stripe internally (`failed_invoice`, `void_invoice`, or `automatic`).
    public enum CancellationReason: String, Codable, CaseIterable {
        case abandoned
        case automatic
        case duplicate
        case failedInvoice = "failed_invoice"
        case fraudulent
        case requestedByCustomer = "requested_by_customer"
        case voidInvoice = "void_invoice"
    }

    /// Controls when the funds will be captured from the customer's account.
    public enum CaptureMethod: String, Codable, CaseIterable {
        case automatic
        case manual
    }

    /// PaymentFlowsPaymentIntentResourceChargeList
    ///
    /// Charges that were created by this PaymentIntent, if any.
    public struct Charges: Codable {
        /// This list only contains the latest charge, even if there were previously multiple unsuccessful charges. To view all previous charges for a PaymentIntent, you can filter the charges list using the `payment_intent` [parameter](https://stripe.com/docs/api/charges/list#list_charges-payment_intent).
        public var data: [Charge]
        /// True if this list has another page of items after this one that can be fetched.
        public var hasMore: Bool
        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public var object: Object
        /// The URL where this list can be accessed.
        public var url: String

        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public enum Object: String, Codable, CaseIterable {
            case list
        }

        public init(data: [Charge], hasMore: Bool, object: Object, url: String) {
            self.data = data
            self.hasMore = hasMore
            self.object = object
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.data = try values.decode([Charge].self, forKey: "data")
            self.hasMore = try values.decode(Bool.self, forKey: "has_more")
            self.object = try values.decode(Object.self, forKey: "object")
            self.url = try values.decode(String.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(data, forKey: "data")
            try values.encode(hasMore, forKey: "has_more")
            try values.encode(object, forKey: "object")
            try values.encode(url, forKey: "url")
        }
    }

    public enum ConfirmationMethod: String, Codable, CaseIterable {
        case automatic
        case manual
    }

    /// ID of the Customer this PaymentIntent belongs to, if one exists.
    /// 
    /// Payment methods attached to other Customers cannot be used with this PaymentIntent.
    /// 
    /// If present in combination with [setup_future_usage](https://stripe.com/docs/api#payment_intent_object-setup_future_usage), this PaymentIntent's payment method will be attached to the Customer after the PaymentIntent has been confirmed and any required actions from the user are complete.
    public final class Customer: Codable {
        public let string: String?
        /// This object represents a customer of your business. It lets you create recurring charges and track payments that belong to the same customer.
        /// 
        /// Related guide: [Save a card during payment](https://stripe.com/docs/payments/save-during-payment).
        public let customer: StripeKit.Customer?
        public let deletedCustomer: DeletedCustomer?

        public init(string: String? = nil, customer: StripeKit.Customer? = nil, deletedCustomer: DeletedCustomer? = nil) {
            self.string = string
            self.customer = customer
            self.deletedCustomer = deletedCustomer
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.customer = try? container.decode(StripeKit.Customer.self)
            self.deletedCustomer = try? container.decode(DeletedCustomer.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = customer { try container.encode(value) }
            if let value = deletedCustomer { try container.encode(value) }
        }
    }

    /// ID of the invoice that created this PaymentIntent, if it exists.
    public final class Invoice: Codable {
        public let string: String?
        /// Invoices are statements of amounts owed by a customer, and are either
        /// generated one-off, or generated periodically from a subscription.
        /// 
        /// They contain [invoice items](https://stripe.com/docs/api#invoiceitems), and proration adjustments
        /// that may be caused by subscription upgrades/downgrades (if necessary).
        /// 
        /// If your invoice is configured to be billed through automatic charges,
        /// Stripe automatically finalizes your invoice and attempts payment. Note
        /// that finalizing the invoice,
        /// [when automatic](https://stripe.com/docs/billing/invoices/workflow/#auto_advance), does
        /// not happen immediately as the invoice is created. Stripe waits
        /// until one hour after the last webhook was successfully sent (or the last
        /// webhook timed out after failing). If you (and the platforms you may have
        /// connected to) have no webhooks configured, Stripe waits one hour after
        /// creation to finalize the invoice.
        /// 
        /// If your invoice is configured to be billed by sending an email, then based on your
        /// [email settings](https://dashboard.stripe.com/account/billing/automatic),
        /// Stripe will email the invoice to your customer and await payment. These
        /// emails can contain a link to a hosted page to pay the invoice.
        /// 
        /// Stripe applies any customer credit on the account before determining the
        /// amount due for the invoice (i.e., the amount that will be actually
        /// charged). If the amount due for the invoice is less than Stripe's [minimum allowed charge
        /// per currency](/docs/currencies#minimum-and-maximum-charge-amounts), the
        /// invoice is automatically marked paid, and we add the amount due to the
        /// customer's credit balance which is applied to the next invoice.
        /// 
        /// More details on the customer's credit balance are
        /// [here](https://stripe.com/docs/billing/customer/balance).
        /// 
        /// Related guide: [Send Invoices to Customers](https://stripe.com/docs/billing/invoices/sending).
        public let invoice: StripeKit.Invoice?

        public init(string: String? = nil, invoice: StripeKit.Invoice? = nil) {
            self.string = string
            self.invoice = invoice
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.invoice = try? container.decode(StripeKit.Invoice.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = invoice { try container.encode(value) }
        }
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case paymentIntent = "payment_intent"
    }

    /// The account (if any) for which the funds of the PaymentIntent are intended. See the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts) for details.
    public struct OnBehalfOf: Codable {
        public var string: String?
        /// This is an object representing a Stripe account. You can retrieve it to see
        /// properties on the account like its current e-mail address or if the account is
        /// enabled yet to make live charges.
        /// 
        /// Some properties, marked below, are available only to platforms that want to
        /// [create and manage Express or Custom accounts](https://stripe.com/docs/connect/accounts).
        public var account: Account?

        public init(string: String? = nil, account: Account? = nil) {
            self.string = string
            self.account = account
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.account = try? container.decode(Account.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = account { try container.encode(value) }
        }
    }

    /// ID of the payment method used in this PaymentIntent.
    public final class PaymentMethod: Codable {
        public let string: String?
        /// PaymentMethod objects represent your customer's payment instruments.
        /// You can use them with [PaymentIntents](https://stripe.com/docs/payments/payment-intents) to collect payments or save them to
        /// Customer objects to store instrument details for future payments.
        /// 
        /// Related guides: [Payment Methods](https://stripe.com/docs/payments/payment-methods) and [More Payment Scenarios](https://stripe.com/docs/payments/more-payment-scenarios).
        public let paymentMethod: StripeKit.PaymentMethod?

        public init(string: String? = nil, paymentMethod: StripeKit.PaymentMethod? = nil) {
            self.string = string
            self.paymentMethod = paymentMethod
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.paymentMethod = try? container.decode(StripeKit.PaymentMethod.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = paymentMethod { try container.encode(value) }
        }
    }

    /// ID of the review associated with this PaymentIntent, if any.
    public final class Review: Codable {
        public let string: String?
        /// RadarReview
        ///
        /// Reviews can be used to supplement automated fraud detection with human expertise.
        /// 
        /// Learn more about [Radar](/radar) and reviewing payments
        /// [here](https://stripe.com/docs/radar/reviews).
        public let review: StripeKit.Review?

        public init(string: String? = nil, review: StripeKit.Review? = nil) {
            self.string = string
            self.review = review
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.review = try? container.decode(StripeKit.Review.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = review { try container.encode(value) }
        }
    }

    /// Indicates that you intend to make future payments with this PaymentIntent's payment method.
    /// 
    /// Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.
    /// 
    /// When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).
    public enum SetupFutureUsage: String, Codable, CaseIterable {
        case offSession = "off_session"
        case onSession = "on_session"
    }

    /// Status of this PaymentIntent, one of `requires_payment_method`, `requires_confirmation`, `requires_action`, `processing`, `requires_capture`, `canceled`, or `succeeded`. Read more about each PaymentIntent [status](https://stripe.com/docs/payments/intents#intent-statuses).
    public enum Status: String, Codable, CaseIterable {
        case canceled
        case processing
        case requiresAction = "requires_action"
        case requiresCapture = "requires_capture"
        case requiresConfirmation = "requires_confirmation"
        case requiresPaymentMethod = "requires_payment_method"
        case succeeded
    }

    public init(amount: Int, amountCapturable: Int? = nil, amountDetails: PaymentFlowsAmountDetails? = nil, amountReceived: Int? = nil, application: Application? = nil, applicationFeeAmount: Int? = nil, automaticPaymentMethods: PaymentFlowsAutomaticPaymentMethodsPaymentIntent? = nil, canceledAt: Int? = nil, cancellationReason: CancellationReason? = nil, captureMethod: CaptureMethod, charges: Charges? = nil, clientSecret: String? = nil, confirmationMethod: ConfirmationMethod, created: Int, currency: String, customer: Customer? = nil, description: String? = nil, id: String, invoice: Invoice? = nil, lastPaymentError: APIErrors? = nil, isLivemode: Bool, metadata: [String: String]? = nil, nextAction: PaymentIntentNextAction? = nil, object: Object, onBehalfOf: OnBehalfOf? = nil, paymentMethod: PaymentMethod? = nil, paymentMethodOptions: PaymentIntentPaymentMethodOptions? = nil, paymentMethodTypes: [String], processing: PaymentIntentProcessing? = nil, receiptEmail: String? = nil, review: Review? = nil, setupFutureUsage: SetupFutureUsage? = nil, shipping: Shipping? = nil, statementDescriptor: String? = nil, statementDescriptorSuffix: String? = nil, status: Status, transferData: TransferData? = nil, transferGroup: String? = nil) {
        self.amount = amount
        self.amountCapturable = amountCapturable
        self.amountDetails = amountDetails
        self.amountReceived = amountReceived
        self.application = application
        self.applicationFeeAmount = applicationFeeAmount
        self.automaticPaymentMethods = automaticPaymentMethods
        self.canceledAt = canceledAt
        self.cancellationReason = cancellationReason
        self.captureMethod = captureMethod
        self.charges = charges
        self.clientSecret = clientSecret
        self.confirmationMethod = confirmationMethod
        self.created = created
        self.currency = currency
        self.customer = customer
        self.description = description
        self.id = id
        self.invoice = invoice
        self.lastPaymentError = lastPaymentError
        self.isLivemode = isLivemode
        self.metadata = metadata
        self.nextAction = nextAction
        self.object = object
        self.onBehalfOf = onBehalfOf
        self.paymentMethod = paymentMethod
        self.paymentMethodOptions = paymentMethodOptions
        self.paymentMethodTypes = paymentMethodTypes
        self.processing = processing
        self.receiptEmail = receiptEmail
        self.review = review
        self.setupFutureUsage = setupFutureUsage
        self.shipping = shipping
        self.statementDescriptor = statementDescriptor
        self.statementDescriptorSuffix = statementDescriptorSuffix
        self.status = status
        self.transferData = transferData
        self.transferGroup = transferGroup
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.amount = try values.decode(Int.self, forKey: "amount")
        self.amountCapturable = try values.decodeIfPresent(Int.self, forKey: "amount_capturable")
        self.amountDetails = try values.decodeIfPresent(PaymentFlowsAmountDetails.self, forKey: "amount_details")
        self.amountReceived = try values.decodeIfPresent(Int.self, forKey: "amount_received")
        self.application = try values.decodeIfPresent(Application.self, forKey: "application")
        self.applicationFeeAmount = try values.decodeIfPresent(Int.self, forKey: "application_fee_amount")
        self.automaticPaymentMethods = try values.decodeIfPresent(PaymentFlowsAutomaticPaymentMethodsPaymentIntent.self, forKey: "automatic_payment_methods")
        self.canceledAt = try values.decodeIfPresent(Int.self, forKey: "canceled_at")
        self.cancellationReason = try values.decodeIfPresent(CancellationReason.self, forKey: "cancellation_reason")
        self.captureMethod = try values.decode(CaptureMethod.self, forKey: "capture_method")
        self.charges = try values.decodeIfPresent(Charges.self, forKey: "charges")
        self.clientSecret = try values.decodeIfPresent(String.self, forKey: "client_secret")
        self.confirmationMethod = try values.decode(ConfirmationMethod.self, forKey: "confirmation_method")
        self.created = try values.decode(Int.self, forKey: "created")
        self.currency = try values.decode(String.self, forKey: "currency")
        self.customer = try values.decodeIfPresent(Customer.self, forKey: "customer")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.id = try values.decode(String.self, forKey: "id")
        self.invoice = try values.decodeIfPresent(Invoice.self, forKey: "invoice")
        self.lastPaymentError = try values.decodeIfPresent(APIErrors.self, forKey: "last_payment_error")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.metadata = try values.decodeIfPresent([String: String].self, forKey: "metadata")
        self.nextAction = try values.decodeIfPresent(PaymentIntentNextAction.self, forKey: "next_action")
        self.object = try values.decode(Object.self, forKey: "object")
        self.onBehalfOf = try values.decodeIfPresent(OnBehalfOf.self, forKey: "on_behalf_of")
        self.paymentMethod = try values.decodeIfPresent(PaymentMethod.self, forKey: "payment_method")
        self.paymentMethodOptions = try values.decodeIfPresent(PaymentIntentPaymentMethodOptions.self, forKey: "payment_method_options")
        self.paymentMethodTypes = try values.decode([String].self, forKey: "payment_method_types")
        self.processing = try values.decodeIfPresent(PaymentIntentProcessing.self, forKey: "processing")
        self.receiptEmail = try values.decodeIfPresent(String.self, forKey: "receipt_email")
        self.review = try values.decodeIfPresent(Review.self, forKey: "review")
        self.setupFutureUsage = try values.decodeIfPresent(SetupFutureUsage.self, forKey: "setup_future_usage")
        self.shipping = try values.decodeIfPresent(Shipping.self, forKey: "shipping")
        self.statementDescriptor = try values.decodeIfPresent(String.self, forKey: "statement_descriptor")
        self.statementDescriptorSuffix = try values.decodeIfPresent(String.self, forKey: "statement_descriptor_suffix")
        self.status = try values.decode(Status.self, forKey: "status")
        self.transferData = try values.decodeIfPresent(TransferData.self, forKey: "transfer_data")
        self.transferGroup = try values.decodeIfPresent(String.self, forKey: "transfer_group")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(amount, forKey: "amount")
        try values.encodeIfPresent(amountCapturable, forKey: "amount_capturable")
        try values.encodeIfPresent(amountDetails, forKey: "amount_details")
        try values.encodeIfPresent(amountReceived, forKey: "amount_received")
        try values.encodeIfPresent(application, forKey: "application")
        try values.encodeIfPresent(applicationFeeAmount, forKey: "application_fee_amount")
        try values.encodeIfPresent(automaticPaymentMethods, forKey: "automatic_payment_methods")
        try values.encodeIfPresent(canceledAt, forKey: "canceled_at")
        try values.encodeIfPresent(cancellationReason, forKey: "cancellation_reason")
        try values.encode(captureMethod, forKey: "capture_method")
        try values.encodeIfPresent(charges, forKey: "charges")
        try values.encodeIfPresent(clientSecret, forKey: "client_secret")
        try values.encode(confirmationMethod, forKey: "confirmation_method")
        try values.encode(created, forKey: "created")
        try values.encode(currency, forKey: "currency")
        try values.encodeIfPresent(customer, forKey: "customer")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(invoice, forKey: "invoice")
        try values.encodeIfPresent(lastPaymentError, forKey: "last_payment_error")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encodeIfPresent(nextAction, forKey: "next_action")
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(onBehalfOf, forKey: "on_behalf_of")
        try values.encodeIfPresent(paymentMethod, forKey: "payment_method")
        try values.encodeIfPresent(paymentMethodOptions, forKey: "payment_method_options")
        try values.encode(paymentMethodTypes, forKey: "payment_method_types")
        try values.encodeIfPresent(processing, forKey: "processing")
        try values.encodeIfPresent(receiptEmail, forKey: "receipt_email")
        try values.encodeIfPresent(review, forKey: "review")
        try values.encodeIfPresent(setupFutureUsage, forKey: "setup_future_usage")
        try values.encodeIfPresent(shipping, forKey: "shipping")
        try values.encodeIfPresent(statementDescriptor, forKey: "statement_descriptor")
        try values.encodeIfPresent(statementDescriptorSuffix, forKey: "statement_descriptor_suffix")
        try values.encode(status, forKey: "status")
        try values.encodeIfPresent(transferData, forKey: "transfer_data")
        try values.encodeIfPresent(transferGroup, forKey: "transfer_group")
    }
}
