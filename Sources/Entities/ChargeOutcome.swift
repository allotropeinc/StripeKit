// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct ChargeOutcome: Codable {
    /// Possible values are `approved_by_network`, `declined_by_network`, `not_sent_to_network`, and `reversed_after_approval`. The value `reversed_after_approval` indicates the payment was [blocked by Stripe](https://stripe.com/docs/declines#blocked-payments) after bank authorization, and may temporarily appear as "pending" on a cardholder's statement.
    public var networkStatus: String?
    /// An enumerated value providing a more detailed explanation of the outcome's `type`. Charges blocked by Radar's default block rule have the value `highest_risk_level`. Charges placed in review by Radar's default review rule have the value `elevated_risk_level`. Charges authorized, blocked, or placed in review by custom rules have the value `rule`. See [understanding declines](https://stripe.com/docs/declines) for more details.
    public var reason: String?
    /// Stripe Radar's evaluation of the riskiness of the payment. Possible values for evaluated payments are `normal`, `elevated`, `highest`. For non-card payments, and card-based payments predating the public assignment of risk levels, this field will have the value `not_assessed`. In the event of an error in the evaluation, this field will have the value `unknown`. This field is only available with Radar.
    public var riskLevel: String?
    /// Stripe Radar's evaluation of the riskiness of the payment. Possible values for evaluated payments are between 0 and 100. For non-card payments, card-based payments predating the public assignment of risk scores, or in the event of an error during evaluation, this field will not be present. This field is only available with Radar for Fraud Teams.
    public var riskScore: Int?
    /// The ID of the Radar rule that matched the payment, if applicable.
    public var rule: Rule?
    /// A human-readable description of the outcome type and reason, designed for you (the recipient of the payment), not your customer.
    public var sellerMessage: String?
    /// Possible values are `authorized`, `manual_review`, `issuer_declined`, `blocked`, and `invalid`. See [understanding declines](https://stripe.com/docs/declines) and [Radar reviews](https://stripe.com/docs/radar/reviews) for details.
    public var type: String

    /// The ID of the Radar rule that matched the payment, if applicable.
    public final class Rule: Codable {
        public let string: String?
        /// RadarRule
        public let rule: StripeKit.Rule?

        public init(string: String? = nil, rule: StripeKit.Rule? = nil) {
            self.string = string
            self.rule = rule
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.rule = try? container.decode(StripeKit.Rule.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = rule { try container.encode(value) }
        }
    }

    public init(networkStatus: String? = nil, reason: String? = nil, riskLevel: String? = nil, riskScore: Int? = nil, rule: Rule? = nil, sellerMessage: String? = nil, type: String) {
        self.networkStatus = networkStatus
        self.reason = reason
        self.riskLevel = riskLevel
        self.riskScore = riskScore
        self.rule = rule
        self.sellerMessage = sellerMessage
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.networkStatus = try values.decodeIfPresent(String.self, forKey: "network_status")
        self.reason = try values.decodeIfPresent(String.self, forKey: "reason")
        self.riskLevel = try values.decodeIfPresent(String.self, forKey: "risk_level")
        self.riskScore = try values.decodeIfPresent(Int.self, forKey: "risk_score")
        self.rule = try values.decodeIfPresent(Rule.self, forKey: "rule")
        self.sellerMessage = try values.decodeIfPresent(String.self, forKey: "seller_message")
        self.type = try values.decode(String.self, forKey: "type")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(networkStatus, forKey: "network_status")
        try values.encodeIfPresent(reason, forKey: "reason")
        try values.encodeIfPresent(riskLevel, forKey: "risk_level")
        try values.encodeIfPresent(riskScore, forKey: "risk_score")
        try values.encodeIfPresent(rule, forKey: "rule")
        try values.encodeIfPresent(sellerMessage, forKey: "seller_message")
        try values.encode(type, forKey: "type")
    }
}
