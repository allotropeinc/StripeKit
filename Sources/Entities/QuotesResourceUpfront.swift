// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct QuotesResourceUpfront: Codable {
    /// Total before any discounts or taxes are applied.
    public var amountSubtotal: Int
    /// Total after discounts and taxes are applied.
    public var amountTotal: Int
    /// QuotesResourceListLineItems
    ///
    /// The line items that will appear on the next invoice after this quote is accepted. This does not include pending invoice items that exist on the customer but may still be included in the next invoice.
    public var lineItems: LineItems?
    /// QuotesResourceTotalDetails
    public var totalDetails: QuotesResourceTotalDetails

    /// QuotesResourceListLineItems
    ///
    /// The line items that will appear on the next invoice after this quote is accepted. This does not include pending invoice items that exist on the customer but may still be included in the next invoice.
    public struct LineItems: Codable {
        /// Details about each object.
        public var data: [Item]
        /// True if this list has another page of items after this one that can be fetched.
        public var hasMore: Bool
        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public var object: Object
        /// The URL where this list can be accessed.
        public var url: String

        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public enum Object: String, Codable, CaseIterable {
            case list
        }

        public init(data: [Item], hasMore: Bool, object: Object, url: String) {
            self.data = data
            self.hasMore = hasMore
            self.object = object
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.data = try values.decode([Item].self, forKey: "data")
            self.hasMore = try values.decode(Bool.self, forKey: "has_more")
            self.object = try values.decode(Object.self, forKey: "object")
            self.url = try values.decode(String.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(data, forKey: "data")
            try values.encode(hasMore, forKey: "has_more")
            try values.encode(object, forKey: "object")
            try values.encode(url, forKey: "url")
        }
    }

    public init(amountSubtotal: Int, amountTotal: Int, lineItems: LineItems? = nil, totalDetails: QuotesResourceTotalDetails) {
        self.amountSubtotal = amountSubtotal
        self.amountTotal = amountTotal
        self.lineItems = lineItems
        self.totalDetails = totalDetails
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.amountSubtotal = try values.decode(Int.self, forKey: "amount_subtotal")
        self.amountTotal = try values.decode(Int.self, forKey: "amount_total")
        self.lineItems = try values.decodeIfPresent(LineItems.self, forKey: "line_items")
        self.totalDetails = try values.decode(QuotesResourceTotalDetails.self, forKey: "total_details")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(amountSubtotal, forKey: "amount_subtotal")
        try values.encode(amountTotal, forKey: "amount_total")
        try values.encodeIfPresent(lineItems, forKey: "line_items")
        try values.encode(totalDetails, forKey: "total_details")
    }
}
