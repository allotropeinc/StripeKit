// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct Recurring: Codable {
    /// Specifies a usage aggregation strategy for prices of `usage_type=metered`. Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max` which uses the usage record with the maximum reported usage during a period. Defaults to `sum`.
    public var aggregateUsage: AggregateUsage?
    /// The frequency at which a subscription is billed. One of `day`, `week`, `month` or `year`.
    public var interval: Interval
    /// The number of intervals (specified in the `interval` attribute) between subscription billings. For example, `interval=month` and `interval_count=3` bills every 3 months.
    public var intervalCount: Int
    /// Configures how the quantity per period should be determined. Can be either `metered` or `licensed`. `licensed` automatically bills the `quantity` set when adding it to a subscription. `metered` aggregates the total usage based on usage records. Defaults to `licensed`.
    public var usageType: UsageType

    /// Specifies a usage aggregation strategy for prices of `usage_type=metered`. Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max` which uses the usage record with the maximum reported usage during a period. Defaults to `sum`.
    public enum AggregateUsage: String, Codable, CaseIterable {
        case lastDuringPeriod = "last_during_period"
        case lastEver = "last_ever"
        case max
        case sum
    }

    /// The frequency at which a subscription is billed. One of `day`, `week`, `month` or `year`.
    public enum Interval: String, Codable, CaseIterable {
        case day
        case month
        case week
        case year
    }

    /// Configures how the quantity per period should be determined. Can be either `metered` or `licensed`. `licensed` automatically bills the `quantity` set when adding it to a subscription. `metered` aggregates the total usage based on usage records. Defaults to `licensed`.
    public enum UsageType: String, Codable, CaseIterable {
        case licensed
        case metered
    }

    public init(aggregateUsage: AggregateUsage? = nil, interval: Interval, intervalCount: Int, usageType: UsageType) {
        self.aggregateUsage = aggregateUsage
        self.interval = interval
        self.intervalCount = intervalCount
        self.usageType = usageType
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.aggregateUsage = try values.decodeIfPresent(AggregateUsage.self, forKey: "aggregate_usage")
        self.interval = try values.decode(Interval.self, forKey: "interval")
        self.intervalCount = try values.decode(Int.self, forKey: "interval_count")
        self.usageType = try values.decode(UsageType.self, forKey: "usage_type")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(aggregateUsage, forKey: "aggregate_usage")
        try values.encode(interval, forKey: "interval")
        try values.encode(intervalCount, forKey: "interval_count")
        try values.encode(usageType, forKey: "usage_type")
    }
}
