// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Payment_intent_payment_method_options_card
public struct PaymentIntentPaymentMethodOptionsCard: Codable {
    /// Controls when the funds will be captured from the customer's account.
    public var captureMethod: CaptureMethod?
    /// Installment details for this payment (Mexico only).
    /// 
    /// For more information, see the [installments integration guide](https://stripe.com/docs/payments/installments).
    public var installments: PaymentMethodOptionsCardInstallments?
    /// Configuration options for setting up an eMandate for cards issued in India.
    public var mandateOptions: PaymentMethodOptionsCardMandateOptions?
    /// Selected network to process this payment intent on. Depends on the available networks of the card attached to the payment intent. Can be only set confirm-time.
    public var network: Network?
    /// We strongly recommend that you rely on our SCA Engine to automatically prompt your customers for authentication based on risk level and [other requirements](https://stripe.com/docs/strong-customer-authentication). However, if you wish to request 3D Secure based on logic from your own fraud engine, provide this option. Permitted values include: `automatic` or `any`. If not provided, defaults to `automatic`. Read our guide on [manually requesting 3D Secure](https://stripe.com/docs/payments/3d-secure#manual-three-ds) for more information on how this configuration interacts with Radar and our SCA Engine.
    public var requestThreeDSecure: RequestThreeDSecure?
    /// Indicates that you intend to make future payments with this PaymentIntent's payment method.
    /// 
    /// Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.
    /// 
    /// When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).
    public var setupFutureUsage: SetupFutureUsage?
    /// Provides information about a card payment that customers see on their statements. Concatenated with the Kana prefix (shortened Kana descriptor) or Kana statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters. On card statements, the *concatenation* of both prefix and suffix (including separators) will appear truncated to 22 characters.
    public var statementDescriptorSuffixKana: String?
    /// Provides information about a card payment that customers see on their statements. Concatenated with the Kanji prefix (shortened Kanji descriptor) or Kanji statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 17 characters. On card statements, the *concatenation* of both prefix and suffix (including separators) will appear truncated to 17 characters.
    public var statementDescriptorSuffixKanji: String?

    /// Controls when the funds will be captured from the customer's account.
    public enum CaptureMethod: String, Codable, CaseIterable {
        case manual
    }

    /// Selected network to process this payment intent on. Depends on the available networks of the card attached to the payment intent. Can be only set confirm-time.
    public enum Network: String, Codable, CaseIterable {
        case amex
        case cartesBancaires = "cartes_bancaires"
        case diners
        case discover
        case interac
        case jcb
        case mastercard
        case unionpay
        case unknown
        case visa
    }

    /// We strongly recommend that you rely on our SCA Engine to automatically prompt your customers for authentication based on risk level and [other requirements](https://stripe.com/docs/strong-customer-authentication). However, if you wish to request 3D Secure based on logic from your own fraud engine, provide this option. Permitted values include: `automatic` or `any`. If not provided, defaults to `automatic`. Read our guide on [manually requesting 3D Secure](https://stripe.com/docs/payments/3d-secure#manual-three-ds) for more information on how this configuration interacts with Radar and our SCA Engine.
    public enum RequestThreeDSecure: String, Codable, CaseIterable {
        case any
        case automatic
        case challengeOnly = "challenge_only"
    }

    /// Indicates that you intend to make future payments with this PaymentIntent's payment method.
    /// 
    /// Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.
    /// 
    /// When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).
    public enum SetupFutureUsage: String, Codable, CaseIterable {
        case `none`
        case offSession = "off_session"
        case onSession = "on_session"
    }

    public init(captureMethod: CaptureMethod? = nil, installments: PaymentMethodOptionsCardInstallments? = nil, mandateOptions: PaymentMethodOptionsCardMandateOptions? = nil, network: Network? = nil, requestThreeDSecure: RequestThreeDSecure? = nil, setupFutureUsage: SetupFutureUsage? = nil, statementDescriptorSuffixKana: String? = nil, statementDescriptorSuffixKanji: String? = nil) {
        self.captureMethod = captureMethod
        self.installments = installments
        self.mandateOptions = mandateOptions
        self.network = network
        self.requestThreeDSecure = requestThreeDSecure
        self.setupFutureUsage = setupFutureUsage
        self.statementDescriptorSuffixKana = statementDescriptorSuffixKana
        self.statementDescriptorSuffixKanji = statementDescriptorSuffixKanji
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.captureMethod = try values.decodeIfPresent(CaptureMethod.self, forKey: "capture_method")
        self.installments = try values.decodeIfPresent(PaymentMethodOptionsCardInstallments.self, forKey: "installments")
        self.mandateOptions = try values.decodeIfPresent(PaymentMethodOptionsCardMandateOptions.self, forKey: "mandate_options")
        self.network = try values.decodeIfPresent(Network.self, forKey: "network")
        self.requestThreeDSecure = try values.decodeIfPresent(RequestThreeDSecure.self, forKey: "request_three_d_secure")
        self.setupFutureUsage = try values.decodeIfPresent(SetupFutureUsage.self, forKey: "setup_future_usage")
        self.statementDescriptorSuffixKana = try values.decodeIfPresent(String.self, forKey: "statement_descriptor_suffix_kana")
        self.statementDescriptorSuffixKanji = try values.decodeIfPresent(String.self, forKey: "statement_descriptor_suffix_kanji")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(captureMethod, forKey: "capture_method")
        try values.encodeIfPresent(installments, forKey: "installments")
        try values.encodeIfPresent(mandateOptions, forKey: "mandate_options")
        try values.encodeIfPresent(network, forKey: "network")
        try values.encodeIfPresent(requestThreeDSecure, forKey: "request_three_d_secure")
        try values.encodeIfPresent(setupFutureUsage, forKey: "setup_future_usage")
        try values.encodeIfPresent(statementDescriptorSuffixKana, forKey: "statement_descriptor_suffix_kana")
        try values.encodeIfPresent(statementDescriptorSuffixKanji, forKey: "statement_descriptor_suffix_kanji")
    }
}
