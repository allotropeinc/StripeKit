// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public final class TreasuryTransactionsResourceFlowDetails: Codable {
    /// TreasuryReceivedCreditsResourceCreditReversal
    ///
    /// You can reverse some [ReceivedCredits](https://stripe.com/docs/api#received_credits) depending on their network and source flow. Reversing a ReceivedCredit leads to the creation of a new object known as a CreditReversal.
    public let creditReversal: TreasuryCreditReversal?
    /// TreasuryReceivedDebitsResourceDebitReversal
    ///
    /// You can reverse some [ReceivedDebits](https://stripe.com/docs/api#received_debits) depending on their network and source flow. Reversing a ReceivedDebit leads to the creation of a new object known as a DebitReversal.
    public let debitReversal: TreasuryDebitReversal?
    /// TreasuryInboundTransfersResourceInboundTransfer
    ///
    /// Use [InboundTransfers](https://stripe.com/docs/treasury/moving-money/financial-accounts/into/inbound-transfers) to add funds to your [FinancialAccount](https://stripe.com/docs/api#financial_accounts) via a PaymentMethod that is owned by you. The funds will be transferred via an ACH debit.
    public let inboundTransfer: TreasuryInboundTransfer?
    /// When an [issued card](https://stripe.com/docs/issuing) is used to make a purchase, an Issuing `Authorization`
    /// object is created. [Authorizations](https://stripe.com/docs/issuing/purchases/authorizations) must be approved for the
    /// purchase to be completed successfully.
    /// 
    /// Related guide: [Issued Card Authorizations](https://stripe.com/docs/issuing/purchases/authorizations).
    public let issuingAuthorization: IssuingAuthorization?
    /// TreasuryOutboundPaymentsResourceOutboundPayment
    ///
    /// Use OutboundPayments to send funds to another party's external bank account or [FinancialAccount](https://stripe.com/docs/api#financial_accounts). To send money to an account belonging to the same user, use an [OutboundTransfer](https://stripe.com/docs/api#outbound_transfers).
    /// 
    /// Simulate OutboundPayment state changes with the `/v1/test_helpers/treasury/outbound_payments` endpoints. These methods can only be called on test mode objects.
    public let outboundPayment: TreasuryOutboundPayment?
    /// TreasuryOutboundTransfersResourceOutboundTransfer
    ///
    /// Use OutboundTransfers to transfer funds from a [FinancialAccount](https://stripe.com/docs/api#financial_accounts) to a PaymentMethod belonging to the same entity. To send funds to a different party, use [OutboundPayments](https://stripe.com/docs/api#outbound_payments) instead. You can send funds over ACH rails or through a domestic wire transfer to a user's own external bank account.
    /// 
    /// Simulate OutboundTransfer state changes with the `/v1/test_helpers/treasury/outbound_transfers` endpoints. These methods can only be called on test mode objects.
    public let outboundTransfer: TreasuryOutboundTransfer?
    /// TreasuryReceivedCreditsResourceReceivedCredit
    ///
    /// ReceivedCredits represent funds sent to a [FinancialAccount](https://stripe.com/docs/api#financial_accounts) (for example, via ACH or wire). These money movements are not initiated from the FinancialAccount.
    public let receivedCredit: TreasuryReceivedCredit?
    /// TreasuryReceivedDebitsResourceReceivedDebit
    ///
    /// ReceivedDebits represent funds pulled from a [FinancialAccount](https://stripe.com/docs/api#financial_accounts). These are not initiated from the FinancialAccount.
    public let receivedDebit: TreasuryReceivedDebit?
    /// Type of the flow that created the Transaction. Set to the same value as `flow_type`.
    public let type: `Type`

    /// Type of the flow that created the Transaction. Set to the same value as `flow_type`.
    public enum `Type`: String, Codable, CaseIterable {
        case creditReversal = "credit_reversal"
        case debitReversal = "debit_reversal"
        case inboundTransfer = "inbound_transfer"
        case issuingAuthorization = "issuing_authorization"
        case other
        case outboundPayment = "outbound_payment"
        case outboundTransfer = "outbound_transfer"
        case receivedCredit = "received_credit"
        case receivedDebit = "received_debit"
    }

    public init(creditReversal: TreasuryCreditReversal? = nil, debitReversal: TreasuryDebitReversal? = nil, inboundTransfer: TreasuryInboundTransfer? = nil, issuingAuthorization: IssuingAuthorization? = nil, outboundPayment: TreasuryOutboundPayment? = nil, outboundTransfer: TreasuryOutboundTransfer? = nil, receivedCredit: TreasuryReceivedCredit? = nil, receivedDebit: TreasuryReceivedDebit? = nil, type: `Type`) {
        self.creditReversal = creditReversal
        self.debitReversal = debitReversal
        self.inboundTransfer = inboundTransfer
        self.issuingAuthorization = issuingAuthorization
        self.outboundPayment = outboundPayment
        self.outboundTransfer = outboundTransfer
        self.receivedCredit = receivedCredit
        self.receivedDebit = receivedDebit
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.creditReversal = try values.decodeIfPresent(TreasuryCreditReversal.self, forKey: "credit_reversal")
        self.debitReversal = try values.decodeIfPresent(TreasuryDebitReversal.self, forKey: "debit_reversal")
        self.inboundTransfer = try values.decodeIfPresent(TreasuryInboundTransfer.self, forKey: "inbound_transfer")
        self.issuingAuthorization = try values.decodeIfPresent(IssuingAuthorization.self, forKey: "issuing_authorization")
        self.outboundPayment = try values.decodeIfPresent(TreasuryOutboundPayment.self, forKey: "outbound_payment")
        self.outboundTransfer = try values.decodeIfPresent(TreasuryOutboundTransfer.self, forKey: "outbound_transfer")
        self.receivedCredit = try values.decodeIfPresent(TreasuryReceivedCredit.self, forKey: "received_credit")
        self.receivedDebit = try values.decodeIfPresent(TreasuryReceivedDebit.self, forKey: "received_debit")
        self.type = try values.decode(`Type`.self, forKey: "type")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(creditReversal, forKey: "credit_reversal")
        try values.encodeIfPresent(debitReversal, forKey: "debit_reversal")
        try values.encodeIfPresent(inboundTransfer, forKey: "inbound_transfer")
        try values.encodeIfPresent(issuingAuthorization, forKey: "issuing_authorization")
        try values.encodeIfPresent(outboundPayment, forKey: "outbound_payment")
        try values.encodeIfPresent(outboundTransfer, forKey: "outbound_transfer")
        try values.encodeIfPresent(receivedCredit, forKey: "received_credit")
        try values.encodeIfPresent(receivedDebit, forKey: "received_debit")
        try values.encode(type, forKey: "type")
    }
}
