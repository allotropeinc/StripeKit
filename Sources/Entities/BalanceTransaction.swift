// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Balance transactions represent funds moving through your Stripe account.
/// They're created for every type of transaction that comes into or flows out of your Stripe account balance.
/// 
/// Related guide: [Balance Transaction Types](https://stripe.com/docs/reports/balance-transaction-types).
public final class BalanceTransaction: Codable {
    /// Gross amount of the transaction, in %s.
    public let amount: Int
    /// The date the transaction's net funds will become available in the Stripe balance.
    public let availableOn: Int
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public let created: Int
    /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    public let currency: String
    /// An arbitrary string attached to the object. Often useful for displaying to users.
    public let description: String?
    /// The exchange rate used, if applicable, for this transaction. Specifically, if money was converted from currency A to currency B, then the `amount` in currency A, times `exchange_rate`, would be the `amount` in currency B. For example, suppose you charged a customer 10.00 EUR. Then the PaymentIntent's `amount` would be `1000` and `currency` would be `eur`. Suppose this was converted into 12.34 USD in your Stripe account. Then the BalanceTransaction's `amount` would be `1234`, `currency` would be `usd`, and `exchange_rate` would be `1.234`.
    public let exchangeRate: Double?
    /// Fees (in %s) paid for this transaction.
    public let fee: Int
    /// Detailed breakdown of fees (in %s) paid for this transaction.
    public let feeDetails: [Fee]
    /// Unique identifier for the object.
    public let id: String
    /// Net amount of the transaction, in %s.
    public let net: Int
    /// String representing the object's type. Objects of the same type share the same value.
    public let object: Object
    /// [Learn more](https://stripe.com/docs/reports/reporting-categories) about how reporting categories can help you understand balance transactions from an accounting perspective.
    public let reportingCategory: String
    /// The Stripe object to which this transaction is related.
    public let source: Source?
    /// If the transaction's net funds are available in the Stripe balance yet. Either `available` or `pending`.
    public let status: String
    /// Transaction type: `adjustment`, `advance`, `advance_funding`, `anticipation_repayment`, `application_fee`, `application_fee_refund`, `charge`, `connect_collection_transfer`, `contribution`, `issuing_authorization_hold`, `issuing_authorization_release`, `issuing_dispute`, `issuing_transaction`, `payment`, `payment_failure_refund`, `payment_refund`, `payout`, `payout_cancel`, `payout_failure`, `refund`, `refund_failure`, `reserve_transaction`, `reserved_funds`, `stripe_fee`, `stripe_fx_fee`, `tax_fee`, `topup`, `topup_reversal`, `transfer`, `transfer_cancel`, `transfer_failure`, or `transfer_refund`. [Learn more](https://stripe.com/docs/reports/balance-transaction-types) about balance transaction types and what they represent. If you are looking to classify transactions for accounting purposes, you might want to consider `reporting_category` instead.
    public let type: `Type`

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case balanceTransaction = "balance_transaction"
    }

    /// The Stripe object to which this transaction is related.
    public struct Source: Codable {
        public var string: String?
        /// PlatformFee
        public var applicationFee: ApplicationFee?
        /// To charge a credit or a debit card, you create a `Charge` object. You can
        /// retrieve and refund individual charges as well as list all charges. Charges
        /// are identified by a unique, random ID.
        /// 
        /// Related guide: [Accept a payment with the Charges API](https://stripe.com/docs/payments/accept-a-payment-charges).
        public var charge: Charge?
        public var connectCollectionTransfer: ConnectCollectionTransfer?
        /// A dispute occurs when a customer questions your charge with their card issuer.
        /// When this happens, you're given the opportunity to respond to the dispute with
        /// evidence that shows that the charge is legitimate. You can find more
        /// information about the dispute process in our [Disputes and
        /// Fraud](/docs/disputes) documentation.
        /// 
        /// Related guide: [Disputes and Fraud](https://stripe.com/docs/disputes).
        public var dispute: Dispute?
        /// `Application Fee Refund` objects allow you to refund an application fee that
        /// has previously been created but not yet refunded. Funds will be refunded to
        /// the Stripe account from which the fee was originally collected.
        /// 
        /// Related guide: [Refunding Application Fees](https://stripe.com/docs/connect/destination-charges#refunding-app-fee).
        public var feeRefund: FeeRefund?
        /// When an [issued card](https://stripe.com/docs/issuing) is used to make a purchase, an Issuing `Authorization`
        /// object is created. [Authorizations](https://stripe.com/docs/issuing/purchases/authorizations) must be approved for the
        /// purchase to be completed successfully.
        /// 
        /// Related guide: [Issued Card Authorizations](https://stripe.com/docs/issuing/purchases/authorizations).
        public var issuingAuthorization: IssuingAuthorization?
        /// As a [card issuer](https://stripe.com/docs/issuing), you can dispute transactions that the cardholder does not recognize, suspects to be fraudulent, or has other issues with.
        /// 
        /// Related guide: [Disputing Transactions](https://stripe.com/docs/issuing/purchases/disputes)
        public var issuingDispute: IssuingDispute?
        /// Any use of an [issued card](https://stripe.com/docs/issuing) that results in funds entering or leaving
        /// your Stripe account, such as a completed purchase or refund, is represented by an Issuing
        /// `Transaction` object.
        /// 
        /// Related guide: [Issued Card Transactions](https://stripe.com/docs/issuing/purchases/transactions).
        public var issuingTransaction: IssuingTransaction?
        /// A `Payout` object is created when you receive funds from Stripe, or when you
        /// initiate a payout to either a bank account or debit card of a [connected
        /// Stripe account](/docs/connect/bank-debit-card-payouts). You can retrieve individual payouts,
        /// as well as list all payouts. Payouts are made on [varying
        /// schedules](/docs/connect/manage-payout-schedule), depending on your country and
        /// industry.
        /// 
        /// Related guide: [Receiving Payouts](https://stripe.com/docs/payouts).
        public var payout: Payout?
        /// PlatformTax
        public var platformTaxFee: PlatformTaxFee?
        /// `Refund` objects allow you to refund a charge that has previously been created
        /// but not yet refunded. Funds will be refunded to the credit or debit card that
        /// was originally charged.
        /// 
        /// Related guide: [Refunds](https://stripe.com/docs/refunds).
        public var refund: Refund?
        public var reserveTransaction: ReserveTransaction?
        public var taxDeductedAtSource: TaxDeductedAtSource?
        /// To top up your Stripe balance, you create a top-up object. You can retrieve
        /// individual top-ups, as well as list all top-ups. Top-ups are identified by a
        /// unique, random ID.
        /// 
        /// Related guide: [Topping Up your Platform Account](https://stripe.com/docs/connect/top-ups).
        public var topup: Topup?
        /// A `Transfer` object is created when you move funds between Stripe accounts as
        /// part of Connect.
        /// 
        /// Before April 6, 2017, transfers also represented movement of funds from a
        /// Stripe account to a card or bank account. This behavior has since been split
        /// out into a [Payout](https://stripe.com/docs/api#payout_object) object, with corresponding payout endpoints. For more
        /// information, read about the
        /// [transfer/payout split](https://stripe.com/docs/transfer-payout-split).
        /// 
        /// Related guide: [Creating Separate Charges and Transfers](https://stripe.com/docs/connect/charges-transfers).
        public var transfer: Transfer?
        /// [Stripe Connect](https://stripe.com/docs/connect) platforms can reverse transfers made to a
        /// connected account, either entirely or partially, and can also specify whether
        /// to refund any related application fees. Transfer reversals add to the
        /// platform's balance and subtract from the destination account's balance.
        /// 
        /// Reversing a transfer that was made for a [destination
        /// charge](/docs/connect/destination-charges) is allowed only up to the amount of
        /// the charge. It is possible to reverse a
        /// [transfer_group](https://stripe.com/docs/connect/charges-transfers#transfer-options)
        /// transfer only if the destination account has enough balance to cover the
        /// reversal.
        /// 
        /// Related guide: [Reversing Transfers](https://stripe.com/docs/connect/charges-transfers#reversing-transfers).
        public var transferReversal: TransferReversal?

        public init(string: String? = nil, applicationFee: ApplicationFee? = nil, charge: Charge? = nil, connectCollectionTransfer: ConnectCollectionTransfer? = nil, dispute: Dispute? = nil, feeRefund: FeeRefund? = nil, issuingAuthorization: IssuingAuthorization? = nil, issuingDispute: IssuingDispute? = nil, issuingTransaction: IssuingTransaction? = nil, payout: Payout? = nil, platformTaxFee: PlatformTaxFee? = nil, refund: Refund? = nil, reserveTransaction: ReserveTransaction? = nil, taxDeductedAtSource: TaxDeductedAtSource? = nil, topup: Topup? = nil, transfer: Transfer? = nil, transferReversal: TransferReversal? = nil) {
            self.string = string
            self.applicationFee = applicationFee
            self.charge = charge
            self.connectCollectionTransfer = connectCollectionTransfer
            self.dispute = dispute
            self.feeRefund = feeRefund
            self.issuingAuthorization = issuingAuthorization
            self.issuingDispute = issuingDispute
            self.issuingTransaction = issuingTransaction
            self.payout = payout
            self.platformTaxFee = platformTaxFee
            self.refund = refund
            self.reserveTransaction = reserveTransaction
            self.taxDeductedAtSource = taxDeductedAtSource
            self.topup = topup
            self.transfer = transfer
            self.transferReversal = transferReversal
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.applicationFee = try? container.decode(ApplicationFee.self)
            self.charge = try? container.decode(Charge.self)
            self.connectCollectionTransfer = try? container.decode(ConnectCollectionTransfer.self)
            self.dispute = try? container.decode(Dispute.self)
            self.feeRefund = try? container.decode(FeeRefund.self)
            self.issuingAuthorization = try? container.decode(IssuingAuthorization.self)
            self.issuingDispute = try? container.decode(IssuingDispute.self)
            self.issuingTransaction = try? container.decode(IssuingTransaction.self)
            self.payout = try? container.decode(Payout.self)
            self.platformTaxFee = try? container.decode(PlatformTaxFee.self)
            self.refund = try? container.decode(Refund.self)
            self.reserveTransaction = try? container.decode(ReserveTransaction.self)
            self.taxDeductedAtSource = try? container.decode(TaxDeductedAtSource.self)
            self.topup = try? container.decode(Topup.self)
            self.transfer = try? container.decode(Transfer.self)
            self.transferReversal = try? container.decode(TransferReversal.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = applicationFee { try container.encode(value) }
            if let value = charge { try container.encode(value) }
            if let value = connectCollectionTransfer { try container.encode(value) }
            if let value = dispute { try container.encode(value) }
            if let value = feeRefund { try container.encode(value) }
            if let value = issuingAuthorization { try container.encode(value) }
            if let value = issuingDispute { try container.encode(value) }
            if let value = issuingTransaction { try container.encode(value) }
            if let value = payout { try container.encode(value) }
            if let value = platformTaxFee { try container.encode(value) }
            if let value = refund { try container.encode(value) }
            if let value = reserveTransaction { try container.encode(value) }
            if let value = taxDeductedAtSource { try container.encode(value) }
            if let value = topup { try container.encode(value) }
            if let value = transfer { try container.encode(value) }
            if let value = transferReversal { try container.encode(value) }
        }
    }

    /// Transaction type: `adjustment`, `advance`, `advance_funding`, `anticipation_repayment`, `application_fee`, `application_fee_refund`, `charge`, `connect_collection_transfer`, `contribution`, `issuing_authorization_hold`, `issuing_authorization_release`, `issuing_dispute`, `issuing_transaction`, `payment`, `payment_failure_refund`, `payment_refund`, `payout`, `payout_cancel`, `payout_failure`, `refund`, `refund_failure`, `reserve_transaction`, `reserved_funds`, `stripe_fee`, `stripe_fx_fee`, `tax_fee`, `topup`, `topup_reversal`, `transfer`, `transfer_cancel`, `transfer_failure`, or `transfer_refund`. [Learn more](https://stripe.com/docs/reports/balance-transaction-types) about balance transaction types and what they represent. If you are looking to classify transactions for accounting purposes, you might want to consider `reporting_category` instead.
    public enum `Type`: String, Codable, CaseIterable {
        case adjustment
        case advance
        case advanceFunding = "advance_funding"
        case anticipationRepayment = "anticipation_repayment"
        case applicationFee = "application_fee"
        case applicationFeeRefund = "application_fee_refund"
        case charge
        case connectCollectionTransfer = "connect_collection_transfer"
        case contribution
        case issuingAuthorizationHold = "issuing_authorization_hold"
        case issuingAuthorizationRelease = "issuing_authorization_release"
        case issuingDispute = "issuing_dispute"
        case issuingTransaction = "issuing_transaction"
        case payment
        case paymentFailureRefund = "payment_failure_refund"
        case paymentRefund = "payment_refund"
        case payout
        case payoutCancel = "payout_cancel"
        case payoutFailure = "payout_failure"
        case refund
        case refundFailure = "refund_failure"
        case reserveTransaction = "reserve_transaction"
        case reservedFunds = "reserved_funds"
        case stripeFee = "stripe_fee"
        case stripeFxFee = "stripe_fx_fee"
        case taxFee = "tax_fee"
        case topup
        case topupReversal = "topup_reversal"
        case transfer
        case transferCancel = "transfer_cancel"
        case transferFailure = "transfer_failure"
        case transferRefund = "transfer_refund"
    }

    public init(amount: Int, availableOn: Int, created: Int, currency: String, description: String? = nil, exchangeRate: Double? = nil, fee: Int, feeDetails: [Fee], id: String, net: Int, object: Object, reportingCategory: String, source: Source? = nil, status: String, type: `Type`) {
        self.amount = amount
        self.availableOn = availableOn
        self.created = created
        self.currency = currency
        self.description = description
        self.exchangeRate = exchangeRate
        self.fee = fee
        self.feeDetails = feeDetails
        self.id = id
        self.net = net
        self.object = object
        self.reportingCategory = reportingCategory
        self.source = source
        self.status = status
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.amount = try values.decode(Int.self, forKey: "amount")
        self.availableOn = try values.decode(Int.self, forKey: "available_on")
        self.created = try values.decode(Int.self, forKey: "created")
        self.currency = try values.decode(String.self, forKey: "currency")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.exchangeRate = try values.decodeIfPresent(Double.self, forKey: "exchange_rate")
        self.fee = try values.decode(Int.self, forKey: "fee")
        self.feeDetails = try values.decode([Fee].self, forKey: "fee_details")
        self.id = try values.decode(String.self, forKey: "id")
        self.net = try values.decode(Int.self, forKey: "net")
        self.object = try values.decode(Object.self, forKey: "object")
        self.reportingCategory = try values.decode(String.self, forKey: "reporting_category")
        self.source = try values.decodeIfPresent(Source.self, forKey: "source")
        self.status = try values.decode(String.self, forKey: "status")
        self.type = try values.decode(`Type`.self, forKey: "type")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(amount, forKey: "amount")
        try values.encode(availableOn, forKey: "available_on")
        try values.encode(created, forKey: "created")
        try values.encode(currency, forKey: "currency")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(exchangeRate, forKey: "exchange_rate")
        try values.encode(fee, forKey: "fee")
        try values.encode(feeDetails, forKey: "fee_details")
        try values.encode(id, forKey: "id")
        try values.encode(net, forKey: "net")
        try values.encode(object, forKey: "object")
        try values.encode(reportingCategory, forKey: "reporting_category")
        try values.encodeIfPresent(source, forKey: "source")
        try values.encode(status, forKey: "status")
        try values.encode(type, forKey: "type")
    }
}
