// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// TestClock
///
/// A test clock enables deterministic control over objects in testmode. With a test clock, you can create
/// objects at a frozen time in the past or future, and advance to a specific future time to observe webhooks and state changes. After the clock advances,
/// you can either validate the current state of your scenario (and test your assumptions), change the current state of your scenario (and test more complex scenarios), or keep advancing forward in time.
public struct TestHelpersTestClock: Codable {
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public var created: Int
    /// Time at which this clock is scheduled to auto delete.
    public var deletesAfter: Int
    /// Time at which all objects belonging to this clock are frozen.
    public var frozenTime: Int
    /// Unique identifier for the object.
    public var id: String
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// The custom name supplied at creation.
    public var name: String?
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// The status of the Test Clock.
    public var status: Status

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case testHelpersTestClock = "test_helpers.test_clock"
    }

    /// The status of the Test Clock.
    public enum Status: String, Codable, CaseIterable {
        case advancing
        case internalFailure = "internal_failure"
        case ready
    }

    public init(created: Int, deletesAfter: Int, frozenTime: Int, id: String, isLivemode: Bool, name: String? = nil, object: Object, status: Status) {
        self.created = created
        self.deletesAfter = deletesAfter
        self.frozenTime = frozenTime
        self.id = id
        self.isLivemode = isLivemode
        self.name = name
        self.object = object
        self.status = status
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.created = try values.decode(Int.self, forKey: "created")
        self.deletesAfter = try values.decode(Int.self, forKey: "deletes_after")
        self.frozenTime = try values.decode(Int.self, forKey: "frozen_time")
        self.id = try values.decode(String.self, forKey: "id")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.object = try values.decode(Object.self, forKey: "object")
        self.status = try values.decode(Status.self, forKey: "status")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(created, forKey: "created")
        try values.encode(deletesAfter, forKey: "deletes_after")
        try values.encode(frozenTime, forKey: "frozen_time")
        try values.encode(id, forKey: "id")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encode(object, forKey: "object")
        try values.encode(status, forKey: "status")
    }
}
