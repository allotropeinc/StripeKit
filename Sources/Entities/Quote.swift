// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// A Quote is a way to model prices that you'd like to provide to a customer.
/// Once accepted, it will automatically create an invoice, subscription or subscription schedule.
public struct Quote: Codable {
    /// Total before any discounts or taxes are applied.
    public var amountSubtotal: Int
    /// Total after discounts and taxes are applied.
    public var amountTotal: Int
    /// ID of the Connect Application that created the quote.
    public var application: Application?
    /// The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. Only applicable if there are no line items with recurring prices on the quote.
    public var applicationFeeAmount: Int?
    /// A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. Only applicable if there are line items with recurring prices on the quote.
    public var applicationFeePercent: Double?
    /// QuotesResourceAutomaticTax
    public var automaticTax: QuotesResourceAutomaticTax
    /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or on finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    public var collectionMethod: CollectionMethod
    /// QuotesResourceComputed
    public var computed: QuotesResourceComputed
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public var created: Int
    /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    public var currency: String?
    /// The customer which this quote belongs to. A customer is required before finalizing the quote. Once specified, it cannot be changed.
    public var customer: Customer?
    /// The tax rates applied to this quote.
    public var defaultTaxRates: [DefaultTaxRate]?
    /// A description that will be displayed on the quote PDF.
    public var description: String?
    /// The discounts applied to this quote.
    public var discounts: [Discount]
    /// The date on which the quote will be canceled if in `open` or `draft` status. Measured in seconds since the Unix epoch.
    public var expiresAt: Int
    /// A footer that will be displayed on the quote PDF.
    public var footer: String?
    /// Details of the quote that was cloned. See the [cloning documentation](https://stripe.com/docs/quotes/clone) for more details.
    public var fromQuote: QuotesResourceFromQuote?
    /// A header that will be displayed on the quote PDF.
    public var header: String?
    /// Unique identifier for the object.
    public var id: String
    /// The invoice that was created from this quote.
    public var invoice: Invoice?
    /// All invoices will be billed using the specified settings.
    public var invoiceSettings: InvoiceSettingQuoteSetting?
    /// QuotesResourceListLineItems
    ///
    /// A list of items the customer is being quoted for.
    public var lineItems: LineItems?
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    public var metadata: [String: String]
    /// A unique number that identifies this particular quote. This number is assigned once the quote is [finalized](https://stripe.com/docs/quotes/overview#finalize).
    public var number: String?
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// The account on behalf of which to charge. See the [Connect documentation](https://support.stripe.com/questions/sending-invoices-on-behalf-of-connected-accounts) for details.
    public var onBehalfOf: OnBehalfOf?
    /// The status of the quote.
    public var status: Status
    /// QuotesResourceStatusTransitions
    public var statusTransitions: QuotesResourceStatusTransitions
    /// The subscription that was created or updated from this quote.
    public var subscription: Subscription?
    /// QuotesResourceSubscriptionData
    public var subscriptionData: QuotesResourceSubscriptionData
    /// The subscription schedule that was created or updated from this quote.
    public var subscriptionSchedule: SubscriptionSchedule?
    /// ID of the test clock this quote belongs to.
    public var testClock: TestClock?
    /// QuotesResourceTotalDetails
    public var totalDetails: QuotesResourceTotalDetails
    /// The account (if any) the payments will be attributed to for tax reporting, and where funds from each payment will be transferred to for each of the invoices.
    public var transferData: QuotesResourceTransferData?

    /// ID of the Connect Application that created the quote.
    public final class Application: Codable {
        public let string: String?
        public let application: StripeKit.Application?
        public let deletedApplication: DeletedApplication?

        public init(string: String? = nil, application: StripeKit.Application? = nil, deletedApplication: DeletedApplication? = nil) {
            self.string = string
            self.application = application
            self.deletedApplication = deletedApplication
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.application = try? container.decode(StripeKit.Application.self)
            self.deletedApplication = try? container.decode(DeletedApplication.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = application { try container.encode(value) }
            if let value = deletedApplication { try container.encode(value) }
        }
    }

    /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or on finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    public enum CollectionMethod: String, Codable, CaseIterable {
        case chargeAutomatically = "charge_automatically"
        case sendInvoice = "send_invoice"
    }

    /// The customer which this quote belongs to. A customer is required before finalizing the quote. Once specified, it cannot be changed.
    public final class Customer: Codable {
        public let string: String?
        /// This object represents a customer of your business. It lets you create recurring charges and track payments that belong to the same customer.
        /// 
        /// Related guide: [Save a card during payment](https://stripe.com/docs/payments/save-during-payment).
        public let customer: StripeKit.Customer?
        public let deletedCustomer: DeletedCustomer?

        public init(string: String? = nil, customer: StripeKit.Customer? = nil, deletedCustomer: DeletedCustomer? = nil) {
            self.string = string
            self.customer = customer
            self.deletedCustomer = deletedCustomer
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.customer = try? container.decode(StripeKit.Customer.self)
            self.deletedCustomer = try? container.decode(DeletedCustomer.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = customer { try container.encode(value) }
            if let value = deletedCustomer { try container.encode(value) }
        }
    }

    public struct DefaultTaxRate: Codable {
        public var string: String?
        /// Tax rates can be applied to [invoices](https://stripe.com/docs/billing/invoices/tax-rates), [subscriptions](https://stripe.com/docs/billing/subscriptions/taxes) and [Checkout Sessions](https://stripe.com/docs/payments/checkout/set-up-a-subscription#tax-rates) to collect tax.
        /// 
        /// Related guide: [Tax Rates](https://stripe.com/docs/billing/taxes/tax-rates).
        public var taxRate: TaxRate?

        public init(string: String? = nil, taxRate: TaxRate? = nil) {
            self.string = string
            self.taxRate = taxRate
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.taxRate = try? container.decode(TaxRate.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = taxRate { try container.encode(value) }
        }
    }

    public final class Discount: Codable {
        public let string: String?
        /// A discount represents the actual application of a [coupon](https://stripe.com/docs/api#coupons) or [promotion code](https://stripe.com/docs/api#promotion_codes).
        /// It contains information about when the discount began, when it will end, and what it is applied to.
        /// 
        /// Related guide: [Applying Discounts to Subscriptions](https://stripe.com/docs/billing/subscriptions/discounts).
        public let discount: StripeKit.Discount?

        public init(string: String? = nil, discount: StripeKit.Discount? = nil) {
            self.string = string
            self.discount = discount
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.discount = try? container.decode(StripeKit.Discount.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = discount { try container.encode(value) }
        }
    }

    /// The invoice that was created from this quote.
    public final class Invoice: Codable {
        public let string: String?
        /// Invoices are statements of amounts owed by a customer, and are either
        /// generated one-off, or generated periodically from a subscription.
        /// 
        /// They contain [invoice items](https://stripe.com/docs/api#invoiceitems), and proration adjustments
        /// that may be caused by subscription upgrades/downgrades (if necessary).
        /// 
        /// If your invoice is configured to be billed through automatic charges,
        /// Stripe automatically finalizes your invoice and attempts payment. Note
        /// that finalizing the invoice,
        /// [when automatic](https://stripe.com/docs/billing/invoices/workflow/#auto_advance), does
        /// not happen immediately as the invoice is created. Stripe waits
        /// until one hour after the last webhook was successfully sent (or the last
        /// webhook timed out after failing). If you (and the platforms you may have
        /// connected to) have no webhooks configured, Stripe waits one hour after
        /// creation to finalize the invoice.
        /// 
        /// If your invoice is configured to be billed by sending an email, then based on your
        /// [email settings](https://dashboard.stripe.com/account/billing/automatic),
        /// Stripe will email the invoice to your customer and await payment. These
        /// emails can contain a link to a hosted page to pay the invoice.
        /// 
        /// Stripe applies any customer credit on the account before determining the
        /// amount due for the invoice (i.e., the amount that will be actually
        /// charged). If the amount due for the invoice is less than Stripe's [minimum allowed charge
        /// per currency](/docs/currencies#minimum-and-maximum-charge-amounts), the
        /// invoice is automatically marked paid, and we add the amount due to the
        /// customer's credit balance which is applied to the next invoice.
        /// 
        /// More details on the customer's credit balance are
        /// [here](https://stripe.com/docs/billing/customer/balance).
        /// 
        /// Related guide: [Send Invoices to Customers](https://stripe.com/docs/billing/invoices/sending).
        public let invoice: StripeKit.Invoice?
        public let deletedInvoice: DeletedInvoice?

        public init(string: String? = nil, invoice: StripeKit.Invoice? = nil, deletedInvoice: DeletedInvoice? = nil) {
            self.string = string
            self.invoice = invoice
            self.deletedInvoice = deletedInvoice
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.invoice = try? container.decode(StripeKit.Invoice.self)
            self.deletedInvoice = try? container.decode(DeletedInvoice.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = invoice { try container.encode(value) }
            if let value = deletedInvoice { try container.encode(value) }
        }
    }

    /// QuotesResourceListLineItems
    ///
    /// A list of items the customer is being quoted for.
    public struct LineItems: Codable {
        /// Details about each object.
        public var data: [Item]
        /// True if this list has another page of items after this one that can be fetched.
        public var hasMore: Bool
        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public var object: Object
        /// The URL where this list can be accessed.
        public var url: String

        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public enum Object: String, Codable, CaseIterable {
            case list
        }

        public init(data: [Item], hasMore: Bool, object: Object, url: String) {
            self.data = data
            self.hasMore = hasMore
            self.object = object
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.data = try values.decode([Item].self, forKey: "data")
            self.hasMore = try values.decode(Bool.self, forKey: "has_more")
            self.object = try values.decode(Object.self, forKey: "object")
            self.url = try values.decode(String.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(data, forKey: "data")
            try values.encode(hasMore, forKey: "has_more")
            try values.encode(object, forKey: "object")
            try values.encode(url, forKey: "url")
        }
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case quote
    }

    /// The account on behalf of which to charge. See the [Connect documentation](https://support.stripe.com/questions/sending-invoices-on-behalf-of-connected-accounts) for details.
    public struct OnBehalfOf: Codable {
        public var string: String?
        /// This is an object representing a Stripe account. You can retrieve it to see
        /// properties on the account like its current e-mail address or if the account is
        /// enabled yet to make live charges.
        /// 
        /// Some properties, marked below, are available only to platforms that want to
        /// [create and manage Express or Custom accounts](https://stripe.com/docs/connect/accounts).
        public var account: Account?

        public init(string: String? = nil, account: Account? = nil) {
            self.string = string
            self.account = account
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.account = try? container.decode(Account.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = account { try container.encode(value) }
        }
    }

    /// The status of the quote.
    public enum Status: String, Codable, CaseIterable {
        case accepted
        case canceled
        case draft
        case `open`
    }

    /// The subscription that was created or updated from this quote.
    public final class Subscription: Codable {
        public let string: String?
        /// Subscriptions allow you to charge a customer on a recurring basis.
        /// 
        /// Related guide: [Creating Subscriptions](https://stripe.com/docs/billing/subscriptions/creating).
        public let subscription: StripeKit.Subscription?

        public init(string: String? = nil, subscription: StripeKit.Subscription? = nil) {
            self.string = string
            self.subscription = subscription
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.subscription = try? container.decode(StripeKit.Subscription.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = subscription { try container.encode(value) }
        }
    }

    /// The subscription schedule that was created or updated from this quote.
    public final class SubscriptionSchedule: Codable {
        public let string: String?
        /// A subscription schedule allows you to create and manage the lifecycle of a subscription by predefining expected changes.
        /// 
        /// Related guide: [Subscription Schedules](https://stripe.com/docs/billing/subscriptions/subscription-schedules).
        public let subscriptionSchedule: StripeKit.SubscriptionSchedule?

        public init(string: String? = nil, subscriptionSchedule: StripeKit.SubscriptionSchedule? = nil) {
            self.string = string
            self.subscriptionSchedule = subscriptionSchedule
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.subscriptionSchedule = try? container.decode(StripeKit.SubscriptionSchedule.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = subscriptionSchedule { try container.encode(value) }
        }
    }

    /// ID of the test clock this quote belongs to.
    public struct TestClock: Codable {
        public var string: String?
        /// TestClock
        ///
        /// A test clock enables deterministic control over objects in testmode. With a test clock, you can create
        /// objects at a frozen time in the past or future, and advance to a specific future time to observe webhooks and state changes. After the clock advances,
        /// you can either validate the current state of your scenario (and test your assumptions), change the current state of your scenario (and test more complex scenarios), or keep advancing forward in time.
        public var testHelpersTestClock: TestHelpersTestClock?

        public init(string: String? = nil, testHelpersTestClock: TestHelpersTestClock? = nil) {
            self.string = string
            self.testHelpersTestClock = testHelpersTestClock
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.testHelpersTestClock = try? container.decode(TestHelpersTestClock.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = testHelpersTestClock { try container.encode(value) }
        }
    }

    public init(amountSubtotal: Int, amountTotal: Int, application: Application? = nil, applicationFeeAmount: Int? = nil, applicationFeePercent: Double? = nil, automaticTax: QuotesResourceAutomaticTax, collectionMethod: CollectionMethod, computed: QuotesResourceComputed, created: Int, currency: String? = nil, customer: Customer? = nil, defaultTaxRates: [DefaultTaxRate]? = nil, description: String? = nil, discounts: [Discount], expiresAt: Int, footer: String? = nil, fromQuote: QuotesResourceFromQuote? = nil, header: String? = nil, id: String, invoice: Invoice? = nil, invoiceSettings: InvoiceSettingQuoteSetting? = nil, lineItems: LineItems? = nil, isLivemode: Bool, metadata: [String: String], number: String? = nil, object: Object, onBehalfOf: OnBehalfOf? = nil, status: Status, statusTransitions: QuotesResourceStatusTransitions, subscription: Subscription? = nil, subscriptionData: QuotesResourceSubscriptionData, subscriptionSchedule: SubscriptionSchedule? = nil, testClock: TestClock? = nil, totalDetails: QuotesResourceTotalDetails, transferData: QuotesResourceTransferData? = nil) {
        self.amountSubtotal = amountSubtotal
        self.amountTotal = amountTotal
        self.application = application
        self.applicationFeeAmount = applicationFeeAmount
        self.applicationFeePercent = applicationFeePercent
        self.automaticTax = automaticTax
        self.collectionMethod = collectionMethod
        self.computed = computed
        self.created = created
        self.currency = currency
        self.customer = customer
        self.defaultTaxRates = defaultTaxRates
        self.description = description
        self.discounts = discounts
        self.expiresAt = expiresAt
        self.footer = footer
        self.fromQuote = fromQuote
        self.header = header
        self.id = id
        self.invoice = invoice
        self.invoiceSettings = invoiceSettings
        self.lineItems = lineItems
        self.isLivemode = isLivemode
        self.metadata = metadata
        self.number = number
        self.object = object
        self.onBehalfOf = onBehalfOf
        self.status = status
        self.statusTransitions = statusTransitions
        self.subscription = subscription
        self.subscriptionData = subscriptionData
        self.subscriptionSchedule = subscriptionSchedule
        self.testClock = testClock
        self.totalDetails = totalDetails
        self.transferData = transferData
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.amountSubtotal = try values.decode(Int.self, forKey: "amount_subtotal")
        self.amountTotal = try values.decode(Int.self, forKey: "amount_total")
        self.application = try values.decodeIfPresent(Application.self, forKey: "application")
        self.applicationFeeAmount = try values.decodeIfPresent(Int.self, forKey: "application_fee_amount")
        self.applicationFeePercent = try values.decodeIfPresent(Double.self, forKey: "application_fee_percent")
        self.automaticTax = try values.decode(QuotesResourceAutomaticTax.self, forKey: "automatic_tax")
        self.collectionMethod = try values.decode(CollectionMethod.self, forKey: "collection_method")
        self.computed = try values.decode(QuotesResourceComputed.self, forKey: "computed")
        self.created = try values.decode(Int.self, forKey: "created")
        self.currency = try values.decodeIfPresent(String.self, forKey: "currency")
        self.customer = try values.decodeIfPresent(Customer.self, forKey: "customer")
        self.defaultTaxRates = try values.decodeIfPresent([DefaultTaxRate].self, forKey: "default_tax_rates")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.discounts = try values.decode([Discount].self, forKey: "discounts")
        self.expiresAt = try values.decode(Int.self, forKey: "expires_at")
        self.footer = try values.decodeIfPresent(String.self, forKey: "footer")
        self.fromQuote = try values.decodeIfPresent(QuotesResourceFromQuote.self, forKey: "from_quote")
        self.header = try values.decodeIfPresent(String.self, forKey: "header")
        self.id = try values.decode(String.self, forKey: "id")
        self.invoice = try values.decodeIfPresent(Invoice.self, forKey: "invoice")
        self.invoiceSettings = try values.decodeIfPresent(InvoiceSettingQuoteSetting.self, forKey: "invoice_settings")
        self.lineItems = try values.decodeIfPresent(LineItems.self, forKey: "line_items")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.metadata = try values.decode([String: String].self, forKey: "metadata")
        self.number = try values.decodeIfPresent(String.self, forKey: "number")
        self.object = try values.decode(Object.self, forKey: "object")
        self.onBehalfOf = try values.decodeIfPresent(OnBehalfOf.self, forKey: "on_behalf_of")
        self.status = try values.decode(Status.self, forKey: "status")
        self.statusTransitions = try values.decode(QuotesResourceStatusTransitions.self, forKey: "status_transitions")
        self.subscription = try values.decodeIfPresent(Subscription.self, forKey: "subscription")
        self.subscriptionData = try values.decode(QuotesResourceSubscriptionData.self, forKey: "subscription_data")
        self.subscriptionSchedule = try values.decodeIfPresent(SubscriptionSchedule.self, forKey: "subscription_schedule")
        self.testClock = try values.decodeIfPresent(TestClock.self, forKey: "test_clock")
        self.totalDetails = try values.decode(QuotesResourceTotalDetails.self, forKey: "total_details")
        self.transferData = try values.decodeIfPresent(QuotesResourceTransferData.self, forKey: "transfer_data")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(amountSubtotal, forKey: "amount_subtotal")
        try values.encode(amountTotal, forKey: "amount_total")
        try values.encodeIfPresent(application, forKey: "application")
        try values.encodeIfPresent(applicationFeeAmount, forKey: "application_fee_amount")
        try values.encodeIfPresent(applicationFeePercent, forKey: "application_fee_percent")
        try values.encode(automaticTax, forKey: "automatic_tax")
        try values.encode(collectionMethod, forKey: "collection_method")
        try values.encode(computed, forKey: "computed")
        try values.encode(created, forKey: "created")
        try values.encodeIfPresent(currency, forKey: "currency")
        try values.encodeIfPresent(customer, forKey: "customer")
        try values.encodeIfPresent(defaultTaxRates, forKey: "default_tax_rates")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(discounts, forKey: "discounts")
        try values.encode(expiresAt, forKey: "expires_at")
        try values.encodeIfPresent(footer, forKey: "footer")
        try values.encodeIfPresent(fromQuote, forKey: "from_quote")
        try values.encodeIfPresent(header, forKey: "header")
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(invoice, forKey: "invoice")
        try values.encodeIfPresent(invoiceSettings, forKey: "invoice_settings")
        try values.encodeIfPresent(lineItems, forKey: "line_items")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encode(metadata, forKey: "metadata")
        try values.encodeIfPresent(number, forKey: "number")
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(onBehalfOf, forKey: "on_behalf_of")
        try values.encode(status, forKey: "status")
        try values.encode(statusTransitions, forKey: "status_transitions")
        try values.encodeIfPresent(subscription, forKey: "subscription")
        try values.encode(subscriptionData, forKey: "subscription_data")
        try values.encodeIfPresent(subscriptionSchedule, forKey: "subscription_schedule")
        try values.encodeIfPresent(testClock, forKey: "test_clock")
        try values.encode(totalDetails, forKey: "total_details")
        try values.encodeIfPresent(transferData, forKey: "transfer_data")
    }
}
