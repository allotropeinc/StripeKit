// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct IssuingDisputeCanceledEvidence: Codable {
    /// (ID of a [file upload](https://stripe.com/docs/guides/file-upload)) Additional documentation supporting the dispute.
    public var additionalDocumentation: AdditionalDocumentation?
    /// Date when order was canceled.
    public var canceledAt: Int?
    /// Whether the cardholder was provided with a cancellation policy.
    public var isCancellationPolicyProvided: Bool?
    /// Reason for canceling the order.
    public var cancellationReason: String?
    /// Date when the cardholder expected to receive the product.
    public var expectedAt: Int?
    /// Explanation of why the cardholder is disputing this transaction.
    public var explanation: String?
    /// Description of the merchandise or service that was purchased.
    public var productDescription: String?
    /// Whether the product was a merchandise or service.
    public var productType: ProductType?
    /// Result of cardholder's attempt to return the product.
    public var returnStatus: ReturnStatus?
    /// Date when the product was returned or attempted to be returned.
    public var returnedAt: Int?

    /// (ID of a [file upload](https://stripe.com/docs/guides/file-upload)) Additional documentation supporting the dispute.
    public struct AdditionalDocumentation: Codable {
        public var string: String?
        /// This is an object representing a file hosted on Stripe's servers. The
        /// file may have been uploaded by yourself using the [create file](https://stripe.com/docs/api#create_file)
        /// request (for example, when uploading dispute evidence) or it may have
        /// been created by Stripe (for example, the results of a [Sigma scheduled
        /// query](#scheduled_queries)).
        /// 
        /// Related guide: [File Upload Guide](https://stripe.com/docs/file-upload).
        public var file: File?

        public init(string: String? = nil, file: File? = nil) {
            self.string = string
            self.file = file
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.file = try? container.decode(File.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = file { try container.encode(value) }
        }
    }

    /// Whether the product was a merchandise or service.
    public enum ProductType: String, Codable, CaseIterable {
        case merchandise
        case service
    }

    /// Result of cardholder's attempt to return the product.
    public enum ReturnStatus: String, Codable, CaseIterable {
        case merchantRejected = "merchant_rejected"
        case successful
    }

    public init(additionalDocumentation: AdditionalDocumentation? = nil, canceledAt: Int? = nil, isCancellationPolicyProvided: Bool? = nil, cancellationReason: String? = nil, expectedAt: Int? = nil, explanation: String? = nil, productDescription: String? = nil, productType: ProductType? = nil, returnStatus: ReturnStatus? = nil, returnedAt: Int? = nil) {
        self.additionalDocumentation = additionalDocumentation
        self.canceledAt = canceledAt
        self.isCancellationPolicyProvided = isCancellationPolicyProvided
        self.cancellationReason = cancellationReason
        self.expectedAt = expectedAt
        self.explanation = explanation
        self.productDescription = productDescription
        self.productType = productType
        self.returnStatus = returnStatus
        self.returnedAt = returnedAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.additionalDocumentation = try values.decodeIfPresent(AdditionalDocumentation.self, forKey: "additional_documentation")
        self.canceledAt = try values.decodeIfPresent(Int.self, forKey: "canceled_at")
        self.isCancellationPolicyProvided = try values.decodeIfPresent(Bool.self, forKey: "cancellation_policy_provided")
        self.cancellationReason = try values.decodeIfPresent(String.self, forKey: "cancellation_reason")
        self.expectedAt = try values.decodeIfPresent(Int.self, forKey: "expected_at")
        self.explanation = try values.decodeIfPresent(String.self, forKey: "explanation")
        self.productDescription = try values.decodeIfPresent(String.self, forKey: "product_description")
        self.productType = try values.decodeIfPresent(ProductType.self, forKey: "product_type")
        self.returnStatus = try values.decodeIfPresent(ReturnStatus.self, forKey: "return_status")
        self.returnedAt = try values.decodeIfPresent(Int.self, forKey: "returned_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(additionalDocumentation, forKey: "additional_documentation")
        try values.encodeIfPresent(canceledAt, forKey: "canceled_at")
        try values.encodeIfPresent(isCancellationPolicyProvided, forKey: "cancellation_policy_provided")
        try values.encodeIfPresent(cancellationReason, forKey: "cancellation_reason")
        try values.encodeIfPresent(expectedAt, forKey: "expected_at")
        try values.encodeIfPresent(explanation, forKey: "explanation")
        try values.encodeIfPresent(productDescription, forKey: "product_description")
        try values.encodeIfPresent(productType, forKey: "product_type")
        try values.encodeIfPresent(returnStatus, forKey: "return_status")
        try values.encodeIfPresent(returnedAt, forKey: "returned_at")
    }
}
