// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// OrdersV2ResourceOrder
///
/// An Order describes a purchase being made by a customer, including the
/// products & quantities being purchased, the order status, the payment information,
/// and the billing/shipping details.
/// 
/// Related guide: [Orders overview](https://stripe.com/docs/orders)
public struct Order: Codable {
    /// Order cost before any discounts or taxes are applied. A positive integer representing the subtotal of the order in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency).
    public var amountSubtotal: Int
    /// Total order cost after discounts and taxes are applied. A positive integer representing the cost of the order in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). To submit an order, the total must be either 0 or at least $0.50 USD or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts).
    public var amountTotal: Int
    /// ID of the Connect application that created the Order, if any.
    public var application: Application?
    /// OrdersV2ResourceAutomaticTax
    public var automaticTax: OrdersV2ResourceAutomaticTax?
    /// Customer billing details associated with the order.
    public var billingDetails: OrdersV2ResourceBillingDetails?
    /// The client secret of this Order. Used for client-side retrieval using a publishable key. 
    /// 
    /// The client secret can be used to complete a payment for an Order from your frontend. It should not be stored, logged, embedded in URLs, or exposed to anyone other than the customer. Make sure that you have TLS enabled on any page that includes the client secret. 
    /// 
    /// Refer to our docs for [creating and processing an order](https://stripe.com/docs/orders-beta/create-and-process) to learn about how client_secret should be handled.
    public var clientSecret: String?
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public var created: Int
    /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    public var currency: String
    /// The customer which this orders belongs to.
    public var customer: Customer?
    /// An arbitrary string attached to the object. Often useful for displaying to users.
    public var description: String?
    /// The discounts applied to the order. Use `expand[]=discounts` to expand each discount.
    public var discounts: [Discount]?
    /// Unique identifier for the object.
    public var id: String
    /// A recent IP address of the purchaser used for tax reporting and tax location inference.
    public var ipAddress: String?
    /// OrdersV2ResourceLineItemList
    ///
    /// A list of line items the customer is ordering. Each line item includes information about the product, the quantity, and the resulting cost. There is a maximum of 100 line items.
    public var lineItems: LineItems?
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    public var metadata: [String: String]?
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// OrdersV2ResourcePayment
    public var payment: OrdersV2ResourcePayment
    /// The details of the customer cost of shipping, including the customer chosen ShippingRate.
    public var shippingCost: OrdersV2ResourceShippingCost?
    /// Customer shipping information associated with the order.
    public var shippingDetails: OrdersV2ResourceShippingDetails?
    /// The overall status of the order.
    public var status: Status
    /// OrdersV2ResourceTaxDetails
    public var taxDetails: OrdersV2ResourceTaxDetails?
    /// OrdersV2ResourceTotalDetails
    public var totalDetails: OrdersV2ResourceTotalDetails

    /// ID of the Connect application that created the Order, if any.
    public final class Application: Codable {
        public let string: String?
        public let application: StripeKit.Application?

        public init(string: String? = nil, application: StripeKit.Application? = nil) {
            self.string = string
            self.application = application
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.application = try? container.decode(StripeKit.Application.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = application { try container.encode(value) }
        }
    }

    /// The customer which this orders belongs to.
    public final class Customer: Codable {
        public let string: String?
        /// This object represents a customer of your business. It lets you create recurring charges and track payments that belong to the same customer.
        /// 
        /// Related guide: [Save a card during payment](https://stripe.com/docs/payments/save-during-payment).
        public let customer: StripeKit.Customer?
        public let deletedCustomer: DeletedCustomer?

        public init(string: String? = nil, customer: StripeKit.Customer? = nil, deletedCustomer: DeletedCustomer? = nil) {
            self.string = string
            self.customer = customer
            self.deletedCustomer = deletedCustomer
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.customer = try? container.decode(StripeKit.Customer.self)
            self.deletedCustomer = try? container.decode(DeletedCustomer.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = customer { try container.encode(value) }
            if let value = deletedCustomer { try container.encode(value) }
        }
    }

    public final class Discount: Codable {
        public let string: String?
        /// A discount represents the actual application of a [coupon](https://stripe.com/docs/api#coupons) or [promotion code](https://stripe.com/docs/api#promotion_codes).
        /// It contains information about when the discount began, when it will end, and what it is applied to.
        /// 
        /// Related guide: [Applying Discounts to Subscriptions](https://stripe.com/docs/billing/subscriptions/discounts).
        public let discount: StripeKit.Discount?

        public init(string: String? = nil, discount: StripeKit.Discount? = nil) {
            self.string = string
            self.discount = discount
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.discount = try? container.decode(StripeKit.Discount.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = discount { try container.encode(value) }
        }
    }

    /// OrdersV2ResourceLineItemList
    ///
    /// A list of line items the customer is ordering. Each line item includes information about the product, the quantity, and the resulting cost. There is a maximum of 100 line items.
    public struct LineItems: Codable {
        /// Details about each object.
        public var data: [Item]
        /// True if this list has another page of items after this one that can be fetched.
        public var hasMore: Bool
        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public var object: Object
        /// The URL where this list can be accessed.
        public var url: String

        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public enum Object: String, Codable, CaseIterable {
            case list
        }

        public init(data: [Item], hasMore: Bool, object: Object, url: String) {
            self.data = data
            self.hasMore = hasMore
            self.object = object
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.data = try values.decode([Item].self, forKey: "data")
            self.hasMore = try values.decode(Bool.self, forKey: "has_more")
            self.object = try values.decode(Object.self, forKey: "object")
            self.url = try values.decode(String.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(data, forKey: "data")
            try values.encode(hasMore, forKey: "has_more")
            try values.encode(object, forKey: "object")
            try values.encode(url, forKey: "url")
        }
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case order
    }

    /// The overall status of the order.
    public enum Status: String, Codable, CaseIterable {
        case canceled
        case complete
        case `open`
        case processing
        case submitted
    }

    public init(amountSubtotal: Int, amountTotal: Int, application: Application? = nil, automaticTax: OrdersV2ResourceAutomaticTax? = nil, billingDetails: OrdersV2ResourceBillingDetails? = nil, clientSecret: String? = nil, created: Int, currency: String, customer: Customer? = nil, description: String? = nil, discounts: [Discount]? = nil, id: String, ipAddress: String? = nil, lineItems: LineItems? = nil, isLivemode: Bool, metadata: [String: String]? = nil, object: Object, payment: OrdersV2ResourcePayment, shippingCost: OrdersV2ResourceShippingCost? = nil, shippingDetails: OrdersV2ResourceShippingDetails? = nil, status: Status, taxDetails: OrdersV2ResourceTaxDetails? = nil, totalDetails: OrdersV2ResourceTotalDetails) {
        self.amountSubtotal = amountSubtotal
        self.amountTotal = amountTotal
        self.application = application
        self.automaticTax = automaticTax
        self.billingDetails = billingDetails
        self.clientSecret = clientSecret
        self.created = created
        self.currency = currency
        self.customer = customer
        self.description = description
        self.discounts = discounts
        self.id = id
        self.ipAddress = ipAddress
        self.lineItems = lineItems
        self.isLivemode = isLivemode
        self.metadata = metadata
        self.object = object
        self.payment = payment
        self.shippingCost = shippingCost
        self.shippingDetails = shippingDetails
        self.status = status
        self.taxDetails = taxDetails
        self.totalDetails = totalDetails
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.amountSubtotal = try values.decode(Int.self, forKey: "amount_subtotal")
        self.amountTotal = try values.decode(Int.self, forKey: "amount_total")
        self.application = try values.decodeIfPresent(Application.self, forKey: "application")
        self.automaticTax = try values.decodeIfPresent(OrdersV2ResourceAutomaticTax.self, forKey: "automatic_tax")
        self.billingDetails = try values.decodeIfPresent(OrdersV2ResourceBillingDetails.self, forKey: "billing_details")
        self.clientSecret = try values.decodeIfPresent(String.self, forKey: "client_secret")
        self.created = try values.decode(Int.self, forKey: "created")
        self.currency = try values.decode(String.self, forKey: "currency")
        self.customer = try values.decodeIfPresent(Customer.self, forKey: "customer")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.discounts = try values.decodeIfPresent([Discount].self, forKey: "discounts")
        self.id = try values.decode(String.self, forKey: "id")
        self.ipAddress = try values.decodeIfPresent(String.self, forKey: "ip_address")
        self.lineItems = try values.decodeIfPresent(LineItems.self, forKey: "line_items")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.metadata = try values.decodeIfPresent([String: String].self, forKey: "metadata")
        self.object = try values.decode(Object.self, forKey: "object")
        self.payment = try values.decode(OrdersV2ResourcePayment.self, forKey: "payment")
        self.shippingCost = try values.decodeIfPresent(OrdersV2ResourceShippingCost.self, forKey: "shipping_cost")
        self.shippingDetails = try values.decodeIfPresent(OrdersV2ResourceShippingDetails.self, forKey: "shipping_details")
        self.status = try values.decode(Status.self, forKey: "status")
        self.taxDetails = try values.decodeIfPresent(OrdersV2ResourceTaxDetails.self, forKey: "tax_details")
        self.totalDetails = try values.decode(OrdersV2ResourceTotalDetails.self, forKey: "total_details")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(amountSubtotal, forKey: "amount_subtotal")
        try values.encode(amountTotal, forKey: "amount_total")
        try values.encodeIfPresent(application, forKey: "application")
        try values.encodeIfPresent(automaticTax, forKey: "automatic_tax")
        try values.encodeIfPresent(billingDetails, forKey: "billing_details")
        try values.encodeIfPresent(clientSecret, forKey: "client_secret")
        try values.encode(created, forKey: "created")
        try values.encode(currency, forKey: "currency")
        try values.encodeIfPresent(customer, forKey: "customer")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(discounts, forKey: "discounts")
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(ipAddress, forKey: "ip_address")
        try values.encodeIfPresent(lineItems, forKey: "line_items")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encode(object, forKey: "object")
        try values.encode(payment, forKey: "payment")
        try values.encodeIfPresent(shippingCost, forKey: "shipping_cost")
        try values.encodeIfPresent(shippingDetails, forKey: "shipping_details")
        try values.encode(status, forKey: "status")
        try values.encodeIfPresent(taxDetails, forKey: "tax_details")
        try values.encode(totalDetails, forKey: "total_details")
    }
}
