// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Tokenization is the process Stripe uses to collect sensitive card or bank
/// account details, or personally identifiable information (PII), directly from
/// your customers in a secure manner. A token representing this information is
/// returned to your server to use. You should use our
/// [recommended payments integrations](https://stripe.com/docs/payments) to perform this process
/// client-side. This ensures that no sensitive card data touches your server,
/// and allows your integration to operate in a PCI-compliant way.
/// 
/// If you cannot use client-side tokenization, you can also create tokens using
/// the API with either your publishable or secret API key. Keep in mind that if
/// your integration uses this method, you are responsible for any PCI compliance
/// that may be required, and you must keep your secret API key safe. Unlike with
/// client-side tokenization, your customer's information is not sent directly to
/// Stripe, so we cannot determine how it is handled or stored.
/// 
/// Tokens cannot be stored or used more than once. To store card or bank account
/// information for later use, you can create [Customer](https://stripe.com/docs/api#customers)
/// objects or [Custom accounts](https://stripe.com/docs/api#external_accounts). Note that
/// [Radar](https://stripe.com/docs/radar), our integrated solution for automatic fraud protection,
/// performs best with integrations that use client-side tokenization.
/// 
/// Related guide: [Accept a payment](https://stripe.com/docs/payments/accept-a-payment-charges#web-create-token)
public struct Token: Codable {
    /// These bank accounts are payment methods on `Customer` objects.
    /// 
    /// On the other hand [External Accounts](https://stripe.com/docs/api#external_accounts) are transfer
    /// destinations on `Account` objects for [Custom accounts](https://stripe.com/docs/connect/custom-accounts).
    /// They can be bank accounts or debit cards as well, and are documented in the links above.
    /// 
    /// Related guide: [Bank Debits and Transfers](https://stripe.com/docs/payments/bank-debits-transfers).
    public var bankAccount: BankAccount?
    /// You can store multiple cards on a customer in order to charge the customer
    /// later. You can also store multiple debit cards on a recipient in order to
    /// transfer to those cards later.
    /// 
    /// Related guide: [Card Payments with Sources](https://stripe.com/docs/sources/cards).
    public var card: Card?
    /// IP address of the client that generated the token.
    public var clientIp: String?
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public var created: Int
    /// Unique identifier for the object.
    public var id: String
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// Type of the token: `account`, `bank_account`, `card`, or `pii`.
    public var type: String
    /// Whether this token has already been used (tokens can be used only once).
    public var isUsed: Bool

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case token
    }

    public init(bankAccount: BankAccount? = nil, card: Card? = nil, clientIp: String? = nil, created: Int, id: String, isLivemode: Bool, object: Object, type: String, isUsed: Bool) {
        self.bankAccount = bankAccount
        self.card = card
        self.clientIp = clientIp
        self.created = created
        self.id = id
        self.isLivemode = isLivemode
        self.object = object
        self.type = type
        self.isUsed = isUsed
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.bankAccount = try values.decodeIfPresent(BankAccount.self, forKey: "bank_account")
        self.card = try values.decodeIfPresent(Card.self, forKey: "card")
        self.clientIp = try values.decodeIfPresent(String.self, forKey: "client_ip")
        self.created = try values.decode(Int.self, forKey: "created")
        self.id = try values.decode(String.self, forKey: "id")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.object = try values.decode(Object.self, forKey: "object")
        self.type = try values.decode(String.self, forKey: "type")
        self.isUsed = try values.decode(Bool.self, forKey: "used")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(bankAccount, forKey: "bank_account")
        try values.encodeIfPresent(card, forKey: "card")
        try values.encodeIfPresent(clientIp, forKey: "client_ip")
        try values.encode(created, forKey: "created")
        try values.encode(id, forKey: "id")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encode(object, forKey: "object")
        try values.encode(type, forKey: "type")
        try values.encode(isUsed, forKey: "used")
    }
}
