// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Each customer has a [`balance`](https://stripe.com/docs/api/customers/object#customer_object-balance) value,
/// which denotes a debit or credit that's automatically applied to their next invoice upon finalization.
/// You may modify the value directly by using the [update customer API](https://stripe.com/docs/api/customers/update),
/// or by creating a Customer Balance Transaction, which increments or decrements the customer's `balance` by the specified `amount`.
/// 
/// Related guide: [Customer Balance](https://stripe.com/docs/billing/customer/balance) to learn more.
public struct CustomerBalanceTransaction: Codable {
    /// The amount of the transaction. A negative value is a credit for the customer's balance, and a positive value is a debit to the customer's `balance`.
    public var amount: Int
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public var created: Int
    /// The ID of the credit note (if any) related to the transaction.
    public var creditNote: CreditNote?
    /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    public var currency: String
    /// The ID of the customer the transaction belongs to.
    public var customer: Customer
    /// An arbitrary string attached to the object. Often useful for displaying to users.
    public var description: String?
    /// The customer's `balance` after the transaction was applied. A negative value decreases the amount due on the customer's next invoice. A positive value increases the amount due on the customer's next invoice.
    public var endingBalance: Int
    /// Unique identifier for the object.
    public var id: String
    /// The ID of the invoice (if any) related to the transaction.
    public var invoice: Invoice?
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    public var metadata: [String: String]?
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// Transaction type: `adjustment`, `applied_to_invoice`, `credit_note`, `initial`, `invoice_too_large`, `invoice_too_small`, `unspent_receiver_credit`, or `unapplied_from_invoice`. See the [Customer Balance page](https://stripe.com/docs/billing/customer/balance#types) to learn more about transaction types.
    public var type: `Type`

    /// The ID of the credit note (if any) related to the transaction.
    public final class CreditNote: Codable {
        public let string: String?
        /// Issue a credit note to adjust an invoice's amount after the invoice is finalized.
        /// 
        /// Related guide: [Credit Notes](https://stripe.com/docs/billing/invoices/credit-notes).
        public let creditNote: StripeKit.CreditNote?

        public init(string: String? = nil, creditNote: StripeKit.CreditNote? = nil) {
            self.string = string
            self.creditNote = creditNote
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.creditNote = try? container.decode(StripeKit.CreditNote.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = creditNote { try container.encode(value) }
        }
    }

    /// The ID of the customer the transaction belongs to.
    public final class Customer: Codable {
        public let string: String?
        /// This object represents a customer of your business. It lets you create recurring charges and track payments that belong to the same customer.
        /// 
        /// Related guide: [Save a card during payment](https://stripe.com/docs/payments/save-during-payment).
        public let customer: StripeKit.Customer?

        public init(string: String? = nil, customer: StripeKit.Customer? = nil) {
            self.string = string
            self.customer = customer
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.customer = try? container.decode(StripeKit.Customer.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = customer { try container.encode(value) }
        }
    }

    /// The ID of the invoice (if any) related to the transaction.
    public final class Invoice: Codable {
        public let string: String?
        /// Invoices are statements of amounts owed by a customer, and are either
        /// generated one-off, or generated periodically from a subscription.
        /// 
        /// They contain [invoice items](https://stripe.com/docs/api#invoiceitems), and proration adjustments
        /// that may be caused by subscription upgrades/downgrades (if necessary).
        /// 
        /// If your invoice is configured to be billed through automatic charges,
        /// Stripe automatically finalizes your invoice and attempts payment. Note
        /// that finalizing the invoice,
        /// [when automatic](https://stripe.com/docs/billing/invoices/workflow/#auto_advance), does
        /// not happen immediately as the invoice is created. Stripe waits
        /// until one hour after the last webhook was successfully sent (or the last
        /// webhook timed out after failing). If you (and the platforms you may have
        /// connected to) have no webhooks configured, Stripe waits one hour after
        /// creation to finalize the invoice.
        /// 
        /// If your invoice is configured to be billed by sending an email, then based on your
        /// [email settings](https://dashboard.stripe.com/account/billing/automatic),
        /// Stripe will email the invoice to your customer and await payment. These
        /// emails can contain a link to a hosted page to pay the invoice.
        /// 
        /// Stripe applies any customer credit on the account before determining the
        /// amount due for the invoice (i.e., the amount that will be actually
        /// charged). If the amount due for the invoice is less than Stripe's [minimum allowed charge
        /// per currency](/docs/currencies#minimum-and-maximum-charge-amounts), the
        /// invoice is automatically marked paid, and we add the amount due to the
        /// customer's credit balance which is applied to the next invoice.
        /// 
        /// More details on the customer's credit balance are
        /// [here](https://stripe.com/docs/billing/customer/balance).
        /// 
        /// Related guide: [Send Invoices to Customers](https://stripe.com/docs/billing/invoices/sending).
        public let invoice: StripeKit.Invoice?

        public init(string: String? = nil, invoice: StripeKit.Invoice? = nil) {
            self.string = string
            self.invoice = invoice
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.invoice = try? container.decode(StripeKit.Invoice.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = invoice { try container.encode(value) }
        }
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case customerBalanceTransaction = "customer_balance_transaction"
    }

    /// Transaction type: `adjustment`, `applied_to_invoice`, `credit_note`, `initial`, `invoice_too_large`, `invoice_too_small`, `unspent_receiver_credit`, or `unapplied_from_invoice`. See the [Customer Balance page](https://stripe.com/docs/billing/customer/balance#types) to learn more about transaction types.
    public enum `Type`: String, Codable, CaseIterable {
        case adjustment
        case appliedToInvoice = "applied_to_invoice"
        case creditNote = "credit_note"
        case initial
        case invoiceTooLarge = "invoice_too_large"
        case invoiceTooSmall = "invoice_too_small"
        case migration
        case unappliedFromInvoice = "unapplied_from_invoice"
        case unspentReceiverCredit = "unspent_receiver_credit"
    }

    public init(amount: Int, created: Int, creditNote: CreditNote? = nil, currency: String, customer: Customer, description: String? = nil, endingBalance: Int, id: String, invoice: Invoice? = nil, isLivemode: Bool, metadata: [String: String]? = nil, object: Object, type: `Type`) {
        self.amount = amount
        self.created = created
        self.creditNote = creditNote
        self.currency = currency
        self.customer = customer
        self.description = description
        self.endingBalance = endingBalance
        self.id = id
        self.invoice = invoice
        self.isLivemode = isLivemode
        self.metadata = metadata
        self.object = object
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.amount = try values.decode(Int.self, forKey: "amount")
        self.created = try values.decode(Int.self, forKey: "created")
        self.creditNote = try values.decodeIfPresent(CreditNote.self, forKey: "credit_note")
        self.currency = try values.decode(String.self, forKey: "currency")
        self.customer = try values.decode(Customer.self, forKey: "customer")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.endingBalance = try values.decode(Int.self, forKey: "ending_balance")
        self.id = try values.decode(String.self, forKey: "id")
        self.invoice = try values.decodeIfPresent(Invoice.self, forKey: "invoice")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.metadata = try values.decodeIfPresent([String: String].self, forKey: "metadata")
        self.object = try values.decode(Object.self, forKey: "object")
        self.type = try values.decode(`Type`.self, forKey: "type")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(amount, forKey: "amount")
        try values.encode(created, forKey: "created")
        try values.encodeIfPresent(creditNote, forKey: "credit_note")
        try values.encode(currency, forKey: "currency")
        try values.encode(customer, forKey: "customer")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(endingBalance, forKey: "ending_balance")
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(invoice, forKey: "invoice")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encode(object, forKey: "object")
        try values.encode(type, forKey: "type")
    }
}
