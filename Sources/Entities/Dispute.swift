// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// A dispute occurs when a customer questions your charge with their card issuer.
/// When this happens, you're given the opportunity to respond to the dispute with
/// evidence that shows that the charge is legitimate. You can find more
/// information about the dispute process in our [Disputes and
/// Fraud](/docs/disputes) documentation.
/// 
/// Related guide: [Disputes and Fraud](https://stripe.com/docs/disputes).
public struct Dispute: Codable {
    /// Disputed amount. Usually the amount of the charge, but can differ (usually because of currency fluctuation or because only part of the order is disputed).
    public var amount: Int
    /// List of zero, one, or two balance transactions that show funds withdrawn and reinstated to your Stripe account as a result of this dispute.
    public var balanceTransactions: [BalanceTransaction]
    /// ID of the charge that was disputed.
    public var charge: Charge
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public var created: Int
    /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    public var currency: String
    /// DisputeEvidence
    public var evidence: DisputeEvidence
    /// DisputeEvidenceDetails
    public var evidenceDetails: DisputeEvidenceDetails
    /// Unique identifier for the object.
    public var id: String
    /// If true, it is still possible to refund the disputed payment. Once the payment has been fully refunded, no further funds will be withdrawn from your Stripe account as a result of this dispute.
    public var isChargeRefundable: Bool
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    public var metadata: [String: String]
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// ID of the PaymentIntent that was disputed.
    public var paymentIntent: PaymentIntent?
    /// Reason given by cardholder for dispute. Possible values are `bank_cannot_process`, `check_returned`, `credit_not_processed`, `customer_initiated`, `debit_not_authorized`, `duplicate`, `fraudulent`, `general`, `incorrect_account_details`, `insufficient_funds`, `product_not_received`, `product_unacceptable`, `subscription_canceled`, or `unrecognized`. Read more about [dispute reasons](https://stripe.com/docs/disputes/categories).
    public var reason: String
    /// Current status of dispute. Possible values are `warning_needs_response`, `warning_under_review`, `warning_closed`, `needs_response`, `under_review`, `charge_refunded`, `won`, or `lost`.
    public var status: Status

    /// ID of the charge that was disputed.
    public final class Charge: Codable {
        public let string: String?
        /// To charge a credit or a debit card, you create a `Charge` object. You can
        /// retrieve and refund individual charges as well as list all charges. Charges
        /// are identified by a unique, random ID.
        /// 
        /// Related guide: [Accept a payment with the Charges API](https://stripe.com/docs/payments/accept-a-payment-charges).
        public let charge: StripeKit.Charge?

        public init(string: String? = nil, charge: StripeKit.Charge? = nil) {
            self.string = string
            self.charge = charge
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.charge = try? container.decode(StripeKit.Charge.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = charge { try container.encode(value) }
        }
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case dispute
    }

    /// ID of the PaymentIntent that was disputed.
    public final class PaymentIntent: Codable {
        public let string: String?
        /// A PaymentIntent guides you through the process of collecting a payment from your customer.
        /// We recommend that you create exactly one PaymentIntent for each order or
        /// customer session in your system. You can reference the PaymentIntent later to
        /// see the history of payment attempts for a particular session.
        /// 
        /// A PaymentIntent transitions through
        /// [multiple statuses](https://stripe.com/docs/payments/intents#intent-statuses)
        /// throughout its lifetime as it interfaces with Stripe.js to perform
        /// authentication flows and ultimately creates at most one successful charge.
        /// 
        /// Related guide: [Payment Intents API](https://stripe.com/docs/payments/payment-intents).
        public let paymentIntent: StripeKit.PaymentIntent?

        public init(string: String? = nil, paymentIntent: StripeKit.PaymentIntent? = nil) {
            self.string = string
            self.paymentIntent = paymentIntent
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.paymentIntent = try? container.decode(StripeKit.PaymentIntent.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = paymentIntent { try container.encode(value) }
        }
    }

    /// Current status of dispute. Possible values are `warning_needs_response`, `warning_under_review`, `warning_closed`, `needs_response`, `under_review`, `charge_refunded`, `won`, or `lost`.
    public enum Status: String, Codable, CaseIterable {
        case chargeRefunded = "charge_refunded"
        case lost
        case needsResponse = "needs_response"
        case underReview = "under_review"
        case warningClosed = "warning_closed"
        case warningNeedsResponse = "warning_needs_response"
        case warningUnderReview = "warning_under_review"
        case won
    }

    public init(amount: Int, balanceTransactions: [BalanceTransaction], charge: Charge, created: Int, currency: String, evidence: DisputeEvidence, evidenceDetails: DisputeEvidenceDetails, id: String, isChargeRefundable: Bool, isLivemode: Bool, metadata: [String: String], object: Object, paymentIntent: PaymentIntent? = nil, reason: String, status: Status) {
        self.amount = amount
        self.balanceTransactions = balanceTransactions
        self.charge = charge
        self.created = created
        self.currency = currency
        self.evidence = evidence
        self.evidenceDetails = evidenceDetails
        self.id = id
        self.isChargeRefundable = isChargeRefundable
        self.isLivemode = isLivemode
        self.metadata = metadata
        self.object = object
        self.paymentIntent = paymentIntent
        self.reason = reason
        self.status = status
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.amount = try values.decode(Int.self, forKey: "amount")
        self.balanceTransactions = try values.decode([BalanceTransaction].self, forKey: "balance_transactions")
        self.charge = try values.decode(Charge.self, forKey: "charge")
        self.created = try values.decode(Int.self, forKey: "created")
        self.currency = try values.decode(String.self, forKey: "currency")
        self.evidence = try values.decode(DisputeEvidence.self, forKey: "evidence")
        self.evidenceDetails = try values.decode(DisputeEvidenceDetails.self, forKey: "evidence_details")
        self.id = try values.decode(String.self, forKey: "id")
        self.isChargeRefundable = try values.decode(Bool.self, forKey: "is_charge_refundable")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.metadata = try values.decode([String: String].self, forKey: "metadata")
        self.object = try values.decode(Object.self, forKey: "object")
        self.paymentIntent = try values.decodeIfPresent(PaymentIntent.self, forKey: "payment_intent")
        self.reason = try values.decode(String.self, forKey: "reason")
        self.status = try values.decode(Status.self, forKey: "status")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(amount, forKey: "amount")
        try values.encode(balanceTransactions, forKey: "balance_transactions")
        try values.encode(charge, forKey: "charge")
        try values.encode(created, forKey: "created")
        try values.encode(currency, forKey: "currency")
        try values.encode(evidence, forKey: "evidence")
        try values.encode(evidenceDetails, forKey: "evidence_details")
        try values.encode(id, forKey: "id")
        try values.encode(isChargeRefundable, forKey: "is_charge_refundable")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encode(metadata, forKey: "metadata")
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(paymentIntent, forKey: "payment_intent")
        try values.encode(reason, forKey: "reason")
        try values.encode(status, forKey: "status")
    }
}
