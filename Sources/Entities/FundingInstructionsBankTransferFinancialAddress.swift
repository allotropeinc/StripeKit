// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// FinancialAddresses contain identifying information that resolves to a FinancialAccount.
public struct FundingInstructionsBankTransferFinancialAddress: Codable {
    /// FundingInstructionsBankTransferIbanRecord
    ///
    /// Iban Records contain E.U. bank account details per the SEPA format.
    public var iban: FundingInstructionsBankTransferIbanRecord?
    /// FundingInstructionsBankTransferSortCodeRecord
    ///
    /// Sort Code Records contain U.K. bank account details per the sort code format.
    public var sortCode: FundingInstructionsBankTransferSortCodeRecord?
    /// FundingInstructionsBankTransferSpeiRecord
    ///
    /// SPEI Records contain Mexico bank account details per the SPEI format.
    public var spei: FundingInstructionsBankTransferSpeiRecord?
    /// The payment networks supported by this FinancialAddress
    public var supportedNetworks: [SupportedNetwork]?
    /// The type of financial address
    public var type: `Type`
    /// FundingInstructionsBankTransferZenginRecord
    ///
    /// Zengin Records contain Japan bank account details per the Zengin format.
    public var zengin: FundingInstructionsBankTransferZenginRecord?

    public enum SupportedNetwork: String, Codable, CaseIterable {
        case bacs
        case fps
        case sepa
        case spei
        case zengin
    }

    /// The type of financial address
    public enum `Type`: String, Codable, CaseIterable {
        case iban
        case sortCode = "sort_code"
        case spei
        case zengin
    }

    public init(iban: FundingInstructionsBankTransferIbanRecord? = nil, sortCode: FundingInstructionsBankTransferSortCodeRecord? = nil, spei: FundingInstructionsBankTransferSpeiRecord? = nil, supportedNetworks: [SupportedNetwork]? = nil, type: `Type`, zengin: FundingInstructionsBankTransferZenginRecord? = nil) {
        self.iban = iban
        self.sortCode = sortCode
        self.spei = spei
        self.supportedNetworks = supportedNetworks
        self.type = type
        self.zengin = zengin
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.iban = try values.decodeIfPresent(FundingInstructionsBankTransferIbanRecord.self, forKey: "iban")
        self.sortCode = try values.decodeIfPresent(FundingInstructionsBankTransferSortCodeRecord.self, forKey: "sort_code")
        self.spei = try values.decodeIfPresent(FundingInstructionsBankTransferSpeiRecord.self, forKey: "spei")
        self.supportedNetworks = try values.decodeIfPresent([SupportedNetwork].self, forKey: "supported_networks")
        self.type = try values.decode(`Type`.self, forKey: "type")
        self.zengin = try values.decodeIfPresent(FundingInstructionsBankTransferZenginRecord.self, forKey: "zengin")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(iban, forKey: "iban")
        try values.encodeIfPresent(sortCode, forKey: "sort_code")
        try values.encodeIfPresent(spei, forKey: "spei")
        try values.encodeIfPresent(supportedNetworks, forKey: "supported_networks")
        try values.encode(type, forKey: "type")
        try values.encodeIfPresent(zengin, forKey: "zengin")
    }
}
