// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Issue a credit note to adjust an invoice's amount after the invoice is finalized.
/// 
/// Related guide: [Credit Notes](https://stripe.com/docs/billing/invoices/credit-notes).
public struct CreditNote: Codable {
    /// The integer amount in %s representing the total amount of the credit note, including tax.
    public var amount: Int
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public var created: Int
    /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    public var currency: String
    /// ID of the customer.
    public var customer: Customer
    /// Customer balance transaction related to this credit note.
    public var customerBalanceTransaction: CustomerBalanceTransaction?
    /// The integer amount in %s representing the total amount of discount that was credited.
    public var discountAmount: Int
    /// The aggregate amounts calculated per discount for all line items.
    public var discountAmounts: [DiscountsResourceDiscountAmount]
    /// Unique identifier for the object.
    public var id: String
    /// ID of the invoice.
    public var invoice: Invoice
    /// CreditNoteLinesList
    ///
    /// Line items that make up the credit note
    public var lines: Lines
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// Customer-facing text that appears on the credit note PDF.
    public var memo: String?
    /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    public var metadata: [String: String]?
    /// A unique number that identifies this particular credit note and appears on the PDF of the credit note and its associated invoice.
    public var number: String
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// Amount that was credited outside of Stripe.
    public var outOfBandAmount: Int?
    /// The link to download the PDF of the credit note.
    public var pdf: String
    /// Reason for issuing this credit note, one of `duplicate`, `fraudulent`, `order_change`, or `product_unsatisfactory`
    public var reason: Reason?
    /// Refund related to this credit note.
    public var refund: Refund?
    /// Status of this credit note, one of `issued` or `void`. Learn more about [voiding credit notes](https://stripe.com/docs/billing/invoices/credit-notes#voiding).
    public var status: Status
    /// The integer amount in %s representing the amount of the credit note, excluding exclusive tax and invoice level discounts.
    public var subtotal: Int
    /// The integer amount in %s representing the amount of the credit note, excluding all tax and invoice level discounts.
    public var subtotalExcludingTax: Int?
    /// The aggregate amounts calculated per tax rate for all line items.
    public var taxAmounts: [CreditNoteTaxAmount]
    /// The integer amount in %s representing the total amount of the credit note, including tax and all discount.
    public var total: Int
    /// The integer amount in %s representing the total amount of the credit note, excluding tax, but including discounts.
    public var totalExcludingTax: Int?
    /// Type of this credit note, one of `pre_payment` or `post_payment`. A `pre_payment` credit note means it was issued when the invoice was open. A `post_payment` credit note means it was issued when the invoice was paid.
    public var type: `Type`
    /// The time that the credit note was voided.
    public var voidedAt: Int?

    /// ID of the customer.
    public final class Customer: Codable {
        public let string: String?
        /// This object represents a customer of your business. It lets you create recurring charges and track payments that belong to the same customer.
        /// 
        /// Related guide: [Save a card during payment](https://stripe.com/docs/payments/save-during-payment).
        public let customer: StripeKit.Customer?
        public let deletedCustomer: DeletedCustomer?

        public init(string: String? = nil, customer: StripeKit.Customer? = nil, deletedCustomer: DeletedCustomer? = nil) {
            self.string = string
            self.customer = customer
            self.deletedCustomer = deletedCustomer
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.customer = try? container.decode(StripeKit.Customer.self)
            self.deletedCustomer = try? container.decode(DeletedCustomer.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = customer { try container.encode(value) }
            if let value = deletedCustomer { try container.encode(value) }
        }
    }

    /// Customer balance transaction related to this credit note.
    public final class CustomerBalanceTransaction: Codable {
        public let string: String?
        /// Each customer has a [`balance`](https://stripe.com/docs/api/customers/object#customer_object-balance) value,
        /// which denotes a debit or credit that's automatically applied to their next invoice upon finalization.
        /// You may modify the value directly by using the [update customer API](https://stripe.com/docs/api/customers/update),
        /// or by creating a Customer Balance Transaction, which increments or decrements the customer's `balance` by the specified `amount`.
        /// 
        /// Related guide: [Customer Balance](https://stripe.com/docs/billing/customer/balance) to learn more.
        public let customerBalanceTransaction: StripeKit.CustomerBalanceTransaction?

        public init(string: String? = nil, customerBalanceTransaction: StripeKit.CustomerBalanceTransaction? = nil) {
            self.string = string
            self.customerBalanceTransaction = customerBalanceTransaction
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.customerBalanceTransaction = try? container.decode(StripeKit.CustomerBalanceTransaction.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = customerBalanceTransaction { try container.encode(value) }
        }
    }

    /// ID of the invoice.
    public final class Invoice: Codable {
        public let string: String?
        /// Invoices are statements of amounts owed by a customer, and are either
        /// generated one-off, or generated periodically from a subscription.
        /// 
        /// They contain [invoice items](https://stripe.com/docs/api#invoiceitems), and proration adjustments
        /// that may be caused by subscription upgrades/downgrades (if necessary).
        /// 
        /// If your invoice is configured to be billed through automatic charges,
        /// Stripe automatically finalizes your invoice and attempts payment. Note
        /// that finalizing the invoice,
        /// [when automatic](https://stripe.com/docs/billing/invoices/workflow/#auto_advance), does
        /// not happen immediately as the invoice is created. Stripe waits
        /// until one hour after the last webhook was successfully sent (or the last
        /// webhook timed out after failing). If you (and the platforms you may have
        /// connected to) have no webhooks configured, Stripe waits one hour after
        /// creation to finalize the invoice.
        /// 
        /// If your invoice is configured to be billed by sending an email, then based on your
        /// [email settings](https://dashboard.stripe.com/account/billing/automatic),
        /// Stripe will email the invoice to your customer and await payment. These
        /// emails can contain a link to a hosted page to pay the invoice.
        /// 
        /// Stripe applies any customer credit on the account before determining the
        /// amount due for the invoice (i.e., the amount that will be actually
        /// charged). If the amount due for the invoice is less than Stripe's [minimum allowed charge
        /// per currency](/docs/currencies#minimum-and-maximum-charge-amounts), the
        /// invoice is automatically marked paid, and we add the amount due to the
        /// customer's credit balance which is applied to the next invoice.
        /// 
        /// More details on the customer's credit balance are
        /// [here](https://stripe.com/docs/billing/customer/balance).
        /// 
        /// Related guide: [Send Invoices to Customers](https://stripe.com/docs/billing/invoices/sending).
        public let invoice: StripeKit.Invoice?

        public init(string: String? = nil, invoice: StripeKit.Invoice? = nil) {
            self.string = string
            self.invoice = invoice
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.invoice = try? container.decode(StripeKit.Invoice.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = invoice { try container.encode(value) }
        }
    }

    /// CreditNoteLinesList
    ///
    /// Line items that make up the credit note
    public struct Lines: Codable {
        /// Details about each object.
        public var data: [CreditNoteLineItem]
        /// True if this list has another page of items after this one that can be fetched.
        public var hasMore: Bool
        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public var object: Object
        /// The URL where this list can be accessed.
        public var url: String

        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public enum Object: String, Codable, CaseIterable {
            case list
        }

        public init(data: [CreditNoteLineItem], hasMore: Bool, object: Object, url: String) {
            self.data = data
            self.hasMore = hasMore
            self.object = object
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.data = try values.decode([CreditNoteLineItem].self, forKey: "data")
            self.hasMore = try values.decode(Bool.self, forKey: "has_more")
            self.object = try values.decode(Object.self, forKey: "object")
            self.url = try values.decode(String.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(data, forKey: "data")
            try values.encode(hasMore, forKey: "has_more")
            try values.encode(object, forKey: "object")
            try values.encode(url, forKey: "url")
        }
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case creditNote = "credit_note"
    }

    /// Reason for issuing this credit note, one of `duplicate`, `fraudulent`, `order_change`, or `product_unsatisfactory`
    public enum Reason: String, Codable, CaseIterable {
        case duplicate
        case fraudulent
        case orderChange = "order_change"
        case productUnsatisfactory = "product_unsatisfactory"
    }

    /// Refund related to this credit note.
    public final class Refund: Codable {
        public let string: String?
        /// `Refund` objects allow you to refund a charge that has previously been created
        /// but not yet refunded. Funds will be refunded to the credit or debit card that
        /// was originally charged.
        /// 
        /// Related guide: [Refunds](https://stripe.com/docs/refunds).
        public let refund: StripeKit.Refund?

        public init(string: String? = nil, refund: StripeKit.Refund? = nil) {
            self.string = string
            self.refund = refund
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.refund = try? container.decode(StripeKit.Refund.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = refund { try container.encode(value) }
        }
    }

    /// Status of this credit note, one of `issued` or `void`. Learn more about [voiding credit notes](https://stripe.com/docs/billing/invoices/credit-notes#voiding).
    public enum Status: String, Codable, CaseIterable {
        case issued
        case void
    }

    /// Type of this credit note, one of `pre_payment` or `post_payment`. A `pre_payment` credit note means it was issued when the invoice was open. A `post_payment` credit note means it was issued when the invoice was paid.
    public enum `Type`: String, Codable, CaseIterable {
        case postPayment = "post_payment"
        case prePayment = "pre_payment"
    }

    public init(amount: Int, created: Int, currency: String, customer: Customer, customerBalanceTransaction: CustomerBalanceTransaction? = nil, discountAmount: Int, discountAmounts: [DiscountsResourceDiscountAmount], id: String, invoice: Invoice, lines: Lines, isLivemode: Bool, memo: String? = nil, metadata: [String: String]? = nil, number: String, object: Object, outOfBandAmount: Int? = nil, pdf: String, reason: Reason? = nil, refund: Refund? = nil, status: Status, subtotal: Int, subtotalExcludingTax: Int? = nil, taxAmounts: [CreditNoteTaxAmount], total: Int, totalExcludingTax: Int? = nil, type: `Type`, voidedAt: Int? = nil) {
        self.amount = amount
        self.created = created
        self.currency = currency
        self.customer = customer
        self.customerBalanceTransaction = customerBalanceTransaction
        self.discountAmount = discountAmount
        self.discountAmounts = discountAmounts
        self.id = id
        self.invoice = invoice
        self.lines = lines
        self.isLivemode = isLivemode
        self.memo = memo
        self.metadata = metadata
        self.number = number
        self.object = object
        self.outOfBandAmount = outOfBandAmount
        self.pdf = pdf
        self.reason = reason
        self.refund = refund
        self.status = status
        self.subtotal = subtotal
        self.subtotalExcludingTax = subtotalExcludingTax
        self.taxAmounts = taxAmounts
        self.total = total
        self.totalExcludingTax = totalExcludingTax
        self.type = type
        self.voidedAt = voidedAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.amount = try values.decode(Int.self, forKey: "amount")
        self.created = try values.decode(Int.self, forKey: "created")
        self.currency = try values.decode(String.self, forKey: "currency")
        self.customer = try values.decode(Customer.self, forKey: "customer")
        self.customerBalanceTransaction = try values.decodeIfPresent(CustomerBalanceTransaction.self, forKey: "customer_balance_transaction")
        self.discountAmount = try values.decode(Int.self, forKey: "discount_amount")
        self.discountAmounts = try values.decode([DiscountsResourceDiscountAmount].self, forKey: "discount_amounts")
        self.id = try values.decode(String.self, forKey: "id")
        self.invoice = try values.decode(Invoice.self, forKey: "invoice")
        self.lines = try values.decode(Lines.self, forKey: "lines")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.memo = try values.decodeIfPresent(String.self, forKey: "memo")
        self.metadata = try values.decodeIfPresent([String: String].self, forKey: "metadata")
        self.number = try values.decode(String.self, forKey: "number")
        self.object = try values.decode(Object.self, forKey: "object")
        self.outOfBandAmount = try values.decodeIfPresent(Int.self, forKey: "out_of_band_amount")
        self.pdf = try values.decode(String.self, forKey: "pdf")
        self.reason = try values.decodeIfPresent(Reason.self, forKey: "reason")
        self.refund = try values.decodeIfPresent(Refund.self, forKey: "refund")
        self.status = try values.decode(Status.self, forKey: "status")
        self.subtotal = try values.decode(Int.self, forKey: "subtotal")
        self.subtotalExcludingTax = try values.decodeIfPresent(Int.self, forKey: "subtotal_excluding_tax")
        self.taxAmounts = try values.decode([CreditNoteTaxAmount].self, forKey: "tax_amounts")
        self.total = try values.decode(Int.self, forKey: "total")
        self.totalExcludingTax = try values.decodeIfPresent(Int.self, forKey: "total_excluding_tax")
        self.type = try values.decode(`Type`.self, forKey: "type")
        self.voidedAt = try values.decodeIfPresent(Int.self, forKey: "voided_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(amount, forKey: "amount")
        try values.encode(created, forKey: "created")
        try values.encode(currency, forKey: "currency")
        try values.encode(customer, forKey: "customer")
        try values.encodeIfPresent(customerBalanceTransaction, forKey: "customer_balance_transaction")
        try values.encode(discountAmount, forKey: "discount_amount")
        try values.encode(discountAmounts, forKey: "discount_amounts")
        try values.encode(id, forKey: "id")
        try values.encode(invoice, forKey: "invoice")
        try values.encode(lines, forKey: "lines")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encodeIfPresent(memo, forKey: "memo")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encode(number, forKey: "number")
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(outOfBandAmount, forKey: "out_of_band_amount")
        try values.encode(pdf, forKey: "pdf")
        try values.encodeIfPresent(reason, forKey: "reason")
        try values.encodeIfPresent(refund, forKey: "refund")
        try values.encode(status, forKey: "status")
        try values.encode(subtotal, forKey: "subtotal")
        try values.encodeIfPresent(subtotalExcludingTax, forKey: "subtotal_excluding_tax")
        try values.encode(taxAmounts, forKey: "tax_amounts")
        try values.encode(total, forKey: "total")
        try values.encodeIfPresent(totalExcludingTax, forKey: "total_excluding_tax")
        try values.encode(type, forKey: "type")
        try values.encodeIfPresent(voidedAt, forKey: "voided_at")
    }
}
