// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Any use of an [issued card](https://stripe.com/docs/issuing) that results in funds entering or leaving
/// your Stripe account, such as a completed purchase or refund, is represented by an Issuing
/// `Transaction` object.
/// 
/// Related guide: [Issued Card Transactions](https://stripe.com/docs/issuing/purchases/transactions).
public final class IssuingTransaction: Codable {
    /// The transaction amount, which will be reflected in your balance. This amount is in your currency and in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal).
    public let amount: Int
    /// Detailed breakdown of amount components. These amounts are denominated in `currency` and in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal).
    public let amountDetails: IssuingTransactionAmountDetails?
    /// The `Authorization` object that led to this transaction.
    public let authorization: Authorization?
    /// ID of the [balance transaction](https://stripe.com/docs/api/balance_transactions) associated with this transaction.
    public let balanceTransaction: BalanceTransaction?
    /// The card used to make this transaction.
    public let card: Card
    /// The cardholder to whom this transaction belongs.
    public let cardholder: Cardholder?
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public let created: Int
    /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    public let currency: String
    /// If you've disputed the transaction, the ID of the dispute.
    public let dispute: Dispute?
    /// Unique identifier for the object.
    public let id: String
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public let isLivemode: Bool
    /// The amount that the merchant will receive, denominated in `merchant_currency` and in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal). It will be different from `amount` if the merchant is taking payment in a different currency.
    public let merchantAmount: Int
    /// The currency with which the merchant is taking payment.
    public let merchantCurrency: String
    /// IssuingAuthorizationMerchantData
    public let merchantData: IssuingAuthorizationMerchantData
    /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    public let metadata: [String: String]
    /// String representing the object's type. Objects of the same type share the same value.
    public let object: Object
    /// Additional purchase information that is optionally provided by the merchant.
    public let purchaseDetails: IssuingTransactionPurchaseDetails?
    /// [Treasury](https://stripe.com/docs/api/treasury) details related to this transaction if it was created on a [FinancialAccount](/docs/api/treasury/financial_accounts
    public let treasury: IssuingTransactionTreasury?
    /// The nature of the transaction.
    public let type: `Type`
    /// The digital wallet used for this transaction. One of `apple_pay`, `google_pay`, or `samsung_pay`.
    public let wallet: Wallet?

    /// The `Authorization` object that led to this transaction.
    public struct Authorization: Codable {
        public var string: String?
        /// When an [issued card](https://stripe.com/docs/issuing) is used to make a purchase, an Issuing `Authorization`
        /// object is created. [Authorizations](https://stripe.com/docs/issuing/purchases/authorizations) must be approved for the
        /// purchase to be completed successfully.
        /// 
        /// Related guide: [Issued Card Authorizations](https://stripe.com/docs/issuing/purchases/authorizations).
        public var issuingAuthorization: IssuingAuthorization?

        public init(string: String? = nil, issuingAuthorization: IssuingAuthorization? = nil) {
            self.string = string
            self.issuingAuthorization = issuingAuthorization
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.issuingAuthorization = try? container.decode(IssuingAuthorization.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = issuingAuthorization { try container.encode(value) }
        }
    }

    /// ID of the [balance transaction](https://stripe.com/docs/api/balance_transactions) associated with this transaction.
    public final class BalanceTransaction: Codable {
        public let string: String?
        /// Balance transactions represent funds moving through your Stripe account.
        /// They're created for every type of transaction that comes into or flows out of your Stripe account balance.
        /// 
        /// Related guide: [Balance Transaction Types](https://stripe.com/docs/reports/balance-transaction-types).
        public let balanceTransaction: StripeKit.BalanceTransaction?

        public init(string: String? = nil, balanceTransaction: StripeKit.BalanceTransaction? = nil) {
            self.string = string
            self.balanceTransaction = balanceTransaction
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.balanceTransaction = try? container.decode(StripeKit.BalanceTransaction.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = balanceTransaction { try container.encode(value) }
        }
    }

    /// The card used to make this transaction.
    public struct Card: Codable {
        public var string: String?
        /// You can [create physical or virtual cards](https://stripe.com/docs/issuing/cards) that are issued to cardholders.
        public var issuingCard: IssuingCard?

        public init(string: String? = nil, issuingCard: IssuingCard? = nil) {
            self.string = string
            self.issuingCard = issuingCard
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.issuingCard = try? container.decode(IssuingCard.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = issuingCard { try container.encode(value) }
        }
    }

    /// The cardholder to whom this transaction belongs.
    public struct Cardholder: Codable {
        public var string: String?
        /// An Issuing `Cardholder` object represents an individual or business entity who is [issued](https://stripe.com/docs/issuing) cards.
        /// 
        /// Related guide: [How to create a Cardholder](https://stripe.com/docs/issuing/cards#create-cardholder)
        public var issuingCardholder: IssuingCardholder?

        public init(string: String? = nil, issuingCardholder: IssuingCardholder? = nil) {
            self.string = string
            self.issuingCardholder = issuingCardholder
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.issuingCardholder = try? container.decode(IssuingCardholder.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = issuingCardholder { try container.encode(value) }
        }
    }

    /// If you've disputed the transaction, the ID of the dispute.
    public struct Dispute: Codable {
        public var string: String?
        /// As a [card issuer](https://stripe.com/docs/issuing), you can dispute transactions that the cardholder does not recognize, suspects to be fraudulent, or has other issues with.
        /// 
        /// Related guide: [Disputing Transactions](https://stripe.com/docs/issuing/purchases/disputes)
        public var issuingDispute: IssuingDispute?

        public init(string: String? = nil, issuingDispute: IssuingDispute? = nil) {
            self.string = string
            self.issuingDispute = issuingDispute
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.issuingDispute = try? container.decode(IssuingDispute.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = issuingDispute { try container.encode(value) }
        }
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case issuingTransaction = "issuing.transaction"
    }

    /// The nature of the transaction.
    public enum `Type`: String, Codable, CaseIterable {
        case capture
        case refund
    }

    /// The digital wallet used for this transaction. One of `apple_pay`, `google_pay`, or `samsung_pay`.
    public enum Wallet: String, Codable, CaseIterable {
        case applePay = "apple_pay"
        case googlePay = "google_pay"
        case samsungPay = "samsung_pay"
    }

    public init(amount: Int, amountDetails: IssuingTransactionAmountDetails? = nil, authorization: Authorization? = nil, balanceTransaction: BalanceTransaction? = nil, card: Card, cardholder: Cardholder? = nil, created: Int, currency: String, dispute: Dispute? = nil, id: String, isLivemode: Bool, merchantAmount: Int, merchantCurrency: String, merchantData: IssuingAuthorizationMerchantData, metadata: [String: String], object: Object, purchaseDetails: IssuingTransactionPurchaseDetails? = nil, treasury: IssuingTransactionTreasury? = nil, type: `Type`, wallet: Wallet? = nil) {
        self.amount = amount
        self.amountDetails = amountDetails
        self.authorization = authorization
        self.balanceTransaction = balanceTransaction
        self.card = card
        self.cardholder = cardholder
        self.created = created
        self.currency = currency
        self.dispute = dispute
        self.id = id
        self.isLivemode = isLivemode
        self.merchantAmount = merchantAmount
        self.merchantCurrency = merchantCurrency
        self.merchantData = merchantData
        self.metadata = metadata
        self.object = object
        self.purchaseDetails = purchaseDetails
        self.treasury = treasury
        self.type = type
        self.wallet = wallet
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.amount = try values.decode(Int.self, forKey: "amount")
        self.amountDetails = try values.decodeIfPresent(IssuingTransactionAmountDetails.self, forKey: "amount_details")
        self.authorization = try values.decodeIfPresent(Authorization.self, forKey: "authorization")
        self.balanceTransaction = try values.decodeIfPresent(BalanceTransaction.self, forKey: "balance_transaction")
        self.card = try values.decode(Card.self, forKey: "card")
        self.cardholder = try values.decodeIfPresent(Cardholder.self, forKey: "cardholder")
        self.created = try values.decode(Int.self, forKey: "created")
        self.currency = try values.decode(String.self, forKey: "currency")
        self.dispute = try values.decodeIfPresent(Dispute.self, forKey: "dispute")
        self.id = try values.decode(String.self, forKey: "id")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.merchantAmount = try values.decode(Int.self, forKey: "merchant_amount")
        self.merchantCurrency = try values.decode(String.self, forKey: "merchant_currency")
        self.merchantData = try values.decode(IssuingAuthorizationMerchantData.self, forKey: "merchant_data")
        self.metadata = try values.decode([String: String].self, forKey: "metadata")
        self.object = try values.decode(Object.self, forKey: "object")
        self.purchaseDetails = try values.decodeIfPresent(IssuingTransactionPurchaseDetails.self, forKey: "purchase_details")
        self.treasury = try values.decodeIfPresent(IssuingTransactionTreasury.self, forKey: "treasury")
        self.type = try values.decode(`Type`.self, forKey: "type")
        self.wallet = try values.decodeIfPresent(Wallet.self, forKey: "wallet")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(amount, forKey: "amount")
        try values.encodeIfPresent(amountDetails, forKey: "amount_details")
        try values.encodeIfPresent(authorization, forKey: "authorization")
        try values.encodeIfPresent(balanceTransaction, forKey: "balance_transaction")
        try values.encode(card, forKey: "card")
        try values.encodeIfPresent(cardholder, forKey: "cardholder")
        try values.encode(created, forKey: "created")
        try values.encode(currency, forKey: "currency")
        try values.encodeIfPresent(dispute, forKey: "dispute")
        try values.encode(id, forKey: "id")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encode(merchantAmount, forKey: "merchant_amount")
        try values.encode(merchantCurrency, forKey: "merchant_currency")
        try values.encode(merchantData, forKey: "merchant_data")
        try values.encode(metadata, forKey: "metadata")
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(purchaseDetails, forKey: "purchase_details")
        try values.encodeIfPresent(treasury, forKey: "treasury")
        try values.encode(type, forKey: "type")
        try values.encodeIfPresent(wallet, forKey: "wallet")
    }
}
