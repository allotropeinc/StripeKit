// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// PlatformFee
public final class ApplicationFee: Codable {
    /// ID of the Stripe account this fee was taken from.
    public let account: Account
    /// Amount earned, in %s.
    public let amount: Int
    /// Amount in %s refunded (can be less than the amount attribute on the fee if a partial refund was issued)
    public let amountRefunded: Int
    /// ID of the Connect application that earned the fee.
    public let application: Application
    /// Balance transaction that describes the impact of this collected application fee on your account balance (not including refunds).
    public let balanceTransaction: BalanceTransaction?
    /// ID of the charge that the application fee was taken from.
    public let charge: Charge
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public let created: Int
    /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    public let currency: String
    /// Unique identifier for the object.
    public let id: String
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public let isLivemode: Bool
    /// String representing the object's type. Objects of the same type share the same value.
    public let object: Object
    /// ID of the corresponding charge on the platform account, if this fee was the result of a charge using the `destination` parameter.
    public let originatingTransaction: OriginatingTransaction?
    /// Whether the fee has been fully refunded. If the fee is only partially refunded, this attribute will still be false.
    public let isRefunded: Bool
    /// FeeRefundList
    ///
    /// A list of refunds that have been applied to the fee.
    public let refunds: Refunds

    /// ID of the Stripe account this fee was taken from.
    public final class Account: Codable {
        public let string: String?
        /// This is an object representing a Stripe account. You can retrieve it to see
        /// properties on the account like its current e-mail address or if the account is
        /// enabled yet to make live charges.
        /// 
        /// Some properties, marked below, are available only to platforms that want to
        /// [create and manage Express or Custom accounts](https://stripe.com/docs/connect/accounts).
        public let account: StripeKit.Account?

        public init(string: String? = nil, account: StripeKit.Account? = nil) {
            self.string = string
            self.account = account
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.account = try? container.decode(StripeKit.Account.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = account { try container.encode(value) }
        }
    }

    /// ID of the Connect application that earned the fee.
    public final class Application: Codable {
        public let string: String?
        public let application: StripeKit.Application?

        public init(string: String? = nil, application: StripeKit.Application? = nil) {
            self.string = string
            self.application = application
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.application = try? container.decode(StripeKit.Application.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = application { try container.encode(value) }
        }
    }

    /// Balance transaction that describes the impact of this collected application fee on your account balance (not including refunds).
    public final class BalanceTransaction: Codable {
        public let string: String?
        /// Balance transactions represent funds moving through your Stripe account.
        /// They're created for every type of transaction that comes into or flows out of your Stripe account balance.
        /// 
        /// Related guide: [Balance Transaction Types](https://stripe.com/docs/reports/balance-transaction-types).
        public let balanceTransaction: StripeKit.BalanceTransaction?

        public init(string: String? = nil, balanceTransaction: StripeKit.BalanceTransaction? = nil) {
            self.string = string
            self.balanceTransaction = balanceTransaction
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.balanceTransaction = try? container.decode(StripeKit.BalanceTransaction.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = balanceTransaction { try container.encode(value) }
        }
    }

    /// ID of the charge that the application fee was taken from.
    public final class Charge: Codable {
        public let string: String?
        /// To charge a credit or a debit card, you create a `Charge` object. You can
        /// retrieve and refund individual charges as well as list all charges. Charges
        /// are identified by a unique, random ID.
        /// 
        /// Related guide: [Accept a payment with the Charges API](https://stripe.com/docs/payments/accept-a-payment-charges).
        public let charge: StripeKit.Charge?

        public init(string: String? = nil, charge: StripeKit.Charge? = nil) {
            self.string = string
            self.charge = charge
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.charge = try? container.decode(StripeKit.Charge.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = charge { try container.encode(value) }
        }
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case applicationFee = "application_fee"
    }

    /// ID of the corresponding charge on the platform account, if this fee was the result of a charge using the `destination` parameter.
    public struct OriginatingTransaction: Codable {
        public var string: String?
        /// To charge a credit or a debit card, you create a `Charge` object. You can
        /// retrieve and refund individual charges as well as list all charges. Charges
        /// are identified by a unique, random ID.
        /// 
        /// Related guide: [Accept a payment with the Charges API](https://stripe.com/docs/payments/accept-a-payment-charges).
        public var charge: Charge?

        public init(string: String? = nil, charge: Charge? = nil) {
            self.string = string
            self.charge = charge
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.charge = try? container.decode(Charge.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = charge { try container.encode(value) }
        }
    }

    /// FeeRefundList
    ///
    /// A list of refunds that have been applied to the fee.
    public struct Refunds: Codable {
        /// Details about each object.
        public var data: [FeeRefund]
        /// True if this list has another page of items after this one that can be fetched.
        public var hasMore: Bool
        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public var object: Object
        /// The URL where this list can be accessed.
        public var url: String

        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public enum Object: String, Codable, CaseIterable {
            case list
        }

        public init(data: [FeeRefund], hasMore: Bool, object: Object, url: String) {
            self.data = data
            self.hasMore = hasMore
            self.object = object
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.data = try values.decode([FeeRefund].self, forKey: "data")
            self.hasMore = try values.decode(Bool.self, forKey: "has_more")
            self.object = try values.decode(Object.self, forKey: "object")
            self.url = try values.decode(String.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(data, forKey: "data")
            try values.encode(hasMore, forKey: "has_more")
            try values.encode(object, forKey: "object")
            try values.encode(url, forKey: "url")
        }
    }

    public init(account: Account, amount: Int, amountRefunded: Int, application: Application, balanceTransaction: BalanceTransaction? = nil, charge: Charge, created: Int, currency: String, id: String, isLivemode: Bool, object: Object, originatingTransaction: OriginatingTransaction? = nil, isRefunded: Bool, refunds: Refunds) {
        self.account = account
        self.amount = amount
        self.amountRefunded = amountRefunded
        self.application = application
        self.balanceTransaction = balanceTransaction
        self.charge = charge
        self.created = created
        self.currency = currency
        self.id = id
        self.isLivemode = isLivemode
        self.object = object
        self.originatingTransaction = originatingTransaction
        self.isRefunded = isRefunded
        self.refunds = refunds
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.account = try values.decode(Account.self, forKey: "account")
        self.amount = try values.decode(Int.self, forKey: "amount")
        self.amountRefunded = try values.decode(Int.self, forKey: "amount_refunded")
        self.application = try values.decode(Application.self, forKey: "application")
        self.balanceTransaction = try values.decodeIfPresent(BalanceTransaction.self, forKey: "balance_transaction")
        self.charge = try values.decode(Charge.self, forKey: "charge")
        self.created = try values.decode(Int.self, forKey: "created")
        self.currency = try values.decode(String.self, forKey: "currency")
        self.id = try values.decode(String.self, forKey: "id")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.object = try values.decode(Object.self, forKey: "object")
        self.originatingTransaction = try values.decodeIfPresent(OriginatingTransaction.self, forKey: "originating_transaction")
        self.isRefunded = try values.decode(Bool.self, forKey: "refunded")
        self.refunds = try values.decode(Refunds.self, forKey: "refunds")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(account, forKey: "account")
        try values.encode(amount, forKey: "amount")
        try values.encode(amountRefunded, forKey: "amount_refunded")
        try values.encode(application, forKey: "application")
        try values.encodeIfPresent(balanceTransaction, forKey: "balance_transaction")
        try values.encode(charge, forKey: "charge")
        try values.encode(created, forKey: "created")
        try values.encode(currency, forKey: "currency")
        try values.encode(id, forKey: "id")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(originatingTransaction, forKey: "originating_transaction")
        try values.encode(isRefunded, forKey: "refunded")
        try values.encode(refunds, forKey: "refunds")
    }
}
