// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// A `Transfer` object is created when you move funds between Stripe accounts as
/// part of Connect.
/// 
/// Before April 6, 2017, transfers also represented movement of funds from a
/// Stripe account to a card or bank account. This behavior has since been split
/// out into a [Payout](https://stripe.com/docs/api#payout_object) object, with corresponding payout endpoints. For more
/// information, read about the
/// [transfer/payout split](https://stripe.com/docs/transfer-payout-split).
/// 
/// Related guide: [Creating Separate Charges and Transfers](https://stripe.com/docs/connect/charges-transfers).
public struct Transfer: Codable {
    /// Amount in %s to be transferred.
    public var amount: Int
    /// Amount in %s reversed (can be less than the amount attribute on the transfer if a partial reversal was issued).
    public var amountReversed: Int
    /// Balance transaction that describes the impact of this transfer on your account balance.
    public var balanceTransaction: BalanceTransaction?
    /// Time that this record of the transfer was first created.
    public var created: Int
    /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    public var currency: String
    /// An arbitrary string attached to the object. Often useful for displaying to users.
    public var description: String?
    /// ID of the Stripe account the transfer was sent to.
    public var destination: Destination?
    /// If the destination is a Stripe account, this will be the ID of the payment that the destination account received for the transfer.
    public var destinationPayment: DestinationPayment?
    /// Unique identifier for the object.
    public var id: String
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    public var metadata: [String: String]
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// TransferReversalList
    ///
    /// A list of reversals that have been applied to the transfer.
    public var reversals: Reversals
    /// Whether the transfer has been fully reversed. If the transfer is only partially reversed, this attribute will still be false.
    public var isReversed: Bool
    /// ID of the charge or payment that was used to fund the transfer. If null, the transfer was funded from the available balance.
    public var sourceTransaction: SourceTransaction?
    /// The source balance this transfer came from. One of `card`, `fpx`, or `bank_account`.
    public var sourceType: String?
    /// A string that identifies this transaction as part of a group. See the [Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-options) for details.
    public var transferGroup: String?

    /// Balance transaction that describes the impact of this transfer on your account balance.
    public final class BalanceTransaction: Codable {
        public let string: String?
        /// Balance transactions represent funds moving through your Stripe account.
        /// They're created for every type of transaction that comes into or flows out of your Stripe account balance.
        /// 
        /// Related guide: [Balance Transaction Types](https://stripe.com/docs/reports/balance-transaction-types).
        public let balanceTransaction: StripeKit.BalanceTransaction?

        public init(string: String? = nil, balanceTransaction: StripeKit.BalanceTransaction? = nil) {
            self.string = string
            self.balanceTransaction = balanceTransaction
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.balanceTransaction = try? container.decode(StripeKit.BalanceTransaction.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = balanceTransaction { try container.encode(value) }
        }
    }

    /// ID of the Stripe account the transfer was sent to.
    public struct Destination: Codable {
        public var string: String?
        /// This is an object representing a Stripe account. You can retrieve it to see
        /// properties on the account like its current e-mail address or if the account is
        /// enabled yet to make live charges.
        /// 
        /// Some properties, marked below, are available only to platforms that want to
        /// [create and manage Express or Custom accounts](https://stripe.com/docs/connect/accounts).
        public var account: Account?

        public init(string: String? = nil, account: Account? = nil) {
            self.string = string
            self.account = account
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.account = try? container.decode(Account.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = account { try container.encode(value) }
        }
    }

    /// If the destination is a Stripe account, this will be the ID of the payment that the destination account received for the transfer.
    public struct DestinationPayment: Codable {
        public var string: String?
        /// To charge a credit or a debit card, you create a `Charge` object. You can
        /// retrieve and refund individual charges as well as list all charges. Charges
        /// are identified by a unique, random ID.
        /// 
        /// Related guide: [Accept a payment with the Charges API](https://stripe.com/docs/payments/accept-a-payment-charges).
        public var charge: Charge?

        public init(string: String? = nil, charge: Charge? = nil) {
            self.string = string
            self.charge = charge
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.charge = try? container.decode(Charge.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = charge { try container.encode(value) }
        }
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case transfer
    }

    /// TransferReversalList
    ///
    /// A list of reversals that have been applied to the transfer.
    public struct Reversals: Codable {
        /// Details about each object.
        public var data: [TransferReversal]
        /// True if this list has another page of items after this one that can be fetched.
        public var hasMore: Bool
        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public var object: Object
        /// The URL where this list can be accessed.
        public var url: String

        /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
        public enum Object: String, Codable, CaseIterable {
            case list
        }

        public init(data: [TransferReversal], hasMore: Bool, object: Object, url: String) {
            self.data = data
            self.hasMore = hasMore
            self.object = object
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.data = try values.decode([TransferReversal].self, forKey: "data")
            self.hasMore = try values.decode(Bool.self, forKey: "has_more")
            self.object = try values.decode(Object.self, forKey: "object")
            self.url = try values.decode(String.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(data, forKey: "data")
            try values.encode(hasMore, forKey: "has_more")
            try values.encode(object, forKey: "object")
            try values.encode(url, forKey: "url")
        }
    }

    /// ID of the charge or payment that was used to fund the transfer. If null, the transfer was funded from the available balance.
    public struct SourceTransaction: Codable {
        public var string: String?
        /// To charge a credit or a debit card, you create a `Charge` object. You can
        /// retrieve and refund individual charges as well as list all charges. Charges
        /// are identified by a unique, random ID.
        /// 
        /// Related guide: [Accept a payment with the Charges API](https://stripe.com/docs/payments/accept-a-payment-charges).
        public var charge: Charge?

        public init(string: String? = nil, charge: Charge? = nil) {
            self.string = string
            self.charge = charge
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.charge = try? container.decode(Charge.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = charge { try container.encode(value) }
        }
    }

    public init(amount: Int, amountReversed: Int, balanceTransaction: BalanceTransaction? = nil, created: Int, currency: String, description: String? = nil, destination: Destination? = nil, destinationPayment: DestinationPayment? = nil, id: String, isLivemode: Bool, metadata: [String: String], object: Object, reversals: Reversals, isReversed: Bool, sourceTransaction: SourceTransaction? = nil, sourceType: String? = nil, transferGroup: String? = nil) {
        self.amount = amount
        self.amountReversed = amountReversed
        self.balanceTransaction = balanceTransaction
        self.created = created
        self.currency = currency
        self.description = description
        self.destination = destination
        self.destinationPayment = destinationPayment
        self.id = id
        self.isLivemode = isLivemode
        self.metadata = metadata
        self.object = object
        self.reversals = reversals
        self.isReversed = isReversed
        self.sourceTransaction = sourceTransaction
        self.sourceType = sourceType
        self.transferGroup = transferGroup
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.amount = try values.decode(Int.self, forKey: "amount")
        self.amountReversed = try values.decode(Int.self, forKey: "amount_reversed")
        self.balanceTransaction = try values.decodeIfPresent(BalanceTransaction.self, forKey: "balance_transaction")
        self.created = try values.decode(Int.self, forKey: "created")
        self.currency = try values.decode(String.self, forKey: "currency")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.destination = try values.decodeIfPresent(Destination.self, forKey: "destination")
        self.destinationPayment = try values.decodeIfPresent(DestinationPayment.self, forKey: "destination_payment")
        self.id = try values.decode(String.self, forKey: "id")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.metadata = try values.decode([String: String].self, forKey: "metadata")
        self.object = try values.decode(Object.self, forKey: "object")
        self.reversals = try values.decode(Reversals.self, forKey: "reversals")
        self.isReversed = try values.decode(Bool.self, forKey: "reversed")
        self.sourceTransaction = try values.decodeIfPresent(SourceTransaction.self, forKey: "source_transaction")
        self.sourceType = try values.decodeIfPresent(String.self, forKey: "source_type")
        self.transferGroup = try values.decodeIfPresent(String.self, forKey: "transfer_group")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(amount, forKey: "amount")
        try values.encode(amountReversed, forKey: "amount_reversed")
        try values.encodeIfPresent(balanceTransaction, forKey: "balance_transaction")
        try values.encode(created, forKey: "created")
        try values.encode(currency, forKey: "currency")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(destination, forKey: "destination")
        try values.encodeIfPresent(destinationPayment, forKey: "destination_payment")
        try values.encode(id, forKey: "id")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encode(metadata, forKey: "metadata")
        try values.encode(object, forKey: "object")
        try values.encode(reversals, forKey: "reversals")
        try values.encode(isReversed, forKey: "reversed")
        try values.encodeIfPresent(sourceTransaction, forKey: "source_transaction")
        try values.encodeIfPresent(sourceType, forKey: "source_type")
        try values.encodeIfPresent(transferGroup, forKey: "transfer_group")
    }
}
