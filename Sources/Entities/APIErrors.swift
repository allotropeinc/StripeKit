// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public final class APIErrors: Codable {
    /// For card errors, the ID of the failed charge.
    public let charge: String?
    /// For some errors that could be handled programmatically, a short string indicating the [error code](https://stripe.com/docs/error-codes) reported.
    public let code: String?
    /// For card errors resulting from a card issuer decline, a short string indicating the [card issuer's reason for the decline](https://stripe.com/docs/declines#issuer-declines) if they provide one.
    public let declineCode: String?
    /// A URL to more information about the [error code](https://stripe.com/docs/error-codes) reported.
    public let docURL: String?
    /// A human-readable message providing more details about the error. For card errors, these messages can be shown to your users.
    public let message: String?
    /// If the error is parameter-specific, the parameter related to the error. For example, you can use this to display a message near the correct form field.
    public let param: String?
    /// A PaymentIntent guides you through the process of collecting a payment from your customer.
    /// We recommend that you create exactly one PaymentIntent for each order or
    /// customer session in your system. You can reference the PaymentIntent later to
    /// see the history of payment attempts for a particular session.
    /// 
    /// A PaymentIntent transitions through
    /// [multiple statuses](https://stripe.com/docs/payments/intents#intent-statuses)
    /// throughout its lifetime as it interfaces with Stripe.js to perform
    /// authentication flows and ultimately creates at most one successful charge.
    /// 
    /// Related guide: [Payment Intents API](https://stripe.com/docs/payments/payment-intents).
    public let paymentIntent: PaymentIntent?
    /// PaymentMethod objects represent your customer's payment instruments.
    /// You can use them with [PaymentIntents](https://stripe.com/docs/payments/payment-intents) to collect payments or save them to
    /// Customer objects to store instrument details for future payments.
    /// 
    /// Related guides: [Payment Methods](https://stripe.com/docs/payments/payment-methods) and [More Payment Scenarios](https://stripe.com/docs/payments/more-payment-scenarios).
    public let paymentMethod: PaymentMethod?
    /// If the error is specific to the type of payment method, the payment method type that had a problem. This field is only populated for invoice-related errors.
    public let paymentMethodType: String?
    /// A SetupIntent guides you through the process of setting up and saving a customer's payment credentials for future payments.
    /// For example, you could use a SetupIntent to set up and save your customer's card without immediately collecting a payment.
    /// Later, you can use [PaymentIntents](https://stripe.com/docs/api#payment_intents) to drive the payment flow.
    /// 
    /// Create a SetupIntent as soon as you're ready to collect your customer's payment credentials.
    /// Do not maintain long-lived, unconfirmed SetupIntents as they may no longer be valid.
    /// The SetupIntent then transitions through multiple [statuses](https://stripe.com/docs/payments/intents#intent-statuses) as it guides
    /// you through the setup process.
    /// 
    /// Successful SetupIntents result in payment credentials that are optimized for future payments.
    /// For example, cardholders in [certain regions](/guides/strong-customer-authentication) may need to be run through
    /// [Strong Customer Authentication](https://stripe.com/docs/strong-customer-authentication) at the time of payment method collection
    /// in order to streamline later [off-session payments](https://stripe.com/docs/payments/setup-intents).
    /// If the SetupIntent is used with a [Customer](https://stripe.com/docs/api#setup_intent_object-customer), upon success,
    /// it will automatically attach the resulting payment method to that Customer.
    /// We recommend using SetupIntents or [setup_future_usage](https://stripe.com/docs/api#payment_intent_object-setup_future_usage) on
    /// PaymentIntents to save payment methods in order to prevent saving invalid or unoptimized payment methods.
    /// 
    /// By using SetupIntents, you ensure that your customers experience the minimum set of required friction,
    /// even as regulations change over time.
    /// 
    /// Related guide: [Setup Intents API](https://stripe.com/docs/payments/setup-intents).
    public let setupIntent: SetupIntent?
    /// The source object for errors returned on a request involving a source.
    public let source: Source?
    /// The type of error returned. One of `api_error`, `card_error`, `idempotency_error`, or `invalid_request_error`
    public let type: `Type`

    /// The source object for errors returned on a request involving a source.
    public final class Source: Codable {
        /// These bank accounts are payment methods on `Customer` objects.
        /// 
        /// On the other hand [External Accounts](https://stripe.com/docs/api#external_accounts) are transfer
        /// destinations on `Account` objects for [Custom accounts](https://stripe.com/docs/connect/custom-accounts).
        /// They can be bank accounts or debit cards as well, and are documented in the links above.
        /// 
        /// Related guide: [Bank Debits and Transfers](https://stripe.com/docs/payments/bank-debits-transfers).
        public let bankAccount: BankAccount?
        /// You can store multiple cards on a customer in order to charge the customer
        /// later. You can also store multiple debit cards on a recipient in order to
        /// transfer to those cards later.
        /// 
        /// Related guide: [Card Payments with Sources](https://stripe.com/docs/sources/cards).
        public let card: Card?
        /// `Source` objects allow you to accept a variety of payment methods. They
        /// represent a customer's payment instrument, and can be used with the Stripe API
        /// just like a `Card` object: once chargeable, they can be charged, or can be
        /// attached to customers.
        /// 
        /// Related guides: [Sources API](https://stripe.com/docs/sources) and [Sources & Customers](https://stripe.com/docs/sources/customers).
        public let source: StripeKit.Source?

        public init(bankAccount: BankAccount? = nil, card: Card? = nil, source: StripeKit.Source? = nil) {
            self.bankAccount = bankAccount
            self.card = card
            self.source = source
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.bankAccount = try? container.decode(BankAccount.self)
            self.card = try? container.decode(Card.self)
            self.source = try? container.decode(StripeKit.Source.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = bankAccount { try container.encode(value) }
            if let value = card { try container.encode(value) }
            if let value = source { try container.encode(value) }
        }
    }

    /// The type of error returned. One of `api_error`, `card_error`, `idempotency_error`, or `invalid_request_error`
    public enum `Type`: String, Codable, CaseIterable {
        case apiError = "api_error"
        case cardError = "card_error"
        case idempotencyError = "idempotency_error"
        case invalidRequestError = "invalid_request_error"
    }

    public init(charge: String? = nil, code: String? = nil, declineCode: String? = nil, docURL: String? = nil, message: String? = nil, param: String? = nil, paymentIntent: PaymentIntent? = nil, paymentMethod: PaymentMethod? = nil, paymentMethodType: String? = nil, setupIntent: SetupIntent? = nil, source: Source? = nil, type: `Type`) {
        self.charge = charge
        self.code = code
        self.declineCode = declineCode
        self.docURL = docURL
        self.message = message
        self.param = param
        self.paymentIntent = paymentIntent
        self.paymentMethod = paymentMethod
        self.paymentMethodType = paymentMethodType
        self.setupIntent = setupIntent
        self.source = source
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.charge = try values.decodeIfPresent(String.self, forKey: "charge")
        self.code = try values.decodeIfPresent(String.self, forKey: "code")
        self.declineCode = try values.decodeIfPresent(String.self, forKey: "decline_code")
        self.docURL = try values.decodeIfPresent(String.self, forKey: "doc_url")
        self.message = try values.decodeIfPresent(String.self, forKey: "message")
        self.param = try values.decodeIfPresent(String.self, forKey: "param")
        self.paymentIntent = try values.decodeIfPresent(PaymentIntent.self, forKey: "payment_intent")
        self.paymentMethod = try values.decodeIfPresent(PaymentMethod.self, forKey: "payment_method")
        self.paymentMethodType = try values.decodeIfPresent(String.self, forKey: "payment_method_type")
        self.setupIntent = try values.decodeIfPresent(SetupIntent.self, forKey: "setup_intent")
        self.source = try values.decodeIfPresent(Source.self, forKey: "source")
        self.type = try values.decode(`Type`.self, forKey: "type")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(charge, forKey: "charge")
        try values.encodeIfPresent(code, forKey: "code")
        try values.encodeIfPresent(declineCode, forKey: "decline_code")
        try values.encodeIfPresent(docURL, forKey: "doc_url")
        try values.encodeIfPresent(message, forKey: "message")
        try values.encodeIfPresent(param, forKey: "param")
        try values.encodeIfPresent(paymentIntent, forKey: "payment_intent")
        try values.encodeIfPresent(paymentMethod, forKey: "payment_method")
        try values.encodeIfPresent(paymentMethodType, forKey: "payment_method_type")
        try values.encodeIfPresent(setupIntent, forKey: "setup_intent")
        try values.encodeIfPresent(source, forKey: "source")
        try values.encode(type, forKey: "type")
    }
}
