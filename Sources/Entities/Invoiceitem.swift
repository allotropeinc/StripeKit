// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Sometimes you want to add a charge or credit to a customer, but actually
/// charge or credit the customer's card only at the end of a regular billing
/// cycle. This is useful for combining several charges (to minimize
/// per-transaction fees), or for having Stripe tabulate your usage-based billing
/// totals.
/// 
/// Related guide: [Subscription Invoices](https://stripe.com/docs/billing/invoices/subscription#adding-upcoming-invoice-items).
public struct Invoiceitem: Codable {
    /// Amount (in the `currency` specified) of the invoice item. This should always be equal to `unit_amount * quantity`.
    public var amount: Int
    /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    public var currency: String
    /// The ID of the customer who will be billed when this invoice item is billed.
    public var customer: Customer
    /// Time at which the object was created. Measured in seconds since the Unix epoch.
    public var date: Int
    /// An arbitrary string attached to the object. Often useful for displaying to users.
    public var description: String?
    /// If true, discounts will apply to this invoice item. Always false for prorations.
    public var isDiscountable: Bool
    /// The discounts which apply to the invoice item. Item discounts are applied before invoice discounts. Use `expand[]=discounts` to expand each discount.
    public var discounts: [Discount]?
    /// Unique identifier for the object.
    public var id: String
    /// The ID of the invoice this invoice item belongs to.
    public var invoice: Invoice?
    /// Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    public var isLivemode: Bool
    /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    public var metadata: [String: String]?
    /// String representing the object's type. Objects of the same type share the same value.
    public var object: Object
    /// InvoiceLineItemPeriod
    public var period: InvoiceLineItemPeriod
    /// The price of the invoice item.
    public var price: Price?
    /// Whether the invoice item was created automatically as a proration adjustment when the customer switched plans.
    public var isProration: Bool
    /// Quantity of units for the invoice item. If the invoice item is a proration, the quantity of the subscription that the proration was computed for.
    public var quantity: Int
    /// The subscription that this invoice item has been created for, if any.
    public var subscription: Subscription?
    /// The subscription item that this invoice item has been created for, if any.
    public var subscriptionItem: String?
    /// The tax rates which apply to the invoice item. When set, the `default_tax_rates` on the invoice do not apply to this invoice item.
    public var taxRates: [TaxRate]?
    /// ID of the test clock this invoice item belongs to.
    public var testClock: TestClock?
    /// Unit amount (in the `currency` specified) of the invoice item.
    public var unitAmount: Int?
    /// Same as `unit_amount`, but contains a decimal value with at most 12 decimal places.
    public var unitAmountDecimal: String?

    /// The ID of the customer who will be billed when this invoice item is billed.
    public final class Customer: Codable {
        public let string: String?
        /// This object represents a customer of your business. It lets you create recurring charges and track payments that belong to the same customer.
        /// 
        /// Related guide: [Save a card during payment](https://stripe.com/docs/payments/save-during-payment).
        public let customer: StripeKit.Customer?
        public let deletedCustomer: DeletedCustomer?

        public init(string: String? = nil, customer: StripeKit.Customer? = nil, deletedCustomer: DeletedCustomer? = nil) {
            self.string = string
            self.customer = customer
            self.deletedCustomer = deletedCustomer
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.customer = try? container.decode(StripeKit.Customer.self)
            self.deletedCustomer = try? container.decode(DeletedCustomer.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = customer { try container.encode(value) }
            if let value = deletedCustomer { try container.encode(value) }
        }
    }

    public final class Discount: Codable {
        public let string: String?
        /// A discount represents the actual application of a [coupon](https://stripe.com/docs/api#coupons) or [promotion code](https://stripe.com/docs/api#promotion_codes).
        /// It contains information about when the discount began, when it will end, and what it is applied to.
        /// 
        /// Related guide: [Applying Discounts to Subscriptions](https://stripe.com/docs/billing/subscriptions/discounts).
        public let discount: StripeKit.Discount?

        public init(string: String? = nil, discount: StripeKit.Discount? = nil) {
            self.string = string
            self.discount = discount
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.discount = try? container.decode(StripeKit.Discount.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = discount { try container.encode(value) }
        }
    }

    /// The ID of the invoice this invoice item belongs to.
    public final class Invoice: Codable {
        public let string: String?
        /// Invoices are statements of amounts owed by a customer, and are either
        /// generated one-off, or generated periodically from a subscription.
        /// 
        /// They contain [invoice items](https://stripe.com/docs/api#invoiceitems), and proration adjustments
        /// that may be caused by subscription upgrades/downgrades (if necessary).
        /// 
        /// If your invoice is configured to be billed through automatic charges,
        /// Stripe automatically finalizes your invoice and attempts payment. Note
        /// that finalizing the invoice,
        /// [when automatic](https://stripe.com/docs/billing/invoices/workflow/#auto_advance), does
        /// not happen immediately as the invoice is created. Stripe waits
        /// until one hour after the last webhook was successfully sent (or the last
        /// webhook timed out after failing). If you (and the platforms you may have
        /// connected to) have no webhooks configured, Stripe waits one hour after
        /// creation to finalize the invoice.
        /// 
        /// If your invoice is configured to be billed by sending an email, then based on your
        /// [email settings](https://dashboard.stripe.com/account/billing/automatic),
        /// Stripe will email the invoice to your customer and await payment. These
        /// emails can contain a link to a hosted page to pay the invoice.
        /// 
        /// Stripe applies any customer credit on the account before determining the
        /// amount due for the invoice (i.e., the amount that will be actually
        /// charged). If the amount due for the invoice is less than Stripe's [minimum allowed charge
        /// per currency](/docs/currencies#minimum-and-maximum-charge-amounts), the
        /// invoice is automatically marked paid, and we add the amount due to the
        /// customer's credit balance which is applied to the next invoice.
        /// 
        /// More details on the customer's credit balance are
        /// [here](https://stripe.com/docs/billing/customer/balance).
        /// 
        /// Related guide: [Send Invoices to Customers](https://stripe.com/docs/billing/invoices/sending).
        public let invoice: StripeKit.Invoice?

        public init(string: String? = nil, invoice: StripeKit.Invoice? = nil) {
            self.string = string
            self.invoice = invoice
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.invoice = try? container.decode(StripeKit.Invoice.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = invoice { try container.encode(value) }
        }
    }

    /// String representing the object's type. Objects of the same type share the same value.
    public enum Object: String, Codable, CaseIterable {
        case invoiceitem
    }

    /// The subscription that this invoice item has been created for, if any.
    public final class Subscription: Codable {
        public let string: String?
        /// Subscriptions allow you to charge a customer on a recurring basis.
        /// 
        /// Related guide: [Creating Subscriptions](https://stripe.com/docs/billing/subscriptions/creating).
        public let subscription: StripeKit.Subscription?

        public init(string: String? = nil, subscription: StripeKit.Subscription? = nil) {
            self.string = string
            self.subscription = subscription
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.subscription = try? container.decode(StripeKit.Subscription.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = subscription { try container.encode(value) }
        }
    }

    /// ID of the test clock this invoice item belongs to.
    public struct TestClock: Codable {
        public var string: String?
        /// TestClock
        ///
        /// A test clock enables deterministic control over objects in testmode. With a test clock, you can create
        /// objects at a frozen time in the past or future, and advance to a specific future time to observe webhooks and state changes. After the clock advances,
        /// you can either validate the current state of your scenario (and test your assumptions), change the current state of your scenario (and test more complex scenarios), or keep advancing forward in time.
        public var testHelpersTestClock: TestHelpersTestClock?

        public init(string: String? = nil, testHelpersTestClock: TestHelpersTestClock? = nil) {
            self.string = string
            self.testHelpersTestClock = testHelpersTestClock
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.testHelpersTestClock = try? container.decode(TestHelpersTestClock.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = testHelpersTestClock { try container.encode(value) }
        }
    }

    public init(amount: Int, currency: String, customer: Customer, date: Int, description: String? = nil, isDiscountable: Bool, discounts: [Discount]? = nil, id: String, invoice: Invoice? = nil, isLivemode: Bool, metadata: [String: String]? = nil, object: Object, period: InvoiceLineItemPeriod, price: Price? = nil, isProration: Bool, quantity: Int, subscription: Subscription? = nil, subscriptionItem: String? = nil, taxRates: [TaxRate]? = nil, testClock: TestClock? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
        self.amount = amount
        self.currency = currency
        self.customer = customer
        self.date = date
        self.description = description
        self.isDiscountable = isDiscountable
        self.discounts = discounts
        self.id = id
        self.invoice = invoice
        self.isLivemode = isLivemode
        self.metadata = metadata
        self.object = object
        self.period = period
        self.price = price
        self.isProration = isProration
        self.quantity = quantity
        self.subscription = subscription
        self.subscriptionItem = subscriptionItem
        self.taxRates = taxRates
        self.testClock = testClock
        self.unitAmount = unitAmount
        self.unitAmountDecimal = unitAmountDecimal
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.amount = try values.decode(Int.self, forKey: "amount")
        self.currency = try values.decode(String.self, forKey: "currency")
        self.customer = try values.decode(Customer.self, forKey: "customer")
        self.date = try values.decode(Int.self, forKey: "date")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.isDiscountable = try values.decode(Bool.self, forKey: "discountable")
        self.discounts = try values.decodeIfPresent([Discount].self, forKey: "discounts")
        self.id = try values.decode(String.self, forKey: "id")
        self.invoice = try values.decodeIfPresent(Invoice.self, forKey: "invoice")
        self.isLivemode = try values.decode(Bool.self, forKey: "livemode")
        self.metadata = try values.decodeIfPresent([String: String].self, forKey: "metadata")
        self.object = try values.decode(Object.self, forKey: "object")
        self.period = try values.decode(InvoiceLineItemPeriod.self, forKey: "period")
        self.price = try values.decodeIfPresent(Price.self, forKey: "price")
        self.isProration = try values.decode(Bool.self, forKey: "proration")
        self.quantity = try values.decode(Int.self, forKey: "quantity")
        self.subscription = try values.decodeIfPresent(Subscription.self, forKey: "subscription")
        self.subscriptionItem = try values.decodeIfPresent(String.self, forKey: "subscription_item")
        self.taxRates = try values.decodeIfPresent([TaxRate].self, forKey: "tax_rates")
        self.testClock = try values.decodeIfPresent(TestClock.self, forKey: "test_clock")
        self.unitAmount = try values.decodeIfPresent(Int.self, forKey: "unit_amount")
        self.unitAmountDecimal = try values.decodeIfPresent(String.self, forKey: "unit_amount_decimal")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(amount, forKey: "amount")
        try values.encode(currency, forKey: "currency")
        try values.encode(customer, forKey: "customer")
        try values.encode(date, forKey: "date")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(isDiscountable, forKey: "discountable")
        try values.encodeIfPresent(discounts, forKey: "discounts")
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(invoice, forKey: "invoice")
        try values.encode(isLivemode, forKey: "livemode")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encode(object, forKey: "object")
        try values.encode(period, forKey: "period")
        try values.encodeIfPresent(price, forKey: "price")
        try values.encode(isProration, forKey: "proration")
        try values.encode(quantity, forKey: "quantity")
        try values.encodeIfPresent(subscription, forKey: "subscription")
        try values.encodeIfPresent(subscriptionItem, forKey: "subscription_item")
        try values.encodeIfPresent(taxRates, forKey: "tax_rates")
        try values.encodeIfPresent(testClock, forKey: "test_clock")
        try values.encodeIfPresent(unitAmount, forKey: "unit_amount")
        try values.encodeIfPresent(unitAmountDecimal, forKey: "unit_amount_decimal")
    }
}
