// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var subscriptionSchedules: SubscriptionSchedules {
        SubscriptionSchedules(path: "/v1/subscription_schedules")
    }

    public struct SubscriptionSchedules {
        /// Path: `/v1/subscription_schedules`
        public let path: String

        /// <p>Retrieves the list of your subscription schedules.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            Request(method: "GET", url: path, query: parameters?.asQuery, id: "GetSubscriptionSchedules")
        }

        /// SubscriptionSchedulesResourceScheduleList
        public struct GetResponse: Decodable {
            public var data: [StripeKit.SubscriptionSchedule]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeKit.SubscriptionSchedule], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.data = try values.decode([StripeKit.SubscriptionSchedule].self, forKey: "data")
                self.hasMore = try values.decode(Bool.self, forKey: "has_more")
                self.object = try values.decode(Object.self, forKey: "object")
                self.url = try values.decode(String.self, forKey: "url")
            }
        }

        public struct GetParameters {
            public var canceledAt: CanceledAt?
            public var completedAt: CompletedAt?
            public var created: Created?
            public var customer: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var releasedAt: ReleasedAt?
            public var isScheduled: Bool?
            public var startingAfter: String?

            public struct CanceledAt: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public struct CompletedAt: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public struct ReleasedAt: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(canceledAt: CanceledAt? = nil, completedAt: CompletedAt? = nil, created: Created? = nil, customer: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, releasedAt: ReleasedAt? = nil, isScheduled: Bool? = nil, startingAfter: String? = nil) {
                self.canceledAt = canceledAt
                self.completedAt = completedAt
                self.created = created
                self.customer = customer
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.releasedAt = releasedAt
                self.isScheduled = isScheduled
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(canceledAt, forKey: "canceled_at", isDeepObject: true)
                encoder.encode(completedAt, forKey: "completed_at", isDeepObject: true)
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(customer, forKey: "customer")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(releasedAt, forKey: "released_at", isDeepObject: true)
                encoder.encode(isScheduled, forKey: "scheduled")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a new subscription schedule object. Each customer can have up to 500 active or scheduled subscriptions.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeKit.SubscriptionSchedule> {
            Request(method: "POST", url: path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery, id: "PostSubscriptionSchedules")
        }

        public struct PostRequest: Encodable {
            /// The identifier of the customer to create the subscription schedule for.
            public var customer: String?
            /// Default_settings_params
            ///
            /// Object representing the subscription schedule's default settings.
            public var defaultSettings: DefaultSettings?
            /// Configures how the subscription schedule behaves when it ends. Possible values are `release` or `cancel` with the default being `release`. `release` will end the subscription schedule and keep the underlying subscription running.`cancel` will end the subscription schedule and cancel the underlying subscription.
            public var endBehavior: EndBehavior?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Migrate an existing subscription to be managed by a subscription schedule. If this parameter is set, a subscription schedule will be created using the subscription's item(s), set to auto-renew using the subscription's interval. When using this parameter, other parameters (such as phase values) cannot be set. To create a subscription schedule with other modifications, we recommend making two separate API calls.
            public var fromSubscription: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// List representing phases of the subscription schedule. Each phase can be customized to have different durations, plans, and coupons. If there are multiple phases, the `end_date` of one phase will always equal the `start_date` of the next phase.
            public var phases: [Phase]?
            /// When the subscription schedule starts. We recommend using `now` so that it starts the subscription immediately. You can also use a Unix timestamp to backdate the subscription so that it starts on a past date, or set a future date for the subscription to start on.
            public var startDate: StartDate?

            /// Default_settings_params
            ///
            /// Object representing the subscription schedule's default settings.
            public struct DefaultSettings: Encodable {
                public var applicationFeePercent: Double?
                /// Automatic_tax_config
                public var automaticTax: AutomaticTax?
                public var billingCycleAnchor: BillingCycleAnchor?
                public var billingThresholds: BillingThresholds?
                public var collectionMethod: CollectionMethod?
                public var defaultPaymentMethod: String?
                /// Subscription_schedules_param
                public var invoiceSettings: InvoiceSettings?
                public var transferData: TransferData?

                /// Automatic_tax_config
                public struct AutomaticTax: Encodable {
                    public var isEnabled: Bool

                    public init(isEnabled: Bool) {
                        self.isEnabled = isEnabled
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isEnabled, forKey: "enabled")
                        return encoder.items
                    }
                }

                public enum BillingCycleAnchor: String, Codable, CaseIterable {
                    case automatic
                    case phaseStart = "phase_start"
                }

                public struct BillingThresholds: Encodable {
                    /// Billing_thresholds_param
                    public var a: A?
                    public var b: B?

                    /// Billing_thresholds_param
                    public struct A: Encodable {
                        public var amountGte: Int?
                        public var isResetBillingCycleAnchor: Bool?

                        public init(amountGte: Int? = nil, isResetBillingCycleAnchor: Bool? = nil) {
                            self.amountGte = amountGte
                            self.isResetBillingCycleAnchor = isResetBillingCycleAnchor
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(amountGte, forKey: "amount_gte")
                            encoder.encode(isResetBillingCycleAnchor, forKey: "reset_billing_cycle_anchor")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public enum CollectionMethod: String, Codable, CaseIterable {
                    case chargeAutomatically = "charge_automatically"
                    case sendInvoice = "send_invoice"
                }

                /// Subscription_schedules_param
                public struct InvoiceSettings: Encodable {
                    public var daysUntilDue: Int?

                    public init(daysUntilDue: Int? = nil) {
                        self.daysUntilDue = daysUntilDue
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(daysUntilDue, forKey: "days_until_due")
                        return encoder.items
                    }
                }

                public struct TransferData: Encodable {
                    /// Transfer_data_specs
                    public var a: A?
                    public var b: B?

                    /// Transfer_data_specs
                    public struct A: Encodable {
                        public var amountPercent: Double?
                        public var destination: String

                        public init(amountPercent: Double? = nil, destination: String) {
                            self.amountPercent = amountPercent
                            self.destination = destination
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(amountPercent, forKey: "amount_percent")
                            encoder.encode(destination, forKey: "destination")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public init(applicationFeePercent: Double? = nil, automaticTax: AutomaticTax? = nil, billingCycleAnchor: BillingCycleAnchor? = nil, billingThresholds: BillingThresholds? = nil, collectionMethod: CollectionMethod? = nil, defaultPaymentMethod: String? = nil, invoiceSettings: InvoiceSettings? = nil, transferData: TransferData? = nil) {
                    self.applicationFeePercent = applicationFeePercent
                    self.automaticTax = automaticTax
                    self.billingCycleAnchor = billingCycleAnchor
                    self.billingThresholds = billingThresholds
                    self.collectionMethod = collectionMethod
                    self.defaultPaymentMethod = defaultPaymentMethod
                    self.invoiceSettings = invoiceSettings
                    self.transferData = transferData
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                    encoder.encode(automaticTax, forKey: "automatic_tax")
                    encoder.encode(billingCycleAnchor, forKey: "billing_cycle_anchor")
                    encoder.encode(billingThresholds, forKey: "billing_thresholds")
                    encoder.encode(collectionMethod, forKey: "collection_method")
                    encoder.encode(defaultPaymentMethod, forKey: "default_payment_method")
                    encoder.encode(invoiceSettings, forKey: "invoice_settings")
                    encoder.encode(transferData, forKey: "transfer_data")
                    return encoder.items
                }
            }

            /// Configures how the subscription schedule behaves when it ends. Possible values are `release` or `cancel` with the default being `release`. `release` will end the subscription schedule and keep the underlying subscription running.`cancel` will end the subscription schedule and cancel the underlying subscription.
            public enum EndBehavior: String, Codable, CaseIterable {
                case cancel
                case `none`
                case release
                case renew
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Phase_configuration_params
            public struct Phase: Encodable {
                public var addInvoiceItems: [AddInvoiceItem]?
                public var applicationFeePercent: Double?
                /// Automatic_tax_config
                public var automaticTax: AutomaticTax?
                public var billingCycleAnchor: BillingCycleAnchor?
                public var billingThresholds: BillingThresholds?
                public var collectionMethod: CollectionMethod?
                public var coupon: String?
                public var currency: String?
                public var defaultPaymentMethod: String?
                public var defaultTaxRates: DefaultTaxRates?
                public var endDate: Int?
                /// Subscription_schedules_param
                public var invoiceSettings: InvoiceSettings?
                public var items: [Item]
                public var iterations: Int?
                public var metadata: [String: String]?
                public var prorationBehavior: ProrationBehavior?
                /// Transfer_data_specs
                public var transferData: TransferData?
                public var isTrial: Bool?
                public var trialEnd: Int?

                /// Add_invoice_item_entry
                public struct AddInvoiceItem: Encodable {
                    public var price: String?
                    /// One_time_price_data
                    public var priceData: PriceData?
                    public var quantity: Int?
                    public var taxRates: TaxRates?

                    /// One_time_price_data
                    public struct PriceData: Encodable {
                        public var currency: String
                        public var product: String
                        public var taxBehavior: TaxBehavior?
                        public var unitAmount: Int?
                        public var unitAmountDecimal: String?

                        public enum TaxBehavior: String, Codable, CaseIterable {
                            case exclusive
                            case inclusive
                            case unspecified
                        }

                        public init(currency: String, product: String, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                            self.currency = currency
                            self.product = product
                            self.taxBehavior = taxBehavior
                            self.unitAmount = unitAmount
                            self.unitAmountDecimal = unitAmountDecimal
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(currency, forKey: "currency")
                            encoder.encode(product, forKey: "product")
                            encoder.encode(taxBehavior, forKey: "tax_behavior")
                            encoder.encode(unitAmount, forKey: "unit_amount")
                            encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                            return encoder.items
                        }
                    }

                    public struct TaxRates: Encodable {
                        public var strings: [String]?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(strings: [String]? = nil, object: Object? = nil) {
                            self.strings = strings
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(strings, forKey: "strings")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                        self.price = price
                        self.priceData = priceData
                        self.quantity = quantity
                        self.taxRates = taxRates
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(price, forKey: "price")
                        encoder.encode(priceData, forKey: "price_data")
                        encoder.encode(quantity, forKey: "quantity")
                        encoder.encode(taxRates, forKey: "tax_rates")
                        return encoder.items
                    }
                }

                /// Automatic_tax_config
                public struct AutomaticTax: Encodable {
                    public var isEnabled: Bool

                    public init(isEnabled: Bool) {
                        self.isEnabled = isEnabled
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isEnabled, forKey: "enabled")
                        return encoder.items
                    }
                }

                public enum BillingCycleAnchor: String, Codable, CaseIterable {
                    case automatic
                    case phaseStart = "phase_start"
                }

                public struct BillingThresholds: Encodable {
                    /// Billing_thresholds_param
                    public var a: A?
                    public var b: B?

                    /// Billing_thresholds_param
                    public struct A: Encodable {
                        public var amountGte: Int?
                        public var isResetBillingCycleAnchor: Bool?

                        public init(amountGte: Int? = nil, isResetBillingCycleAnchor: Bool? = nil) {
                            self.amountGte = amountGte
                            self.isResetBillingCycleAnchor = isResetBillingCycleAnchor
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(amountGte, forKey: "amount_gte")
                            encoder.encode(isResetBillingCycleAnchor, forKey: "reset_billing_cycle_anchor")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public enum CollectionMethod: String, Codable, CaseIterable {
                    case chargeAutomatically = "charge_automatically"
                    case sendInvoice = "send_invoice"
                }

                public struct DefaultTaxRates: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                /// Subscription_schedules_param
                public struct InvoiceSettings: Encodable {
                    public var daysUntilDue: Int?

                    public init(daysUntilDue: Int? = nil) {
                        self.daysUntilDue = daysUntilDue
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(daysUntilDue, forKey: "days_until_due")
                        return encoder.items
                    }
                }

                /// Configuration_item_params
                public struct Item: Encodable {
                    public var billingThresholds: BillingThresholds?
                    public var price: String?
                    /// Recurring_price_data
                    public var priceData: PriceData?
                    public var quantity: Int?
                    public var taxRates: TaxRates?

                    public struct BillingThresholds: Encodable {
                        /// Item_billing_thresholds_param
                        public var a: A?
                        public var b: B?

                        /// Item_billing_thresholds_param
                        public struct A: Encodable {
                            public var usageGte: Int

                            public init(usageGte: Int) {
                                self.usageGte = usageGte
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(usageGte, forKey: "usage_gte")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    /// Recurring_price_data
                    public struct PriceData: Encodable {
                        public var currency: String
                        public var product: String
                        /// Recurring_adhoc
                        public var recurring: Recurring
                        public var taxBehavior: TaxBehavior?
                        public var unitAmount: Int?
                        public var unitAmountDecimal: String?

                        /// Recurring_adhoc
                        public struct Recurring: Encodable {
                            public var interval: Interval
                            public var intervalCount: Int?

                            public enum Interval: String, Codable, CaseIterable {
                                case day
                                case month
                                case week
                                case year
                            }

                            public init(interval: Interval, intervalCount: Int? = nil) {
                                self.interval = interval
                                self.intervalCount = intervalCount
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(interval, forKey: "interval")
                                encoder.encode(intervalCount, forKey: "interval_count")
                                return encoder.items
                            }
                        }

                        public enum TaxBehavior: String, Codable, CaseIterable {
                            case exclusive
                            case inclusive
                            case unspecified
                        }

                        public init(currency: String, product: String, recurring: Recurring, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                            self.currency = currency
                            self.product = product
                            self.recurring = recurring
                            self.taxBehavior = taxBehavior
                            self.unitAmount = unitAmount
                            self.unitAmountDecimal = unitAmountDecimal
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(currency, forKey: "currency")
                            encoder.encode(product, forKey: "product")
                            encoder.encode(recurring, forKey: "recurring")
                            encoder.encode(taxBehavior, forKey: "tax_behavior")
                            encoder.encode(unitAmount, forKey: "unit_amount")
                            encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                            return encoder.items
                        }
                    }

                    public struct TaxRates: Encodable {
                        public var strings: [String]?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(strings: [String]? = nil, object: Object? = nil) {
                            self.strings = strings
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(strings, forKey: "strings")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(billingThresholds: BillingThresholds? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                        self.billingThresholds = billingThresholds
                        self.price = price
                        self.priceData = priceData
                        self.quantity = quantity
                        self.taxRates = taxRates
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(billingThresholds, forKey: "billing_thresholds")
                        encoder.encode(price, forKey: "price")
                        encoder.encode(priceData, forKey: "price_data")
                        encoder.encode(quantity, forKey: "quantity")
                        encoder.encode(taxRates, forKey: "tax_rates")
                        return encoder.items
                    }
                }

                public enum ProrationBehavior: String, Codable, CaseIterable {
                    case alwaysInvoice = "always_invoice"
                    case createProrations = "create_prorations"
                    case `none`
                }

                /// Transfer_data_specs
                public struct TransferData: Encodable {
                    public var amountPercent: Double?
                    public var destination: String

                    public init(amountPercent: Double? = nil, destination: String) {
                        self.amountPercent = amountPercent
                        self.destination = destination
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amountPercent, forKey: "amount_percent")
                        encoder.encode(destination, forKey: "destination")
                        return encoder.items
                    }
                }

                public init(addInvoiceItems: [AddInvoiceItem]? = nil, applicationFeePercent: Double? = nil, automaticTax: AutomaticTax? = nil, billingCycleAnchor: BillingCycleAnchor? = nil, billingThresholds: BillingThresholds? = nil, collectionMethod: CollectionMethod? = nil, coupon: String? = nil, currency: String? = nil, defaultPaymentMethod: String? = nil, defaultTaxRates: DefaultTaxRates? = nil, endDate: Int? = nil, invoiceSettings: InvoiceSettings? = nil, items: [Item], iterations: Int? = nil, metadata: [String: String]? = nil, prorationBehavior: ProrationBehavior? = nil, transferData: TransferData? = nil, isTrial: Bool? = nil, trialEnd: Int? = nil) {
                    self.addInvoiceItems = addInvoiceItems
                    self.applicationFeePercent = applicationFeePercent
                    self.automaticTax = automaticTax
                    self.billingCycleAnchor = billingCycleAnchor
                    self.billingThresholds = billingThresholds
                    self.collectionMethod = collectionMethod
                    self.coupon = coupon
                    self.currency = currency
                    self.defaultPaymentMethod = defaultPaymentMethod
                    self.defaultTaxRates = defaultTaxRates
                    self.endDate = endDate
                    self.invoiceSettings = invoiceSettings
                    self.items = items
                    self.iterations = iterations
                    self.metadata = metadata
                    self.prorationBehavior = prorationBehavior
                    self.transferData = transferData
                    self.isTrial = isTrial
                    self.trialEnd = trialEnd
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(addInvoiceItems, forKey: "add_invoice_items")
                    encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                    encoder.encode(automaticTax, forKey: "automatic_tax")
                    encoder.encode(billingCycleAnchor, forKey: "billing_cycle_anchor")
                    encoder.encode(billingThresholds, forKey: "billing_thresholds")
                    encoder.encode(collectionMethod, forKey: "collection_method")
                    encoder.encode(coupon, forKey: "coupon")
                    encoder.encode(currency, forKey: "currency")
                    encoder.encode(defaultPaymentMethod, forKey: "default_payment_method")
                    encoder.encode(defaultTaxRates, forKey: "default_tax_rates")
                    encoder.encode(endDate, forKey: "end_date")
                    encoder.encode(invoiceSettings, forKey: "invoice_settings")
                    encoder.encode(items, forKey: "items")
                    encoder.encode(iterations, forKey: "iterations")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(prorationBehavior, forKey: "proration_behavior")
                    encoder.encode(transferData, forKey: "transfer_data")
                    encoder.encode(isTrial, forKey: "trial")
                    encoder.encode(trialEnd, forKey: "trial_end")
                    return encoder.items
                }
            }

            /// When the subscription schedule starts. We recommend using `now` so that it starts the subscription immediately. You can also use a Unix timestamp to backdate the subscription so that it starts on a past date, or set a future date for the subscription to start on.
            public struct StartDate: Encodable {
                public var int: Int?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case now
                }

                public init(int: Int? = nil, object: Object? = nil) {
                    self.int = int
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(int, forKey: "int")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(customer: String? = nil, defaultSettings: DefaultSettings? = nil, endBehavior: EndBehavior? = nil, expand: [String]? = nil, fromSubscription: String? = nil, metadata: Metadata? = nil, phases: [Phase]? = nil, startDate: StartDate? = nil) {
                self.customer = customer
                self.defaultSettings = defaultSettings
                self.endBehavior = endBehavior
                self.expand = expand
                self.fromSubscription = fromSubscription
                self.metadata = metadata
                self.phases = phases
                self.startDate = startDate
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(customer, forKey: "customer")
                encoder.encode(defaultSettings, forKey: "default_settings")
                encoder.encode(endBehavior, forKey: "end_behavior")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(fromSubscription, forKey: "from_subscription")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(phases, forKey: "phases")
                encoder.encode(startDate, forKey: "start_date")
                return encoder.items
            }
        }
    }
}
