// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths.Charges.WithCharge {
    public var capture: Capture {
        Capture(path: path + "/capture")
    }

    public struct Capture {
        /// Path: `/v1/charges/{charge}/capture`
        public let path: String

        /// <p>Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you <a href="#create_charge">created a charge</a> with the capture option set to false.</p>
        /// 
        /// <p>Uncaptured payments expire a set number of days after they are created (<a href="/docs/charges/placing-a-hold">7 by default</a>). If they are not captured by that point in time, they will be marked as refunded and will no longer be capturable.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeKit.Charge> {
            Request(method: "POST", url: path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery, id: "PostChargesChargeCapture")
        }

        public struct PostRequest: Encodable {
            /// The amount to capture, which must be less than or equal to the original amount. Any additional amount will be automatically refunded.
            public var amount: Int?
            /// An application fee to add on to this charge.
            public var applicationFee: Int?
            /// An application fee amount to add on to this charge, which must be less than or equal to the original amount.
            public var applicationFeeAmount: Int?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The email address to send this charge's receipt to. This will override the previously-specified email address for this charge, if one was set. Receipts will not be sent in test mode.
            public var receiptEmail: String?
            /// For card charges, use `statement_descriptor_suffix` instead. Otherwise, you can use this value as the complete description of a charge on your customers’ statements. Must contain at least one letter, maximum 22 characters.
            public var statementDescriptor: String?
            /// Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
            public var statementDescriptorSuffix: String?
            /// Transfer_data_specs
            ///
            /// An optional dictionary including the account to automatically transfer to as part of a destination charge. [See the Connect documentation](https://stripe.com/docs/connect/destination-charges) for details.
            public var transferData: TransferData?
            /// A string that identifies this transaction as part of a group. `transfer_group` may only be provided if it has not been set. See the [Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-options) for details.
            public var transferGroup: String?

            /// Transfer_data_specs
            ///
            /// An optional dictionary including the account to automatically transfer to as part of a destination charge. [See the Connect documentation](https://stripe.com/docs/connect/destination-charges) for details.
            public struct TransferData: Encodable {
                public var amount: Int?

                public init(amount: Int? = nil) {
                    self.amount = amount
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    return encoder.items
                }
            }

            public init(amount: Int? = nil, applicationFee: Int? = nil, applicationFeeAmount: Int? = nil, expand: [String]? = nil, receiptEmail: String? = nil, statementDescriptor: String? = nil, statementDescriptorSuffix: String? = nil, transferData: TransferData? = nil, transferGroup: String? = nil) {
                self.amount = amount
                self.applicationFee = applicationFee
                self.applicationFeeAmount = applicationFeeAmount
                self.expand = expand
                self.receiptEmail = receiptEmail
                self.statementDescriptor = statementDescriptor
                self.statementDescriptorSuffix = statementDescriptorSuffix
                self.transferData = transferData
                self.transferGroup = transferGroup
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(applicationFee, forKey: "application_fee")
                encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(receiptEmail, forKey: "receipt_email")
                encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                encoder.encode(statementDescriptorSuffix, forKey: "statement_descriptor_suffix")
                encoder.encode(transferData, forKey: "transfer_data")
                encoder.encode(transferGroup, forKey: "transfer_group")
                return encoder.items
            }
        }
    }
}
