// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var quotes: Quotes {
        Quotes(path: "/v1/quotes")
    }

    public struct Quotes {
        /// Path: `/v1/quotes`
        public let path: String

        /// <p>Returns a list of your quotes.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            Request(method: "GET", url: path, query: parameters?.asQuery, id: "GetQuotes")
        }

        /// QuotesResourceQuoteList
        public struct GetResponse: Decodable {
            public var data: [StripeKit.Quote]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeKit.Quote], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.data = try values.decode([StripeKit.Quote].self, forKey: "data")
                self.hasMore = try values.decode(Bool.self, forKey: "has_more")
                self.object = try values.decode(Object.self, forKey: "object")
                self.url = try values.decode(String.self, forKey: "url")
            }
        }

        public struct GetParameters {
            public var customer: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var status: Status?
            public var testClock: String?

            public enum Status: String, Codable, CaseIterable {
                case accepted
                case canceled
                case draft
                case `open`
            }

            public init(customer: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, status: Status? = nil, testClock: String? = nil) {
                self.customer = customer
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
                self.status = status
                self.testClock = testClock
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(customer, forKey: "customer")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(status, forKey: "status")
                encoder.encode(testClock, forKey: "test_clock")
                return encoder.items
            }
        }

        /// <p>A quote models prices and services for a customer. Default options for <code>header</code>, <code>description</code>, <code>footer</code>, and <code>expires_at</code> can be set in the dashboard via the <a href="https://dashboard.stripe.com/settings/billing/quote">quote template</a>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeKit.Quote> {
            Request(method: "POST", url: path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery, id: "PostQuotes")
        }

        public struct PostRequest: Encodable {
            /// The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. There cannot be any line items with recurring prices when using this field.
            public var applicationFeeAmount: ApplicationFeeAmount?
            /// A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. There must be at least 1 line item with a recurring price to use this field.
            public var applicationFeePercent: ApplicationFeePercent?
            /// Automatic_tax_param
            ///
            /// Settings for automatic tax lookup for this quote and resulting invoices and subscriptions.
            public var automaticTax: AutomaticTax?
            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or at invoice finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
            public var collectionMethod: CollectionMethod?
            /// The customer for which this quote belongs to. A customer is required before finalizing the quote. Once specified, it cannot be changed.
            public var customer: String?
            /// The tax rates that will apply to any line item that does not have `tax_rates` set.
            public var defaultTaxRates: DefaultTaxRates?
            /// A description that will be displayed on the quote PDF. If no value is passed, the default description configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
            public var description: String?
            /// The discounts applied to the quote. You can only set up to one discount.
            public var discounts: Discounts?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// A future timestamp on which the quote will be canceled if in `open` or `draft` status. Measured in seconds since the Unix epoch. If no value is passed, the default expiration date configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
            public var expiresAt: Int?
            /// A footer that will be displayed on the quote PDF. If no value is passed, the default footer configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
            public var footer: String?
            /// From_quote_params
            ///
            /// Clone an existing quote. The new quote will be created in `status=draft`. When using this parameter, you cannot specify any other parameters except for `expires_at`.
            public var fromQuote: FromQuote?
            /// A header that will be displayed on the quote PDF. If no value is passed, the default header configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
            public var header: String?
            /// Quote_param
            ///
            /// All invoices will be billed using the specified settings.
            public var invoiceSettings: InvoiceSettings?
            /// A list of line items the customer is being quoted for. Each line item includes information about the product, the quantity, and the resulting cost.
            public var lineItems: [LineItem]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// The account on behalf of which to charge.
            public var onBehalfOf: OnBehalfOf?
            /// Subscription_data_create_params
            ///
            /// When creating a subscription or subscription schedule, the specified configuration data will be used. There must be at least one line item with a recurring price for a subscription or subscription schedule to be created. A subscription schedule is created if `subscription_data[effective_date]` is present and in the future, otherwise a subscription is created.
            public var subscriptionData: SubscriptionData?
            /// ID of the test clock to attach to the quote.
            public var testClock: String?
            /// The data with which to automatically create a Transfer for each of the invoices.
            public var transferData: TransferData?

            /// The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. There cannot be any line items with recurring prices when using this field.
            public struct ApplicationFeeAmount: Encodable {
                public var int: Int?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(int: Int? = nil, object: Object? = nil) {
                    self.int = int
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(int, forKey: "int")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. There must be at least 1 line item with a recurring price to use this field.
            public struct ApplicationFeePercent: Encodable {
                public var double: Double?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(double: Double? = nil, object: Object? = nil) {
                    self.double = double
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(double, forKey: "double")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Automatic_tax_param
            ///
            /// Settings for automatic tax lookup for this quote and resulting invoices and subscriptions.
            public struct AutomaticTax: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or at invoice finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
            public enum CollectionMethod: String, Codable, CaseIterable {
                case chargeAutomatically = "charge_automatically"
                case sendInvoice = "send_invoice"
            }

            /// The tax rates that will apply to any line item that does not have `tax_rates` set.
            public struct DefaultTaxRates: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The discounts applied to the quote. You can only set up to one discount.
            public struct Discounts: Encodable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Discounts_data_param
                public struct PlaceholderItem: Encodable {
                    public var coupon: String?
                    public var discount: String?

                    public init(coupon: String? = nil, discount: String? = nil) {
                        self.coupon = coupon
                        self.discount = discount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(coupon, forKey: "coupon")
                        encoder.encode(discount, forKey: "discount")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// From_quote_params
            ///
            /// Clone an existing quote. The new quote will be created in `status=draft`. When using this parameter, you cannot specify any other parameters except for `expires_at`.
            public struct FromQuote: Encodable {
                public var isRevision: Bool?
                public var quote: String

                public init(isRevision: Bool? = nil, quote: String) {
                    self.isRevision = isRevision
                    self.quote = quote
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isRevision, forKey: "is_revision")
                    encoder.encode(quote, forKey: "quote")
                    return encoder.items
                }
            }

            /// Quote_param
            ///
            /// All invoices will be billed using the specified settings.
            public struct InvoiceSettings: Encodable {
                public var daysUntilDue: Int?

                public init(daysUntilDue: Int? = nil) {
                    self.daysUntilDue = daysUntilDue
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(daysUntilDue, forKey: "days_until_due")
                    return encoder.items
                }
            }

            /// Line_item_create_params
            public struct LineItem: Encodable {
                public var price: String?
                /// Price_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: TaxRates?

                /// Price_data
                public struct PriceData: Encodable {
                    public var currency: String
                    public var product: String
                    /// Recurring_adhoc
                    public var recurring: Recurring?
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    /// Recurring_adhoc
                    public struct Recurring: Encodable {
                        public var interval: Interval
                        public var intervalCount: Int?

                        public enum Interval: String, Codable, CaseIterable {
                            case day
                            case month
                            case week
                            case year
                        }

                        public init(interval: Interval, intervalCount: Int? = nil) {
                            self.interval = interval
                            self.intervalCount = intervalCount
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(interval, forKey: "interval")
                            encoder.encode(intervalCount, forKey: "interval_count")
                            return encoder.items
                        }
                    }

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String, recurring: Recurring? = nil, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.recurring = recurring
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(recurring, forKey: "recurring")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public struct TaxRates: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    return encoder.items
                }
            }

            /// The account on behalf of which to charge.
            public struct OnBehalfOf: Encodable {
                public var string: String?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(string: String? = nil, object: Object? = nil) {
                    self.string = string
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(string, forKey: "string")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Subscription_data_create_params
            ///
            /// When creating a subscription or subscription schedule, the specified configuration data will be used. There must be at least one line item with a recurring price for a subscription or subscription schedule to be created. A subscription schedule is created if `subscription_data[effective_date]` is present and in the future, otherwise a subscription is created.
            public struct SubscriptionData: Encodable {
                public var effectiveDate: EffectiveDate?
                public var trialPeriodDays: TrialPeriodDays?

                public struct EffectiveDate: Encodable {
                    public var object1: Object1?
                    public var int: Int?
                    public var object2: Object2?

                    public enum Object1: String, Codable, CaseIterable {
                        case currentPeriodEnd = "current_period_end"
                    }

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object1: Object1? = nil, int: Int? = nil, object2: Object2? = nil) {
                        self.object1 = object1
                        self.int = int
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object1, forKey: "object1")
                        encoder.encode(int, forKey: "int")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct TrialPeriodDays: Encodable {
                    public var int: Int?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(int: Int? = nil, object: Object? = nil) {
                        self.int = int
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(int, forKey: "int")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(effectiveDate: EffectiveDate? = nil, trialPeriodDays: TrialPeriodDays? = nil) {
                    self.effectiveDate = effectiveDate
                    self.trialPeriodDays = trialPeriodDays
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(effectiveDate, forKey: "effective_date")
                    encoder.encode(trialPeriodDays, forKey: "trial_period_days")
                    return encoder.items
                }
            }

            /// The data with which to automatically create a Transfer for each of the invoices.
            public struct TransferData: Encodable {
                /// Transfer_data_specs
                public var a: A?
                public var b: B?

                /// Transfer_data_specs
                public struct A: Encodable {
                    public var amount: Int?
                    public var amountPercent: Double?
                    public var destination: String

                    public init(amount: Int? = nil, amountPercent: Double? = nil, destination: String) {
                        self.amount = amount
                        self.amountPercent = amountPercent
                        self.destination = destination
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amount, forKey: "amount")
                        encoder.encode(amountPercent, forKey: "amount_percent")
                        encoder.encode(destination, forKey: "destination")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            public init(applicationFeeAmount: ApplicationFeeAmount? = nil, applicationFeePercent: ApplicationFeePercent? = nil, automaticTax: AutomaticTax? = nil, collectionMethod: CollectionMethod? = nil, customer: String? = nil, defaultTaxRates: DefaultTaxRates? = nil, description: String? = nil, discounts: Discounts? = nil, expand: [String]? = nil, expiresAt: Int? = nil, footer: String? = nil, fromQuote: FromQuote? = nil, header: String? = nil, invoiceSettings: InvoiceSettings? = nil, lineItems: [LineItem]? = nil, metadata: [String: String]? = nil, onBehalfOf: OnBehalfOf? = nil, subscriptionData: SubscriptionData? = nil, testClock: String? = nil, transferData: TransferData? = nil) {
                self.applicationFeeAmount = applicationFeeAmount
                self.applicationFeePercent = applicationFeePercent
                self.automaticTax = automaticTax
                self.collectionMethod = collectionMethod
                self.customer = customer
                self.defaultTaxRates = defaultTaxRates
                self.description = description
                self.discounts = discounts
                self.expand = expand
                self.expiresAt = expiresAt
                self.footer = footer
                self.fromQuote = fromQuote
                self.header = header
                self.invoiceSettings = invoiceSettings
                self.lineItems = lineItems
                self.metadata = metadata
                self.onBehalfOf = onBehalfOf
                self.subscriptionData = subscriptionData
                self.testClock = testClock
                self.transferData = transferData
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                encoder.encode(automaticTax, forKey: "automatic_tax")
                encoder.encode(collectionMethod, forKey: "collection_method")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(defaultTaxRates, forKey: "default_tax_rates")
                encoder.encode(description, forKey: "description")
                encoder.encode(discounts, forKey: "discounts")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(expiresAt, forKey: "expires_at")
                encoder.encode(footer, forKey: "footer")
                encoder.encode(fromQuote, forKey: "from_quote")
                encoder.encode(header, forKey: "header")
                encoder.encode(invoiceSettings, forKey: "invoice_settings")
                encoder.encode(lineItems, forKey: "line_items")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(onBehalfOf, forKey: "on_behalf_of")
                encoder.encode(subscriptionData, forKey: "subscription_data")
                encoder.encode(testClock, forKey: "test_clock")
                encoder.encode(transferData, forKey: "transfer_data")
                return encoder.items
            }
        }
    }
}
