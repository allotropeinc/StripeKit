// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var balanceTransactions: BalanceTransactions {
        BalanceTransactions(path: "/v1/balance_transactions")
    }

    public struct BalanceTransactions {
        /// Path: `/v1/balance_transactions`
        public let path: String

        /// <p>Returns a list of transactions that have contributed to the Stripe account balance (e.g., charges, transfers, and so forth). The transactions are returned in sorted order, with the most recent transactions appearing first.</p>
        /// 
        /// <p>Note that this endpoint was previously called “Balance history” and used the path <code>/v1/balance/history</code>.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            Request(method: "GET", url: path, query: parameters?.asQuery, id: "GetBalanceTransactions")
        }

        /// BalanceTransactionsList
        public struct GetResponse: Decodable {
            public var data: [StripeKit.BalanceTransaction]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeKit.BalanceTransaction], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.data = try values.decode([StripeKit.BalanceTransaction].self, forKey: "data")
                self.hasMore = try values.decode(Bool.self, forKey: "has_more")
                self.object = try values.decode(Object.self, forKey: "object")
                self.url = try values.decode(String.self, forKey: "url")
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var currency: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var payout: String?
            public var source: String?
            public var startingAfter: String?
            public var type: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, currency: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, payout: String? = nil, source: String? = nil, startingAfter: String? = nil, type: String? = nil) {
                self.created = created
                self.currency = currency
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.payout = payout
                self.source = source
                self.startingAfter = startingAfter
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(currency, forKey: "currency")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(payout, forKey: "payout")
                encoder.encode(source, forKey: "source")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }
    }
}
