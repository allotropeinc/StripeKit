// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths.SubscriptionSchedules {
    public func schedule(_ schedule: String) -> WithSchedule {
        WithSchedule(path: "\(path)/\(schedule)")
    }

    public struct WithSchedule {
        /// Path: `/v1/subscription_schedules/{schedule}`
        public let path: String

        /// <p>Retrieves the details of an existing subscription schedule. You only need to supply the unique subscription schedule identifier that was returned upon subscription schedule creation.</p>
        public func get(expand: [String]? = nil) -> Request<StripeKit.SubscriptionSchedule> {
            Request(method: "GET", url: path, query: makeGetQuery(expand), id: "GetSubscriptionSchedulesSchedule")
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates an existing subscription schedule.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeKit.SubscriptionSchedule> {
            Request(method: "POST", url: path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery, id: "PostSubscriptionSchedulesSchedule")
        }

        public struct PostRequest: Encodable {
            /// Default_settings_params
            ///
            /// Object representing the subscription schedule's default settings.
            public var defaultSettings: DefaultSettings?
            /// Configures how the subscription schedule behaves when it ends. Possible values are `release` or `cancel` with the default being `release`. `release` will end the subscription schedule and keep the underlying subscription running.`cancel` will end the subscription schedule and cancel the underlying subscription.
            public var endBehavior: EndBehavior?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// List representing phases of the subscription schedule. Each phase can be customized to have different durations, plans, and coupons. If there are multiple phases, the `end_date` of one phase will always equal the `start_date` of the next phase. Note that past phases can be omitted.
            public var phases: [Phase]?
            /// If the update changes the current phase, indicates whether the changes should be prorated. The default value is `create_prorations`.
            public var prorationBehavior: ProrationBehavior?

            /// Default_settings_params
            ///
            /// Object representing the subscription schedule's default settings.
            public struct DefaultSettings: Encodable {
                public var applicationFeePercent: Double?
                /// Automatic_tax_config
                public var automaticTax: AutomaticTax?
                public var billingCycleAnchor: BillingCycleAnchor?
                public var billingThresholds: BillingThresholds?
                public var collectionMethod: CollectionMethod?
                public var defaultPaymentMethod: String?
                /// Subscription_schedules_param
                public var invoiceSettings: InvoiceSettings?
                public var transferData: TransferData?

                /// Automatic_tax_config
                public struct AutomaticTax: Encodable {
                    public var isEnabled: Bool

                    public init(isEnabled: Bool) {
                        self.isEnabled = isEnabled
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isEnabled, forKey: "enabled")
                        return encoder.items
                    }
                }

                public enum BillingCycleAnchor: String, Codable, CaseIterable {
                    case automatic
                    case phaseStart = "phase_start"
                }

                public struct BillingThresholds: Encodable {
                    /// Billing_thresholds_param
                    public var a: A?
                    public var b: B?

                    /// Billing_thresholds_param
                    public struct A: Encodable {
                        public var amountGte: Int?
                        public var isResetBillingCycleAnchor: Bool?

                        public init(amountGte: Int? = nil, isResetBillingCycleAnchor: Bool? = nil) {
                            self.amountGte = amountGte
                            self.isResetBillingCycleAnchor = isResetBillingCycleAnchor
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(amountGte, forKey: "amount_gte")
                            encoder.encode(isResetBillingCycleAnchor, forKey: "reset_billing_cycle_anchor")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public enum CollectionMethod: String, Codable, CaseIterable {
                    case chargeAutomatically = "charge_automatically"
                    case sendInvoice = "send_invoice"
                }

                /// Subscription_schedules_param
                public struct InvoiceSettings: Encodable {
                    public var daysUntilDue: Int?

                    public init(daysUntilDue: Int? = nil) {
                        self.daysUntilDue = daysUntilDue
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(daysUntilDue, forKey: "days_until_due")
                        return encoder.items
                    }
                }

                public struct TransferData: Encodable {
                    /// Transfer_data_specs
                    public var a: A?
                    public var b: B?

                    /// Transfer_data_specs
                    public struct A: Encodable {
                        public var amountPercent: Double?
                        public var destination: String

                        public init(amountPercent: Double? = nil, destination: String) {
                            self.amountPercent = amountPercent
                            self.destination = destination
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(amountPercent, forKey: "amount_percent")
                            encoder.encode(destination, forKey: "destination")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public init(applicationFeePercent: Double? = nil, automaticTax: AutomaticTax? = nil, billingCycleAnchor: BillingCycleAnchor? = nil, billingThresholds: BillingThresholds? = nil, collectionMethod: CollectionMethod? = nil, defaultPaymentMethod: String? = nil, invoiceSettings: InvoiceSettings? = nil, transferData: TransferData? = nil) {
                    self.applicationFeePercent = applicationFeePercent
                    self.automaticTax = automaticTax
                    self.billingCycleAnchor = billingCycleAnchor
                    self.billingThresholds = billingThresholds
                    self.collectionMethod = collectionMethod
                    self.defaultPaymentMethod = defaultPaymentMethod
                    self.invoiceSettings = invoiceSettings
                    self.transferData = transferData
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                    encoder.encode(automaticTax, forKey: "automatic_tax")
                    encoder.encode(billingCycleAnchor, forKey: "billing_cycle_anchor")
                    encoder.encode(billingThresholds, forKey: "billing_thresholds")
                    encoder.encode(collectionMethod, forKey: "collection_method")
                    encoder.encode(defaultPaymentMethod, forKey: "default_payment_method")
                    encoder.encode(invoiceSettings, forKey: "invoice_settings")
                    encoder.encode(transferData, forKey: "transfer_data")
                    return encoder.items
                }
            }

            /// Configures how the subscription schedule behaves when it ends. Possible values are `release` or `cancel` with the default being `release`. `release` will end the subscription schedule and keep the underlying subscription running.`cancel` will end the subscription schedule and cancel the underlying subscription.
            public enum EndBehavior: String, Codable, CaseIterable {
                case cancel
                case `none`
                case release
                case renew
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Phase_configuration_params
            public struct Phase: Encodable {
                public var addInvoiceItems: [AddInvoiceItem]?
                public var applicationFeePercent: Double?
                /// Automatic_tax_config
                public var automaticTax: AutomaticTax?
                public var billingCycleAnchor: BillingCycleAnchor?
                public var billingThresholds: BillingThresholds?
                public var collectionMethod: CollectionMethod?
                public var coupon: String?
                public var currency: String?
                public var defaultPaymentMethod: String?
                public var defaultTaxRates: DefaultTaxRates?
                public var endDate: EndDate?
                /// Subscription_schedules_param
                public var invoiceSettings: InvoiceSettings?
                public var items: [Item]
                public var iterations: Int?
                public var metadata: [String: String]?
                public var prorationBehavior: ProrationBehavior?
                public var startDate: StartDate?
                /// Transfer_data_specs
                public var transferData: TransferData?
                public var isTrial: Bool?
                public var trialEnd: TrialEnd?

                /// Add_invoice_item_entry
                public struct AddInvoiceItem: Encodable {
                    public var price: String?
                    /// One_time_price_data
                    public var priceData: PriceData?
                    public var quantity: Int?
                    public var taxRates: TaxRates?

                    /// One_time_price_data
                    public struct PriceData: Encodable {
                        public var currency: String
                        public var product: String
                        public var taxBehavior: TaxBehavior?
                        public var unitAmount: Int?
                        public var unitAmountDecimal: String?

                        public enum TaxBehavior: String, Codable, CaseIterable {
                            case exclusive
                            case inclusive
                            case unspecified
                        }

                        public init(currency: String, product: String, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                            self.currency = currency
                            self.product = product
                            self.taxBehavior = taxBehavior
                            self.unitAmount = unitAmount
                            self.unitAmountDecimal = unitAmountDecimal
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(currency, forKey: "currency")
                            encoder.encode(product, forKey: "product")
                            encoder.encode(taxBehavior, forKey: "tax_behavior")
                            encoder.encode(unitAmount, forKey: "unit_amount")
                            encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                            return encoder.items
                        }
                    }

                    public struct TaxRates: Encodable {
                        public var strings: [String]?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(strings: [String]? = nil, object: Object? = nil) {
                            self.strings = strings
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(strings, forKey: "strings")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                        self.price = price
                        self.priceData = priceData
                        self.quantity = quantity
                        self.taxRates = taxRates
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(price, forKey: "price")
                        encoder.encode(priceData, forKey: "price_data")
                        encoder.encode(quantity, forKey: "quantity")
                        encoder.encode(taxRates, forKey: "tax_rates")
                        return encoder.items
                    }
                }

                /// Automatic_tax_config
                public struct AutomaticTax: Encodable {
                    public var isEnabled: Bool

                    public init(isEnabled: Bool) {
                        self.isEnabled = isEnabled
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isEnabled, forKey: "enabled")
                        return encoder.items
                    }
                }

                public enum BillingCycleAnchor: String, Codable, CaseIterable {
                    case automatic
                    case phaseStart = "phase_start"
                }

                public struct BillingThresholds: Encodable {
                    /// Billing_thresholds_param
                    public var a: A?
                    public var b: B?

                    /// Billing_thresholds_param
                    public struct A: Encodable {
                        public var amountGte: Int?
                        public var isResetBillingCycleAnchor: Bool?

                        public init(amountGte: Int? = nil, isResetBillingCycleAnchor: Bool? = nil) {
                            self.amountGte = amountGte
                            self.isResetBillingCycleAnchor = isResetBillingCycleAnchor
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(amountGte, forKey: "amount_gte")
                            encoder.encode(isResetBillingCycleAnchor, forKey: "reset_billing_cycle_anchor")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public enum CollectionMethod: String, Codable, CaseIterable {
                    case chargeAutomatically = "charge_automatically"
                    case sendInvoice = "send_invoice"
                }

                public struct DefaultTaxRates: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public struct EndDate: Encodable {
                    public var int: Int?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case now
                    }

                    public init(int: Int? = nil, object: Object? = nil) {
                        self.int = int
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(int, forKey: "int")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                /// Subscription_schedules_param
                public struct InvoiceSettings: Encodable {
                    public var daysUntilDue: Int?

                    public init(daysUntilDue: Int? = nil) {
                        self.daysUntilDue = daysUntilDue
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(daysUntilDue, forKey: "days_until_due")
                        return encoder.items
                    }
                }

                /// Configuration_item_params
                public struct Item: Encodable {
                    public var billingThresholds: BillingThresholds?
                    public var price: String?
                    /// Recurring_price_data
                    public var priceData: PriceData?
                    public var quantity: Int?
                    public var taxRates: TaxRates?

                    public struct BillingThresholds: Encodable {
                        /// Item_billing_thresholds_param
                        public var a: A?
                        public var b: B?

                        /// Item_billing_thresholds_param
                        public struct A: Encodable {
                            public var usageGte: Int

                            public init(usageGte: Int) {
                                self.usageGte = usageGte
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(usageGte, forKey: "usage_gte")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    /// Recurring_price_data
                    public struct PriceData: Encodable {
                        public var currency: String
                        public var product: String
                        /// Recurring_adhoc
                        public var recurring: Recurring
                        public var taxBehavior: TaxBehavior?
                        public var unitAmount: Int?
                        public var unitAmountDecimal: String?

                        /// Recurring_adhoc
                        public struct Recurring: Encodable {
                            public var interval: Interval
                            public var intervalCount: Int?

                            public enum Interval: String, Codable, CaseIterable {
                                case day
                                case month
                                case week
                                case year
                            }

                            public init(interval: Interval, intervalCount: Int? = nil) {
                                self.interval = interval
                                self.intervalCount = intervalCount
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(interval, forKey: "interval")
                                encoder.encode(intervalCount, forKey: "interval_count")
                                return encoder.items
                            }
                        }

                        public enum TaxBehavior: String, Codable, CaseIterable {
                            case exclusive
                            case inclusive
                            case unspecified
                        }

                        public init(currency: String, product: String, recurring: Recurring, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                            self.currency = currency
                            self.product = product
                            self.recurring = recurring
                            self.taxBehavior = taxBehavior
                            self.unitAmount = unitAmount
                            self.unitAmountDecimal = unitAmountDecimal
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(currency, forKey: "currency")
                            encoder.encode(product, forKey: "product")
                            encoder.encode(recurring, forKey: "recurring")
                            encoder.encode(taxBehavior, forKey: "tax_behavior")
                            encoder.encode(unitAmount, forKey: "unit_amount")
                            encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                            return encoder.items
                        }
                    }

                    public struct TaxRates: Encodable {
                        public var strings: [String]?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(strings: [String]? = nil, object: Object? = nil) {
                            self.strings = strings
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(strings, forKey: "strings")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(billingThresholds: BillingThresholds? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                        self.billingThresholds = billingThresholds
                        self.price = price
                        self.priceData = priceData
                        self.quantity = quantity
                        self.taxRates = taxRates
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(billingThresholds, forKey: "billing_thresholds")
                        encoder.encode(price, forKey: "price")
                        encoder.encode(priceData, forKey: "price_data")
                        encoder.encode(quantity, forKey: "quantity")
                        encoder.encode(taxRates, forKey: "tax_rates")
                        return encoder.items
                    }
                }

                public enum ProrationBehavior: String, Codable, CaseIterable {
                    case alwaysInvoice = "always_invoice"
                    case createProrations = "create_prorations"
                    case `none`
                }

                public struct StartDate: Encodable {
                    public var int: Int?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case now
                    }

                    public init(int: Int? = nil, object: Object? = nil) {
                        self.int = int
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(int, forKey: "int")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                /// Transfer_data_specs
                public struct TransferData: Encodable {
                    public var amountPercent: Double?
                    public var destination: String

                    public init(amountPercent: Double? = nil, destination: String) {
                        self.amountPercent = amountPercent
                        self.destination = destination
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amountPercent, forKey: "amount_percent")
                        encoder.encode(destination, forKey: "destination")
                        return encoder.items
                    }
                }

                public struct TrialEnd: Encodable {
                    public var int: Int?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case now
                    }

                    public init(int: Int? = nil, object: Object? = nil) {
                        self.int = int
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(int, forKey: "int")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(addInvoiceItems: [AddInvoiceItem]? = nil, applicationFeePercent: Double? = nil, automaticTax: AutomaticTax? = nil, billingCycleAnchor: BillingCycleAnchor? = nil, billingThresholds: BillingThresholds? = nil, collectionMethod: CollectionMethod? = nil, coupon: String? = nil, currency: String? = nil, defaultPaymentMethod: String? = nil, defaultTaxRates: DefaultTaxRates? = nil, endDate: EndDate? = nil, invoiceSettings: InvoiceSettings? = nil, items: [Item], iterations: Int? = nil, metadata: [String: String]? = nil, prorationBehavior: ProrationBehavior? = nil, startDate: StartDate? = nil, transferData: TransferData? = nil, isTrial: Bool? = nil, trialEnd: TrialEnd? = nil) {
                    self.addInvoiceItems = addInvoiceItems
                    self.applicationFeePercent = applicationFeePercent
                    self.automaticTax = automaticTax
                    self.billingCycleAnchor = billingCycleAnchor
                    self.billingThresholds = billingThresholds
                    self.collectionMethod = collectionMethod
                    self.coupon = coupon
                    self.currency = currency
                    self.defaultPaymentMethod = defaultPaymentMethod
                    self.defaultTaxRates = defaultTaxRates
                    self.endDate = endDate
                    self.invoiceSettings = invoiceSettings
                    self.items = items
                    self.iterations = iterations
                    self.metadata = metadata
                    self.prorationBehavior = prorationBehavior
                    self.startDate = startDate
                    self.transferData = transferData
                    self.isTrial = isTrial
                    self.trialEnd = trialEnd
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(addInvoiceItems, forKey: "add_invoice_items")
                    encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                    encoder.encode(automaticTax, forKey: "automatic_tax")
                    encoder.encode(billingCycleAnchor, forKey: "billing_cycle_anchor")
                    encoder.encode(billingThresholds, forKey: "billing_thresholds")
                    encoder.encode(collectionMethod, forKey: "collection_method")
                    encoder.encode(coupon, forKey: "coupon")
                    encoder.encode(currency, forKey: "currency")
                    encoder.encode(defaultPaymentMethod, forKey: "default_payment_method")
                    encoder.encode(defaultTaxRates, forKey: "default_tax_rates")
                    encoder.encode(endDate, forKey: "end_date")
                    encoder.encode(invoiceSettings, forKey: "invoice_settings")
                    encoder.encode(items, forKey: "items")
                    encoder.encode(iterations, forKey: "iterations")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(prorationBehavior, forKey: "proration_behavior")
                    encoder.encode(startDate, forKey: "start_date")
                    encoder.encode(transferData, forKey: "transfer_data")
                    encoder.encode(isTrial, forKey: "trial")
                    encoder.encode(trialEnd, forKey: "trial_end")
                    return encoder.items
                }
            }

            /// If the update changes the current phase, indicates whether the changes should be prorated. The default value is `create_prorations`.
            public enum ProrationBehavior: String, Codable, CaseIterable {
                case alwaysInvoice = "always_invoice"
                case createProrations = "create_prorations"
                case `none`
            }

            public init(defaultSettings: DefaultSettings? = nil, endBehavior: EndBehavior? = nil, expand: [String]? = nil, metadata: Metadata? = nil, phases: [Phase]? = nil, prorationBehavior: ProrationBehavior? = nil) {
                self.defaultSettings = defaultSettings
                self.endBehavior = endBehavior
                self.expand = expand
                self.metadata = metadata
                self.phases = phases
                self.prorationBehavior = prorationBehavior
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(defaultSettings, forKey: "default_settings")
                encoder.encode(endBehavior, forKey: "end_behavior")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(phases, forKey: "phases")
                encoder.encode(prorationBehavior, forKey: "proration_behavior")
                return encoder.items
            }
        }
    }
}
