// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var invoiceitems: Invoiceitems {
        Invoiceitems(path: "/v1/invoiceitems")
    }

    public struct Invoiceitems {
        /// Path: `/v1/invoiceitems`
        public let path: String

        /// <p>Returns a list of your invoice items. Invoice items are returned sorted by creation date, with the most recently created invoice items appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            Request(method: "GET", url: path, query: parameters?.asQuery, id: "GetInvoiceitems")
        }

        /// InvoicesItemsList
        public struct GetResponse: Decodable {
            public var data: [StripeKit.Invoiceitem]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeKit.Invoiceitem], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.data = try values.decode([StripeKit.Invoiceitem].self, forKey: "data")
                self.hasMore = try values.decode(Bool.self, forKey: "has_more")
                self.object = try values.decode(Object.self, forKey: "object")
                self.url = try values.decode(String.self, forKey: "url")
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var customer: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var invoice: String?
            public var limit: Int?
            public var isPending: Bool?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, customer: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, invoice: String? = nil, limit: Int? = nil, isPending: Bool? = nil, startingAfter: String? = nil) {
                self.created = created
                self.customer = customer
                self.endingBefore = endingBefore
                self.expand = expand
                self.invoice = invoice
                self.limit = limit
                self.isPending = isPending
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(customer, forKey: "customer")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(invoice, forKey: "invoice")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(isPending, forKey: "pending")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates an item to be added to a draft invoice (up to 250 items per invoice). If no invoice is specified, the item will be on the next invoice created for the customer specified.</p>
        public func post(_ body: PostRequest) -> Request<StripeKit.Invoiceitem> {
            Request(method: "POST", url: path, body: URLQueryEncoder.encode(body).percentEncodedQuery, id: "PostInvoiceitems")
        }

        public struct PostRequest: Encodable {
            /// The integer amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. Passing in a negative `amount` will reduce the `amount_due` on the invoice.
            public var amount: Int?
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
            public var currency: String?
            /// The ID of the customer who will be billed when this invoice item is billed.
            public var customer: String
            /// An arbitrary string which you can attach to the invoice item. The description is displayed in the invoice for easy tracking.
            public var description: String?
            /// Controls whether discounts apply to this invoice item. Defaults to false for prorations or negative invoice items, and true for all other invoice items.
            public var isDiscountable: Bool?
            /// The coupons to redeem into discounts for the invoice item or invoice line item.
            public var discounts: Discounts?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The ID of an existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming scheduled invoice. This is useful when adding invoice items in response to an invoice.created webhook. You can only add invoice items to draft invoices and there is a maximum of 250 items per invoice.
            public var invoice: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The period associated with this invoice item. When set to different values, the period will be rendered on the invoice.
            public var period: Period?
            /// The ID of the price object.
            public var price: String?
            /// One_time_price_data
            ///
            /// Data used to generate a new [Price](https://stripe.com/docs/api/prices) object inline.
            public var priceData: PriceData?
            /// Non-negative integer. The quantity of units for the invoice item.
            public var quantity: Int?
            /// The ID of a subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming scheduled invoice. When set, scheduled invoices for subscriptions other than the specified subscription will ignore the invoice item. Use this when you want to express that an invoice item has been accrued within the context of a particular subscription.
            public var subscription: String?
            /// The tax rates which apply to the invoice item. When set, the `default_tax_rates` on the invoice do not apply to this invoice item.
            public var taxRates: [String]?
            /// The integer unit amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. This `unit_amount` will be multiplied by the quantity to get the full amount. Passing in a negative `unit_amount` will reduce the `amount_due` on the invoice.
            public var unitAmount: Int?
            /// Same as `unit_amount`, but accepts a decimal value in cents (or local equivalent) with at most 12 decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
            public var unitAmountDecimal: String?

            /// The coupons to redeem into discounts for the invoice item or invoice line item.
            public struct Discounts: Encodable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Discounts_data_param
                public struct PlaceholderItem: Encodable {
                    public var coupon: String?
                    public var discount: String?

                    public init(coupon: String? = nil, discount: String? = nil) {
                        self.coupon = coupon
                        self.discount = discount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(coupon, forKey: "coupon")
                        encoder.encode(discount, forKey: "discount")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The period associated with this invoice item. When set to different values, the period will be rendered on the invoice.
            public struct Period: Encodable {
                public var end: Int
                public var start: Int

                public init(end: Int, start: Int) {
                    self.end = end
                    self.start = start
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(end, forKey: "end")
                    encoder.encode(start, forKey: "start")
                    return encoder.items
                }
            }

            /// One_time_price_data
            ///
            /// Data used to generate a new [Price](https://stripe.com/docs/api/prices) object inline.
            public struct PriceData: Encodable {
                public var currency: String
                public var product: String
                public var taxBehavior: TaxBehavior?
                public var unitAmount: Int?
                public var unitAmountDecimal: String?

                public enum TaxBehavior: String, Codable, CaseIterable {
                    case exclusive
                    case inclusive
                    case unspecified
                }

                public init(currency: String, product: String, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                    self.currency = currency
                    self.product = product
                    self.taxBehavior = taxBehavior
                    self.unitAmount = unitAmount
                    self.unitAmountDecimal = unitAmountDecimal
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(currency, forKey: "currency")
                    encoder.encode(product, forKey: "product")
                    encoder.encode(taxBehavior, forKey: "tax_behavior")
                    encoder.encode(unitAmount, forKey: "unit_amount")
                    encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                    return encoder.items
                }
            }

            public init(amount: Int? = nil, currency: String? = nil, customer: String, description: String? = nil, isDiscountable: Bool? = nil, discounts: Discounts? = nil, expand: [String]? = nil, invoice: String? = nil, metadata: Metadata? = nil, period: Period? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, subscription: String? = nil, taxRates: [String]? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                self.amount = amount
                self.currency = currency
                self.customer = customer
                self.description = description
                self.isDiscountable = isDiscountable
                self.discounts = discounts
                self.expand = expand
                self.invoice = invoice
                self.metadata = metadata
                self.period = period
                self.price = price
                self.priceData = priceData
                self.quantity = quantity
                self.subscription = subscription
                self.taxRates = taxRates
                self.unitAmount = unitAmount
                self.unitAmountDecimal = unitAmountDecimal
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(description, forKey: "description")
                encoder.encode(isDiscountable, forKey: "discountable")
                encoder.encode(discounts, forKey: "discounts")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(invoice, forKey: "invoice")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(period, forKey: "period")
                encoder.encode(price, forKey: "price")
                encoder.encode(priceData, forKey: "price_data")
                encoder.encode(quantity, forKey: "quantity")
                encoder.encode(subscription, forKey: "subscription")
                encoder.encode(taxRates, forKey: "tax_rates")
                encoder.encode(unitAmount, forKey: "unit_amount")
                encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                return encoder.items
            }
        }
    }
}
