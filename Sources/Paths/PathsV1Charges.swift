// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var charges: Charges {
        Charges(path: "/v1/charges")
    }

    public struct Charges {
        /// Path: `/v1/charges`
        public let path: String

        /// <p>Returns a list of charges you’ve previously created. The charges are returned in sorted order, with the most recent charges appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            Request(method: "GET", url: path, query: parameters?.asQuery, id: "GetCharges")
        }

        /// ChargeList
        public struct GetResponse: Decodable {
            public var data: [StripeKit.Charge]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeKit.Charge], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.data = try values.decode([StripeKit.Charge].self, forKey: "data")
                self.hasMore = try values.decode(Bool.self, forKey: "has_more")
                self.object = try values.decode(Object.self, forKey: "object")
                self.url = try values.decode(String.self, forKey: "url")
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var customer: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var paymentIntent: String?
            public var startingAfter: String?
            public var transferGroup: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, customer: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, paymentIntent: String? = nil, startingAfter: String? = nil, transferGroup: String? = nil) {
                self.created = created
                self.customer = customer
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.paymentIntent = paymentIntent
                self.startingAfter = startingAfter
                self.transferGroup = transferGroup
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(customer, forKey: "customer")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(paymentIntent, forKey: "payment_intent")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(transferGroup, forKey: "transfer_group")
                return encoder.items
            }
        }

        /// <p>To charge a credit card or other payment source, you create a <code>Charge</code> object. If your API key is in test mode, the supplied payment source (e.g., card) won’t actually be charged, although everything else will occur as if in live mode. (Stripe assumes that the charge would have completed successfully).</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeKit.Charge> {
            Request(method: "POST", url: path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery, id: "PostCharges")
        }

        public struct PostRequest: Encodable {
            /// Amount intended to be collected by this payment. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
            public var amount: Int?
            public var applicationFee: Int?
            /// A fee in cents (or local equivalent) that will be applied to the charge and transferred to the application owner's Stripe account. The request must be made with an OAuth key or the `Stripe-Account` header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/connect/direct-charges#collecting-fees).
            public var applicationFeeAmount: Int?
            /// Whether to immediately capture the charge. Defaults to `true`. When `false`, the charge issues an authorization (or pre-authorization), and will need to be [captured](https://stripe.com/docs/api#capture_charge) later. Uncaptured charges expire after a set number of days (7 by default). For more information, see the [authorizing charges and settling later](https://stripe.com/docs/charges/placing-a-hold) documentation.
            public var isCapture: Bool?
            /// A token, like the ones returned by [Stripe.js](https://stripe.com/docs/js).
            public var card: Card?
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
            public var currency: String?
            /// The ID of an existing customer that will be charged in this request.
            public var customer: String?
            /// An arbitrary string which you can attach to a `Charge` object. It is displayed when in the web interface alongside the charge. Note that if you use Stripe to send automatic email receipts to your customers, your receipt emails will include the `description` of the charge(s) that they are describing.
            public var description: String?
            public var destination: Destination?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The Stripe account ID for which these funds are intended. Automatically set if you use the `destination` parameter. For details, see [Creating Separate Charges and Transfers](https://stripe.com/docs/connect/charges-transfers#on-behalf-of).
            public var onBehalfOf: String?
            /// Radar_options
            ///
            /// Options to configure Radar. See [Radar Session](https://stripe.com/docs/radar/radar-session) for more information.
            public var radarOptions: RadarOptions?
            /// The email address to which this charge's [receipt](https://stripe.com/docs/dashboard/receipts) will be sent. The receipt will not be sent until the charge is paid, and no receipts will be sent for test mode charges. If this charge is for a [Customer](https://stripe.com/docs/api/customers/object), the email address specified here will override the customer's email address. If `receipt_email` is specified for a charge in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
            public var receiptEmail: String?
            /// Optional_fields_shipping
            ///
            /// Shipping information for the charge. Helps prevent fraud on charges for physical goods.
            public var shipping: Shipping?
            /// A payment source to be charged. This can be the ID of a [card](https://stripe.com/docs/api#cards) (i.e., credit or debit card), a [bank account](https://stripe.com/docs/api#bank_accounts), a [source](https://stripe.com/docs/api#sources), a [token](https://stripe.com/docs/api#tokens), or a [connected account](https://stripe.com/docs/connect/account-debits#charging-a-connected-account). For certain sources---namely, [cards](https://stripe.com/docs/api#cards), [bank accounts](https://stripe.com/docs/api#bank_accounts), and attached [sources](https://stripe.com/docs/api#sources)---you must also pass the ID of the associated customer.
            public var source: String?
            /// For card charges, use `statement_descriptor_suffix` instead. Otherwise, you can use this value as the complete description of a charge on your customers’ statements. Must contain at least one letter, maximum 22 characters.
            public var statementDescriptor: String?
            /// Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
            public var statementDescriptorSuffix: String?
            /// Transfer_data_specs
            ///
            /// An optional dictionary including the account to automatically transfer to as part of a destination charge. [See the Connect documentation](https://stripe.com/docs/connect/destination-charges) for details.
            public var transferData: TransferData?
            /// A string that identifies this transaction as part of a group. For details, see [Grouping transactions](https://stripe.com/docs/connect/charges-transfers#transfer-options).
            public var transferGroup: String?

            /// A token, like the ones returned by [Stripe.js](https://stripe.com/docs/js).
            public struct Card: Encodable {
                /// Customer_payment_source_card
                public var object: Object?
                public var string: String?

                /// Customer_payment_source_card
                public struct Object: Encodable {
                    public var addressCity: String?
                    public var addressCountry: String?
                    public var addressLine1: String?
                    public var addressLine2: String?
                    public var addressState: String?
                    public var addressZip: String?
                    public var cvc: String?
                    public var expMonth: Int
                    public var expYear: Int
                    public var metadata: [String: String]?
                    public var name: String?
                    public var number: String
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case card
                    }

                    public init(addressCity: String? = nil, addressCountry: String? = nil, addressLine1: String? = nil, addressLine2: String? = nil, addressState: String? = nil, addressZip: String? = nil, cvc: String? = nil, expMonth: Int, expYear: Int, metadata: [String: String]? = nil, name: String? = nil, number: String, object: Object? = nil) {
                        self.addressCity = addressCity
                        self.addressCountry = addressCountry
                        self.addressLine1 = addressLine1
                        self.addressLine2 = addressLine2
                        self.addressState = addressState
                        self.addressZip = addressZip
                        self.cvc = cvc
                        self.expMonth = expMonth
                        self.expYear = expYear
                        self.metadata = metadata
                        self.name = name
                        self.number = number
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(addressCity, forKey: "address_city")
                        encoder.encode(addressCountry, forKey: "address_country")
                        encoder.encode(addressLine1, forKey: "address_line1")
                        encoder.encode(addressLine2, forKey: "address_line2")
                        encoder.encode(addressState, forKey: "address_state")
                        encoder.encode(addressZip, forKey: "address_zip")
                        encoder.encode(cvc, forKey: "cvc")
                        encoder.encode(expMonth, forKey: "exp_month")
                        encoder.encode(expYear, forKey: "exp_year")
                        encoder.encode(metadata, forKey: "metadata")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(number, forKey: "number")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            public struct Destination: Encodable {
                /// Destination_specs
                public var object: Object?
                public var string: String?

                /// Destination_specs
                public struct Object: Encodable {
                    public var account: String
                    public var amount: Int?

                    public init(account: String, amount: Int? = nil) {
                        self.account = account
                        self.amount = amount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(account, forKey: "account")
                        encoder.encode(amount, forKey: "amount")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Radar_options
            ///
            /// Options to configure Radar. See [Radar Session](https://stripe.com/docs/radar/radar-session) for more information.
            public struct RadarOptions: Encodable {
                public var session: String?

                public init(session: String? = nil) {
                    self.session = session
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(session, forKey: "session")
                    return encoder.items
                }
            }

            /// Optional_fields_shipping
            ///
            /// Shipping information for the charge. Helps prevent fraud on charges for physical goods.
            public struct Shipping: Encodable {
                /// Optional_fields_address
                public var address: Address
                public var carrier: String?
                public var name: String
                public var phone: String?
                public var trackingNumber: String?

                /// Optional_fields_address
                public struct Address: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                public init(address: Address, carrier: String? = nil, name: String, phone: String? = nil, trackingNumber: String? = nil) {
                    self.address = address
                    self.carrier = carrier
                    self.name = name
                    self.phone = phone
                    self.trackingNumber = trackingNumber
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(carrier, forKey: "carrier")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(phone, forKey: "phone")
                    encoder.encode(trackingNumber, forKey: "tracking_number")
                    return encoder.items
                }
            }

            /// Transfer_data_specs
            ///
            /// An optional dictionary including the account to automatically transfer to as part of a destination charge. [See the Connect documentation](https://stripe.com/docs/connect/destination-charges) for details.
            public struct TransferData: Encodable {
                public var amount: Int?
                public var destination: String

                public init(amount: Int? = nil, destination: String) {
                    self.amount = amount
                    self.destination = destination
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    encoder.encode(destination, forKey: "destination")
                    return encoder.items
                }
            }

            public init(amount: Int? = nil, applicationFee: Int? = nil, applicationFeeAmount: Int? = nil, isCapture: Bool? = nil, card: Card? = nil, currency: String? = nil, customer: String? = nil, description: String? = nil, destination: Destination? = nil, expand: [String]? = nil, metadata: Metadata? = nil, onBehalfOf: String? = nil, radarOptions: RadarOptions? = nil, receiptEmail: String? = nil, shipping: Shipping? = nil, source: String? = nil, statementDescriptor: String? = nil, statementDescriptorSuffix: String? = nil, transferData: TransferData? = nil, transferGroup: String? = nil) {
                self.amount = amount
                self.applicationFee = applicationFee
                self.applicationFeeAmount = applicationFeeAmount
                self.isCapture = isCapture
                self.card = card
                self.currency = currency
                self.customer = customer
                self.description = description
                self.destination = destination
                self.expand = expand
                self.metadata = metadata
                self.onBehalfOf = onBehalfOf
                self.radarOptions = radarOptions
                self.receiptEmail = receiptEmail
                self.shipping = shipping
                self.source = source
                self.statementDescriptor = statementDescriptor
                self.statementDescriptorSuffix = statementDescriptorSuffix
                self.transferData = transferData
                self.transferGroup = transferGroup
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(applicationFee, forKey: "application_fee")
                encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                encoder.encode(isCapture, forKey: "capture")
                encoder.encode(card, forKey: "card")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(description, forKey: "description")
                encoder.encode(destination, forKey: "destination")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(onBehalfOf, forKey: "on_behalf_of")
                encoder.encode(radarOptions, forKey: "radar_options")
                encoder.encode(receiptEmail, forKey: "receipt_email")
                encoder.encode(shipping, forKey: "shipping")
                encoder.encode(source, forKey: "source")
                encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                encoder.encode(statementDescriptorSuffix, forKey: "statement_descriptor_suffix")
                encoder.encode(transferData, forKey: "transfer_data")
                encoder.encode(transferGroup, forKey: "transfer_group")
                return encoder.items
            }
        }
    }
}
