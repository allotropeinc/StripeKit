// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths.Quotes {
    public func quote(_ quote: String) -> WithQuote {
        WithQuote(path: "\(path)/\(quote)")
    }

    public struct WithQuote {
        /// Path: `/v1/quotes/{quote}`
        public let path: String

        /// <p>Retrieves the quote with the given ID.</p>
        public func get(expand: [String]? = nil) -> Request<StripeKit.Quote> {
            Request(method: "GET", url: path, query: makeGetQuery(expand), id: "GetQuotesQuote")
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>A quote models prices and services for a customer.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeKit.Quote> {
            Request(method: "POST", url: path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery, id: "PostQuotesQuote")
        }

        public struct PostRequest: Encodable {
            /// The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. There cannot be any line items with recurring prices when using this field.
            public var applicationFeeAmount: ApplicationFeeAmount?
            /// A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. There must be at least 1 line item with a recurring price to use this field.
            public var applicationFeePercent: ApplicationFeePercent?
            /// Automatic_tax_param
            ///
            /// Settings for automatic tax lookup for this quote and resulting invoices and subscriptions.
            public var automaticTax: AutomaticTax?
            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or at invoice finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
            public var collectionMethod: CollectionMethod?
            /// The customer for which this quote belongs to. A customer is required before finalizing the quote. Once specified, it cannot be changed.
            public var customer: String?
            /// The tax rates that will apply to any line item that does not have `tax_rates` set.
            public var defaultTaxRates: DefaultTaxRates?
            /// A description that will be displayed on the quote PDF.
            public var description: String?
            /// The discounts applied to the quote. You can only set up to one discount.
            public var discounts: Discounts?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// A future timestamp on which the quote will be canceled if in `open` or `draft` status. Measured in seconds since the Unix epoch.
            public var expiresAt: Int?
            /// A footer that will be displayed on the quote PDF.
            public var footer: String?
            /// A header that will be displayed on the quote PDF.
            public var header: String?
            /// Quote_param
            ///
            /// All invoices will be billed using the specified settings.
            public var invoiceSettings: InvoiceSettings?
            /// A list of line items the customer is being quoted for. Each line item includes information about the product, the quantity, and the resulting cost.
            public var lineItems: [LineItem]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// The account on behalf of which to charge.
            public var onBehalfOf: OnBehalfOf?
            /// Subscription_data_update_params
            ///
            /// When creating a subscription or subscription schedule, the specified configuration data will be used. There must be at least one line item with a recurring price for a subscription or subscription schedule to be created. A subscription schedule is created if `subscription_data[effective_date]` is present and in the future, otherwise a subscription is created.
            public var subscriptionData: SubscriptionData?
            /// The data with which to automatically create a Transfer for each of the invoices.
            public var transferData: TransferData?

            /// The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. There cannot be any line items with recurring prices when using this field.
            public struct ApplicationFeeAmount: Encodable {
                public var int: Int?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(int: Int? = nil, object: Object? = nil) {
                    self.int = int
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(int, forKey: "int")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. There must be at least 1 line item with a recurring price to use this field.
            public struct ApplicationFeePercent: Encodable {
                public var double: Double?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(double: Double? = nil, object: Object? = nil) {
                    self.double = double
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(double, forKey: "double")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Automatic_tax_param
            ///
            /// Settings for automatic tax lookup for this quote and resulting invoices and subscriptions.
            public struct AutomaticTax: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or at invoice finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
            public enum CollectionMethod: String, Codable, CaseIterable {
                case chargeAutomatically = "charge_automatically"
                case sendInvoice = "send_invoice"
            }

            /// The tax rates that will apply to any line item that does not have `tax_rates` set.
            public struct DefaultTaxRates: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The discounts applied to the quote. You can only set up to one discount.
            public struct Discounts: Encodable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Discounts_data_param
                public struct PlaceholderItem: Encodable {
                    public var coupon: String?
                    public var discount: String?

                    public init(coupon: String? = nil, discount: String? = nil) {
                        self.coupon = coupon
                        self.discount = discount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(coupon, forKey: "coupon")
                        encoder.encode(discount, forKey: "discount")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Quote_param
            ///
            /// All invoices will be billed using the specified settings.
            public struct InvoiceSettings: Encodable {
                public var daysUntilDue: Int?

                public init(daysUntilDue: Int? = nil) {
                    self.daysUntilDue = daysUntilDue
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(daysUntilDue, forKey: "days_until_due")
                    return encoder.items
                }
            }

            /// Line_item_update_params
            public struct LineItem: Encodable {
                public var id: String?
                public var price: String?
                /// Price_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: TaxRates?

                /// Price_data
                public struct PriceData: Encodable {
                    public var currency: String
                    public var product: String
                    /// Recurring_adhoc
                    public var recurring: Recurring?
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    /// Recurring_adhoc
                    public struct Recurring: Encodable {
                        public var interval: Interval
                        public var intervalCount: Int?

                        public enum Interval: String, Codable, CaseIterable {
                            case day
                            case month
                            case week
                            case year
                        }

                        public init(interval: Interval, intervalCount: Int? = nil) {
                            self.interval = interval
                            self.intervalCount = intervalCount
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(interval, forKey: "interval")
                            encoder.encode(intervalCount, forKey: "interval_count")
                            return encoder.items
                        }
                    }

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String, recurring: Recurring? = nil, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.recurring = recurring
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(recurring, forKey: "recurring")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public struct TaxRates: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(id: String? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                    self.id = id
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(id, forKey: "id")
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    return encoder.items
                }
            }

            /// The account on behalf of which to charge.
            public struct OnBehalfOf: Encodable {
                public var string: String?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(string: String? = nil, object: Object? = nil) {
                    self.string = string
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(string, forKey: "string")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Subscription_data_update_params
            ///
            /// When creating a subscription or subscription schedule, the specified configuration data will be used. There must be at least one line item with a recurring price for a subscription or subscription schedule to be created. A subscription schedule is created if `subscription_data[effective_date]` is present and in the future, otherwise a subscription is created.
            public struct SubscriptionData: Encodable {
                public var effectiveDate: EffectiveDate?
                public var trialPeriodDays: TrialPeriodDays?

                public struct EffectiveDate: Encodable {
                    public var object1: Object1?
                    public var int: Int?
                    public var object2: Object2?

                    public enum Object1: String, Codable, CaseIterable {
                        case currentPeriodEnd = "current_period_end"
                    }

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object1: Object1? = nil, int: Int? = nil, object2: Object2? = nil) {
                        self.object1 = object1
                        self.int = int
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object1, forKey: "object1")
                        encoder.encode(int, forKey: "int")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct TrialPeriodDays: Encodable {
                    public var int: Int?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(int: Int? = nil, object: Object? = nil) {
                        self.int = int
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(int, forKey: "int")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(effectiveDate: EffectiveDate? = nil, trialPeriodDays: TrialPeriodDays? = nil) {
                    self.effectiveDate = effectiveDate
                    self.trialPeriodDays = trialPeriodDays
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(effectiveDate, forKey: "effective_date")
                    encoder.encode(trialPeriodDays, forKey: "trial_period_days")
                    return encoder.items
                }
            }

            /// The data with which to automatically create a Transfer for each of the invoices.
            public struct TransferData: Encodable {
                /// Transfer_data_specs
                public var a: A?
                public var b: B?

                /// Transfer_data_specs
                public struct A: Encodable {
                    public var amount: Int?
                    public var amountPercent: Double?
                    public var destination: String

                    public init(amount: Int? = nil, amountPercent: Double? = nil, destination: String) {
                        self.amount = amount
                        self.amountPercent = amountPercent
                        self.destination = destination
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amount, forKey: "amount")
                        encoder.encode(amountPercent, forKey: "amount_percent")
                        encoder.encode(destination, forKey: "destination")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            public init(applicationFeeAmount: ApplicationFeeAmount? = nil, applicationFeePercent: ApplicationFeePercent? = nil, automaticTax: AutomaticTax? = nil, collectionMethod: CollectionMethod? = nil, customer: String? = nil, defaultTaxRates: DefaultTaxRates? = nil, description: String? = nil, discounts: Discounts? = nil, expand: [String]? = nil, expiresAt: Int? = nil, footer: String? = nil, header: String? = nil, invoiceSettings: InvoiceSettings? = nil, lineItems: [LineItem]? = nil, metadata: [String: String]? = nil, onBehalfOf: OnBehalfOf? = nil, subscriptionData: SubscriptionData? = nil, transferData: TransferData? = nil) {
                self.applicationFeeAmount = applicationFeeAmount
                self.applicationFeePercent = applicationFeePercent
                self.automaticTax = automaticTax
                self.collectionMethod = collectionMethod
                self.customer = customer
                self.defaultTaxRates = defaultTaxRates
                self.description = description
                self.discounts = discounts
                self.expand = expand
                self.expiresAt = expiresAt
                self.footer = footer
                self.header = header
                self.invoiceSettings = invoiceSettings
                self.lineItems = lineItems
                self.metadata = metadata
                self.onBehalfOf = onBehalfOf
                self.subscriptionData = subscriptionData
                self.transferData = transferData
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                encoder.encode(automaticTax, forKey: "automatic_tax")
                encoder.encode(collectionMethod, forKey: "collection_method")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(defaultTaxRates, forKey: "default_tax_rates")
                encoder.encode(description, forKey: "description")
                encoder.encode(discounts, forKey: "discounts")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(expiresAt, forKey: "expires_at")
                encoder.encode(footer, forKey: "footer")
                encoder.encode(header, forKey: "header")
                encoder.encode(invoiceSettings, forKey: "invoice_settings")
                encoder.encode(lineItems, forKey: "line_items")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(onBehalfOf, forKey: "on_behalf_of")
                encoder.encode(subscriptionData, forKey: "subscription_data")
                encoder.encode(transferData, forKey: "transfer_data")
                return encoder.items
            }
        }
    }
}
