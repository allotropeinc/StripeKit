// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths.PaymentIntents {
    public func intent(_ intent: String) -> WithIntent {
        WithIntent(path: "\(path)/\(intent)")
    }

    public struct WithIntent {
        /// Path: `/v1/payment_intents/{intent}`
        public let path: String

        /// <p>Retrieves the details of a PaymentIntent that has previously been created. </p>
        /// 
        /// <p>Client-side retrieval using a publishable key is allowed when the <code>client_secret</code> is provided in the query string. </p>
        /// 
        /// <p>When retrieved with a publishable key, only a subset of properties will be returned. Please refer to the <a href="#payment_intent_object">payment intent</a> object reference for more details.</p>
        public func get(clientSecret: String? = nil, expand: [String]? = nil) -> Request<StripeKit.PaymentIntent> {
            Request(method: "GET", url: path, query: makeGetQuery(clientSecret, expand), id: "GetPaymentIntentsIntent")
        }

        private func makeGetQuery(_ clientSecret: String?, _ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(clientSecret, forKey: "client_secret")
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates properties on a PaymentIntent object without confirming.</p>
        /// 
        /// <p>Depending on which properties you update, you may need to confirm the
        /// PaymentIntent again. For example, updating the <code>payment_method</code> will
        /// always require you to confirm the PaymentIntent again. If you prefer to
        /// update and confirm at the same time, we recommend updating properties via
        /// the <a href="/docs/api/payment_intents/confirm">confirm API</a> instead.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeKit.PaymentIntent> {
            Request(method: "POST", url: path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery, id: "PostPaymentIntentsIntent")
        }

        public struct PostRequest: Encodable {
            /// Amount intended to be collected by this PaymentIntent. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
            public var amount: Int?
            /// The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
            public var applicationFeeAmount: ApplicationFeeAmount?
            /// Controls when the funds will be captured from the customer's account.
            public var captureMethod: CaptureMethod?
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
            public var currency: String?
            /// ID of the Customer this PaymentIntent belongs to, if one exists.
            /// 
            /// Payment methods attached to other Customers cannot be used with this PaymentIntent.
            /// 
            /// If present in combination with [setup_future_usage](https://stripe.com/docs/api#payment_intent_object-setup_future_usage), this PaymentIntent's payment method will be attached to the Customer after the PaymentIntent has been confirmed and any required actions from the user are complete.
            public var customer: String?
            /// An arbitrary string attached to the object. Often useful for displaying to users.
            public var description: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// ID of the payment method (a PaymentMethod, Card, or [compatible Source](https://stripe.com/docs/payments/payment-methods/transitioning#compatibility) object) to attach to this PaymentIntent.
            public var paymentMethod: String?
            /// Payment_method_data_params
            ///
            /// If provided, this hash will be used to create a PaymentMethod. The new PaymentMethod will appear
            /// in the [payment_method](https://stripe.com/docs/api/payment_intents/object#payment_intent_object-payment_method)
            /// property on the PaymentIntent.
            public var paymentMethodData: PaymentMethodData?
            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration for this PaymentIntent.
            public var paymentMethodOptions: PaymentMethodOptions?
            /// The list of payment method types (e.g. card) that this PaymentIntent is allowed to use. Use automatic_payment_methods to manage payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods).
            public var paymentMethodTypes: [String]?
            /// Email address that the receipt for the resulting payment will be sent to. If `receipt_email` is specified for a payment in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
            public var receiptEmail: ReceiptEmail?
            /// Indicates that you intend to make future payments with this PaymentIntent's payment method.
            /// 
            /// Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.
            /// 
            /// When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).
            /// 
            /// If `setup_future_usage` is already set and you are performing a request using a publishable key, you may only update the value from `on_session` to `off_session`.
            public var setupFutureUsage: SetupFutureUsage?
            /// Shipping information for this PaymentIntent.
            public var shipping: Shipping?
            /// For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
            public var statementDescriptor: String?
            /// Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
            public var statementDescriptorSuffix: String?
            /// Transfer_data_update_params
            ///
            /// The parameters used to automatically create a Transfer when the payment succeeds. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
            public var transferData: TransferData?
            /// A string that identifies the resulting payment as part of a group. `transfer_group` may only be provided if it has not been set. See the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts) for details.
            public var transferGroup: String?

            /// The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
            public struct ApplicationFeeAmount: Encodable {
                public var int: Int?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(int: Int? = nil, object: Object? = nil) {
                    self.int = int
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(int, forKey: "int")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Controls when the funds will be captured from the customer's account.
            public enum CaptureMethod: String, Codable, CaseIterable {
                case automatic
                case manual
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Payment_method_data_params
            ///
            /// If provided, this hash will be used to create a PaymentMethod. The new PaymentMethod will appear
            /// in the [payment_method](https://stripe.com/docs/api/payment_intents/object#payment_intent_object-payment_method)
            /// property on the PaymentIntent.
            public struct PaymentMethodData: Encodable {
                /// Payment_method_param
                public var acssDebit: AcssDebit?
                /// Param
                public var affirm: [String: AnyJSON]?
                /// Param
                public var afterpayClearpay: [String: AnyJSON]?
                /// Param
                public var alipay: [String: AnyJSON]?
                /// Param
                public var auBecsDebit: AuBecsDebit?
                /// Param
                public var bacsDebit: BacsDebit?
                /// Param
                public var bancontact: [String: AnyJSON]?
                /// Billing_details_inner_params
                public var billingDetails: BillingDetails?
                /// Param
                public var blik: [String: AnyJSON]?
                /// Param
                public var boleto: Boleto?
                /// Param
                public var customerBalance: [String: AnyJSON]?
                /// Param
                public var eps: Eps?
                /// Param
                public var fpx: Fpx?
                /// Param
                public var giropay: [String: AnyJSON]?
                /// Param
                public var grabpay: [String: AnyJSON]?
                /// Param
                public var ideal: Ideal?
                /// Param
                public var interacPresent: [String: AnyJSON]?
                /// Param
                public var klarna: Klarna?
                /// Param
                public var konbini: [String: AnyJSON]?
                /// Param
                public var link: [String: AnyJSON]?
                public var metadata: [String: String]?
                /// Param
                public var oxxo: [String: AnyJSON]?
                /// Param
                public var p24: P24?
                /// Param
                public var paynow: [String: AnyJSON]?
                /// Param
                public var promptpay: [String: AnyJSON]?
                /// Radar_options
                public var radarOptions: RadarOptions?
                /// Param
                public var sepaDebit: SepaDebit?
                /// Param
                public var sofort: Sofort?
                public var type: `Type`
                /// Payment_method_param
                public var usBankAccount: UsBankAccount?
                /// Param
                public var wechatPay: [String: AnyJSON]?

                /// Payment_method_param
                public struct AcssDebit: Encodable {
                    public var accountNumber: String
                    public var institutionNumber: String
                    public var transitNumber: String

                    public init(accountNumber: String, institutionNumber: String, transitNumber: String) {
                        self.accountNumber = accountNumber
                        self.institutionNumber = institutionNumber
                        self.transitNumber = transitNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(institutionNumber, forKey: "institution_number")
                        encoder.encode(transitNumber, forKey: "transit_number")
                        return encoder.items
                    }
                }

                /// Param
                public struct AuBecsDebit: Encodable {
                    public var accountNumber: String
                    public var bsbNumber: String

                    public init(accountNumber: String, bsbNumber: String) {
                        self.accountNumber = accountNumber
                        self.bsbNumber = bsbNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(bsbNumber, forKey: "bsb_number")
                        return encoder.items
                    }
                }

                /// Param
                public struct BacsDebit: Encodable {
                    public var accountNumber: String?
                    public var sortCode: String?

                    public init(accountNumber: String? = nil, sortCode: String? = nil) {
                        self.accountNumber = accountNumber
                        self.sortCode = sortCode
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(sortCode, forKey: "sort_code")
                        return encoder.items
                    }
                }

                /// Billing_details_inner_params
                public struct BillingDetails: Encodable {
                    public var address: Address?
                    public var email: Email?
                    public var name: String?
                    public var phone: String?

                    public struct Address: Encodable {
                        /// Billing_details_address
                        public var a: A?
                        public var b: B?

                        /// Billing_details_address
                        public struct A: Encodable {
                            public var city: String?
                            public var country: String?
                            public var line1: String?
                            public var line2: String?
                            public var postalCode: String?
                            public var state: String?

                            public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                                self.city = city
                                self.country = country
                                self.line1 = line1
                                self.line2 = line2
                                self.postalCode = postalCode
                                self.state = state
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(city, forKey: "city")
                                encoder.encode(country, forKey: "country")
                                encoder.encode(line1, forKey: "line1")
                                encoder.encode(line2, forKey: "line2")
                                encoder.encode(postalCode, forKey: "postal_code")
                                encoder.encode(state, forKey: "state")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Email: Encodable {
                        public var string: String?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(string: String? = nil, object: Object? = nil) {
                            self.string = string
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(string, forKey: "string")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(address: Address? = nil, email: Email? = nil, name: String? = nil, phone: String? = nil) {
                        self.address = address
                        self.email = email
                        self.name = name
                        self.phone = phone
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(address, forKey: "address")
                        encoder.encode(email, forKey: "email")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(phone, forKey: "phone")
                        return encoder.items
                    }
                }

                /// Param
                public struct Boleto: Encodable {
                    public var taxID: String

                    public init(taxID: String) {
                        self.taxID = taxID
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(taxID, forKey: "tax_id")
                        return encoder.items
                    }
                }

                /// Param
                public struct Eps: Encodable {
                    public var bank: Bank?

                    public enum Bank: String, Codable, CaseIterable {
                        case arzteUndApothekerBank = "arzte_und_apotheker_bank"
                        case austrianAnadiBankAg = "austrian_anadi_bank_ag"
                        case bankAustria = "bank_austria"
                        case bankhausCarlSpangler = "bankhaus_carl_spangler"
                        case bankhausSchelhammerUndSchatteraAg = "bankhaus_schelhammer_und_schattera_ag"
                        case bawagPskAg = "bawag_psk_ag"
                        case bksBankAg = "bks_bank_ag"
                        case brullKallmusBankAg = "brull_kallmus_bank_ag"
                        case btvVierLanderBank = "btv_vier_lander_bank"
                        case capitalBankGraweGruppeAg = "capital_bank_grawe_gruppe_ag"
                        case dolomitenbank
                        case easybankAg = "easybank_ag"
                        case ersteBankUndSparkassen = "erste_bank_und_sparkassen"
                        case hypoAlpeadriabankInternationalAg = "hypo_alpeadriabank_international_ag"
                        case hypoBankBurgenlandAktiengesellschaft = "hypo_bank_burgenland_aktiengesellschaft"
                        case hypoNoeLbFurNiederosterreichUWien = "hypo_noe_lb_fur_niederosterreich_u_wien"
                        case hypoOberosterreichSalzburgSteiermark = "hypo_oberosterreich_salzburg_steiermark"
                        case hypoTirolBankAg = "hypo_tirol_bank_ag"
                        case hypoVorarlbergBankAg = "hypo_vorarlberg_bank_ag"
                        case marchfelderBank = "marchfelder_bank"
                        case oberbankAg = "oberbank_ag"
                        case raiffeisenBankengruppeOsterreich = "raiffeisen_bankengruppe_osterreich"
                        case schoellerbankAg = "schoellerbank_ag"
                        case spardaBankWien = "sparda_bank_wien"
                        case volksbankGruppe = "volksbank_gruppe"
                        case volkskreditbankAg = "volkskreditbank_ag"
                        case vrBankBraunau = "vr_bank_braunau"
                    }

                    public init(bank: Bank? = nil) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Param
                public struct Fpx: Encodable {
                    public var bank: Bank

                    public enum Bank: String, Codable, CaseIterable {
                        case affinBank = "affin_bank"
                        case agrobank
                        case allianceBank = "alliance_bank"
                        case ambank
                        case bankIslam = "bank_islam"
                        case bankMuamalat = "bank_muamalat"
                        case bankRakyat = "bank_rakyat"
                        case bsn
                        case cimb
                        case deutscheBank = "deutsche_bank"
                        case hongLeongBank = "hong_leong_bank"
                        case hsbc
                        case kfh
                        case maybank2e
                        case maybank2u
                        case ocbc
                        case pbEnterprise = "pb_enterprise"
                        case publicBank = "public_bank"
                        case rhb
                        case standardChartered = "standard_chartered"
                        case uob
                    }

                    public init(bank: Bank) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Param
                public struct Ideal: Encodable {
                    public var bank: Bank?

                    public enum Bank: String, Codable, CaseIterable {
                        case abnAmro = "abn_amro"
                        case asnBank = "asn_bank"
                        case bunq
                        case handelsbanken
                        case ing
                        case knab
                        case moneyou
                        case rabobank
                        case regiobank
                        case revolut
                        case snsBank = "sns_bank"
                        case triodosBank = "triodos_bank"
                        case vanLanschot = "van_lanschot"
                    }

                    public init(bank: Bank? = nil) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Param
                public struct Klarna: Encodable {
                    /// Date_of_birth
                    public var dob: Dob?

                    /// Date_of_birth
                    public struct Dob: Encodable {
                        public var day: Int
                        public var month: Int
                        public var year: Int

                        public init(day: Int, month: Int, year: Int) {
                            self.day = day
                            self.month = month
                            self.year = year
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(day, forKey: "day")
                            encoder.encode(month, forKey: "month")
                            encoder.encode(year, forKey: "year")
                            return encoder.items
                        }
                    }

                    public init(dob: Dob? = nil) {
                        self.dob = dob
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(dob, forKey: "dob")
                        return encoder.items
                    }
                }

                /// Param
                public struct P24: Encodable {
                    public var bank: Bank?

                    public enum Bank: String, Codable, CaseIterable {
                        case aliorBank = "alior_bank"
                        case bankMillennium = "bank_millennium"
                        case bankNowyBfgSa = "bank_nowy_bfg_sa"
                        case bankPekaoSa = "bank_pekao_sa"
                        case bankiSpbdzielcze = "banki_spbdzielcze"
                        case blik
                        case bnpParibas = "bnp_paribas"
                        case boz
                        case citiHandlowy = "citi_handlowy"
                        case creditAgricole = "credit_agricole"
                        case envelobank
                        case etransferPocztowy24 = "etransfer_pocztowy24"
                        case getinBank = "getin_bank"
                        case ideabank
                        case ing
                        case inteligo
                        case mbankMtransfer = "mbank_mtransfer"
                        case nestPrzelew = "nest_przelew"
                        case noblePay = "noble_pay"
                        case pbacZIpko = "pbac_z_ipko"
                        case plusBank = "plus_bank"
                        case santanderPrzelew24 = "santander_przelew24"
                        case tmobileUsbugiBankowe = "tmobile_usbugi_bankowe"
                        case toyotaBank = "toyota_bank"
                        case volkswagenBank = "volkswagen_bank"
                    }

                    public init(bank: Bank? = nil) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Radar_options
                public struct RadarOptions: Encodable {
                    public var session: String?

                    public init(session: String? = nil) {
                        self.session = session
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(session, forKey: "session")
                        return encoder.items
                    }
                }

                /// Param
                public struct SepaDebit: Encodable {
                    public var iban: String

                    public init(iban: String) {
                        self.iban = iban
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(iban, forKey: "iban")
                        return encoder.items
                    }
                }

                /// Param
                public struct Sofort: Encodable {
                    public var country: Country

                    public enum Country: String, Codable, CaseIterable {
                        case at = "AT"
                        case be = "BE"
                        case de = "DE"
                        case es = "ES"
                        case it = "IT"
                        case nl = "NL"
                    }

                    public init(country: Country) {
                        self.country = country
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(country, forKey: "country")
                        return encoder.items
                    }
                }

                public enum `Type`: String, Codable, CaseIterable {
                    case acssDebit = "acss_debit"
                    case affirm
                    case afterpayClearpay = "afterpay_clearpay"
                    case alipay
                    case auBecsDebit = "au_becs_debit"
                    case bacsDebit = "bacs_debit"
                    case bancontact
                    case blik
                    case boleto
                    case customerBalance = "customer_balance"
                    case eps
                    case fpx
                    case giropay
                    case grabpay
                    case ideal
                    case klarna
                    case konbini
                    case link
                    case oxxo
                    case p24
                    case paynow
                    case promptpay
                    case sepaDebit = "sepa_debit"
                    case sofort
                    case usBankAccount = "us_bank_account"
                    case wechatPay = "wechat_pay"
                }

                /// Payment_method_param
                public struct UsBankAccount: Encodable {
                    public var accountHolderType: AccountHolderType?
                    public var accountNumber: String?
                    public var accountType: AccountType?
                    public var financialConnectionsAccount: String?
                    public var routingNumber: String?

                    public enum AccountHolderType: String, Codable, CaseIterable {
                        case company
                        case individual
                    }

                    public enum AccountType: String, Codable, CaseIterable {
                        case checking
                        case savings
                    }

                    public init(accountHolderType: AccountHolderType? = nil, accountNumber: String? = nil, accountType: AccountType? = nil, financialConnectionsAccount: String? = nil, routingNumber: String? = nil) {
                        self.accountHolderType = accountHolderType
                        self.accountNumber = accountNumber
                        self.accountType = accountType
                        self.financialConnectionsAccount = financialConnectionsAccount
                        self.routingNumber = routingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountHolderType, forKey: "account_holder_type")
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(accountType, forKey: "account_type")
                        encoder.encode(financialConnectionsAccount, forKey: "financial_connections_account")
                        encoder.encode(routingNumber, forKey: "routing_number")
                        return encoder.items
                    }
                }

                public init(acssDebit: AcssDebit? = nil, affirm: [String: AnyJSON]? = nil, afterpayClearpay: [String: AnyJSON]? = nil, alipay: [String: AnyJSON]? = nil, auBecsDebit: AuBecsDebit? = nil, bacsDebit: BacsDebit? = nil, bancontact: [String: AnyJSON]? = nil, billingDetails: BillingDetails? = nil, blik: [String: AnyJSON]? = nil, boleto: Boleto? = nil, customerBalance: [String: AnyJSON]? = nil, eps: Eps? = nil, fpx: Fpx? = nil, giropay: [String: AnyJSON]? = nil, grabpay: [String: AnyJSON]? = nil, ideal: Ideal? = nil, interacPresent: [String: AnyJSON]? = nil, klarna: Klarna? = nil, konbini: [String: AnyJSON]? = nil, link: [String: AnyJSON]? = nil, metadata: [String: String]? = nil, oxxo: [String: AnyJSON]? = nil, p24: P24? = nil, paynow: [String: AnyJSON]? = nil, promptpay: [String: AnyJSON]? = nil, radarOptions: RadarOptions? = nil, sepaDebit: SepaDebit? = nil, sofort: Sofort? = nil, type: `Type`, usBankAccount: UsBankAccount? = nil, wechatPay: [String: AnyJSON]? = nil) {
                    self.acssDebit = acssDebit
                    self.affirm = affirm
                    self.afterpayClearpay = afterpayClearpay
                    self.alipay = alipay
                    self.auBecsDebit = auBecsDebit
                    self.bacsDebit = bacsDebit
                    self.bancontact = bancontact
                    self.billingDetails = billingDetails
                    self.blik = blik
                    self.boleto = boleto
                    self.customerBalance = customerBalance
                    self.eps = eps
                    self.fpx = fpx
                    self.giropay = giropay
                    self.grabpay = grabpay
                    self.ideal = ideal
                    self.interacPresent = interacPresent
                    self.klarna = klarna
                    self.konbini = konbini
                    self.link = link
                    self.metadata = metadata
                    self.oxxo = oxxo
                    self.p24 = p24
                    self.paynow = paynow
                    self.promptpay = promptpay
                    self.radarOptions = radarOptions
                    self.sepaDebit = sepaDebit
                    self.sofort = sofort
                    self.type = type
                    self.usBankAccount = usBankAccount
                    self.wechatPay = wechatPay
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acssDebit, forKey: "acss_debit")
                    encoder.encode(affirm, forKey: "affirm")
                    encoder.encode(afterpayClearpay, forKey: "afterpay_clearpay")
                    encoder.encode(alipay, forKey: "alipay")
                    encoder.encode(auBecsDebit, forKey: "au_becs_debit")
                    encoder.encode(bacsDebit, forKey: "bacs_debit")
                    encoder.encode(bancontact, forKey: "bancontact")
                    encoder.encode(billingDetails, forKey: "billing_details")
                    encoder.encode(blik, forKey: "blik")
                    encoder.encode(boleto, forKey: "boleto")
                    encoder.encode(customerBalance, forKey: "customer_balance")
                    encoder.encode(eps, forKey: "eps")
                    encoder.encode(fpx, forKey: "fpx")
                    encoder.encode(giropay, forKey: "giropay")
                    encoder.encode(grabpay, forKey: "grabpay")
                    encoder.encode(ideal, forKey: "ideal")
                    encoder.encode(interacPresent, forKey: "interac_present")
                    encoder.encode(klarna, forKey: "klarna")
                    encoder.encode(konbini, forKey: "konbini")
                    encoder.encode(link, forKey: "link")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(oxxo, forKey: "oxxo")
                    encoder.encode(p24, forKey: "p24")
                    encoder.encode(paynow, forKey: "paynow")
                    encoder.encode(promptpay, forKey: "promptpay")
                    encoder.encode(radarOptions, forKey: "radar_options")
                    encoder.encode(sepaDebit, forKey: "sepa_debit")
                    encoder.encode(sofort, forKey: "sofort")
                    encoder.encode(type, forKey: "type")
                    encoder.encode(usBankAccount, forKey: "us_bank_account")
                    encoder.encode(wechatPay, forKey: "wechat_pay")
                    return encoder.items
                }
            }

            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration for this PaymentIntent.
            public struct PaymentMethodOptions: Encodable {
                public var acssDebit: AcssDebit?
                public var affirm: Affirm?
                public var afterpayClearpay: AfterpayClearpay?
                public var alipay: Alipay?
                public var auBecsDebit: AuBecsDebit?
                public var bacsDebit: BacsDebit?
                public var bancontact: Bancontact?
                public var blik: Blik?
                public var boleto: Boleto?
                public var card: Card?
                public var cardPresent: CardPresent?
                public var customerBalance: CustomerBalance?
                public var eps: Eps?
                public var fpx: Fpx?
                public var giropay: Giropay?
                public var grabpay: Grabpay?
                public var ideal: Ideal?
                public var interacPresent: InteracPresent?
                public var klarna: Klarna?
                public var konbini: Konbini?
                public var link: Link?
                public var oxxo: Oxxo?
                public var p24: P24?
                public var paynow: Paynow?
                public var promptpay: Promptpay?
                public var sepaDebit: SepaDebit?
                public var sofort: Sofort?
                public var usBankAccount: UsBankAccount?
                public var wechatPay: WechatPay?

                public struct AcssDebit: Encodable {
                    /// Payment_intent_payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_intent_payment_method_options_param
                    public struct A: Encodable {
                        /// Payment_intent_payment_method_options_mandate_options_param
                        public var mandateOptions: MandateOptions?
                        public var setupFutureUsage: SetupFutureUsage?
                        public var verificationMethod: VerificationMethod?

                        /// Payment_intent_payment_method_options_mandate_options_param
                        public struct MandateOptions: Encodable {
                            public var customMandateURL: CustomMandateURL?
                            public var intervalDescription: String?
                            public var paymentSchedule: PaymentSchedule?
                            public var transactionType: TransactionType?

                            public struct CustomMandateURL: Encodable {
                                public var string: String?
                                public var object: Object?

                                public enum Object: String, Codable, CaseIterable {
                                    case empty = ""
                                }

                                public init(string: String? = nil, object: Object? = nil) {
                                    self.string = string
                                    self.object = object
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(string, forKey: "string")
                                    encoder.encode(object, forKey: "object")
                                    return encoder.items
                                }
                            }

                            public enum PaymentSchedule: String, Codable, CaseIterable {
                                case combined
                                case interval
                                case sporadic
                            }

                            public enum TransactionType: String, Codable, CaseIterable {
                                case business
                                case personal
                            }

                            public init(customMandateURL: CustomMandateURL? = nil, intervalDescription: String? = nil, paymentSchedule: PaymentSchedule? = nil, transactionType: TransactionType? = nil) {
                                self.customMandateURL = customMandateURL
                                self.intervalDescription = intervalDescription
                                self.paymentSchedule = paymentSchedule
                                self.transactionType = transactionType
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(customMandateURL, forKey: "custom_mandate_url")
                                encoder.encode(intervalDescription, forKey: "interval_description")
                                encoder.encode(paymentSchedule, forKey: "payment_schedule")
                                encoder.encode(transactionType, forKey: "transaction_type")
                                return encoder.items
                            }
                        }

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case empty = ""
                            case `none`
                            case offSession = "off_session"
                            case onSession = "on_session"
                        }

                        public enum VerificationMethod: String, Codable, CaseIterable {
                            case automatic
                            case instant
                            case microdeposits
                        }

                        public init(mandateOptions: MandateOptions? = nil, setupFutureUsage: SetupFutureUsage? = nil, verificationMethod: VerificationMethod? = nil) {
                            self.mandateOptions = mandateOptions
                            self.setupFutureUsage = setupFutureUsage
                            self.verificationMethod = verificationMethod
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(mandateOptions, forKey: "mandate_options")
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            encoder.encode(verificationMethod, forKey: "verification_method")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Affirm: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var captureMethod: CaptureMethod?
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum CaptureMethod: String, Codable, CaseIterable {
                            case empty = ""
                            case manual
                        }

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case `none`
                        }

                        public init(captureMethod: CaptureMethod? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                            self.captureMethod = captureMethod
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(captureMethod, forKey: "capture_method")
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct AfterpayClearpay: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var captureMethod: CaptureMethod?
                        public var reference: String?
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum CaptureMethod: String, Codable, CaseIterable {
                            case empty = ""
                            case manual
                        }

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case `none`
                        }

                        public init(captureMethod: CaptureMethod? = nil, reference: String? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                            self.captureMethod = captureMethod
                            self.reference = reference
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(captureMethod, forKey: "capture_method")
                            encoder.encode(reference, forKey: "reference")
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Alipay: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case empty = ""
                            case `none`
                            case offSession = "off_session"
                        }

                        public init(setupFutureUsage: SetupFutureUsage? = nil) {
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct AuBecsDebit: Encodable {
                    /// Payment_intent_payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_intent_payment_method_options_param
                    public struct A: Encodable {
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case empty = ""
                            case `none`
                            case offSession = "off_session"
                            case onSession = "on_session"
                        }

                        public init(setupFutureUsage: SetupFutureUsage? = nil) {
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct BacsDebit: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case empty = ""
                            case `none`
                            case offSession = "off_session"
                            case onSession = "on_session"
                        }

                        public init(setupFutureUsage: SetupFutureUsage? = nil) {
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Bancontact: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var preferredLanguage: PreferredLanguage?
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum PreferredLanguage: String, Codable, CaseIterable {
                            case de
                            case en
                            case fr
                            case nl
                        }

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case empty = ""
                            case `none`
                            case offSession = "off_session"
                        }

                        public init(preferredLanguage: PreferredLanguage? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                            self.preferredLanguage = preferredLanguage
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(preferredLanguage, forKey: "preferred_language")
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Blik: Encodable {
                    /// Payment_intent_payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_intent_payment_method_options_param
                    public struct A: Encodable {
                        public var code: String?

                        public init(code: String? = nil) {
                            self.code = code
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(code, forKey: "code")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Boleto: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var expiresAfterDays: Int?
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case empty = ""
                            case `none`
                            case offSession = "off_session"
                            case onSession = "on_session"
                        }

                        public init(expiresAfterDays: Int? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                            self.expiresAfterDays = expiresAfterDays
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(expiresAfterDays, forKey: "expires_after_days")
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Card: Encodable {
                    /// Payment_intent_param
                    public var a: A?
                    public var b: B?

                    /// Payment_intent_param
                    public struct A: Encodable {
                        public var captureMethod: CaptureMethod?
                        public var cvcToken: String?
                        /// Installments_param
                        public var installments: Installments?
                        /// Mandate_options_param
                        public var mandateOptions: MandateOptions?
                        public var network: Network?
                        public var requestThreeDSecure: RequestThreeDSecure?
                        public var setupFutureUsage: SetupFutureUsage?
                        public var statementDescriptorSuffixKana: StatementDescriptorSuffixKana?
                        public var statementDescriptorSuffixKanji: StatementDescriptorSuffixKanji?

                        public enum CaptureMethod: String, Codable, CaseIterable {
                            case empty = ""
                            case manual
                        }

                        /// Installments_param
                        public struct Installments: Encodable {
                            public var isEnabled: Bool?
                            public var plan: Plan?

                            public struct Plan: Encodable {
                                /// Installment_plan
                                public var a: A?
                                public var b: B?

                                /// Installment_plan
                                public struct A: Encodable {
                                    public var count: Int
                                    public var interval: Interval
                                    public var type: `Type`

                                    public enum Interval: String, Codable, CaseIterable {
                                        case month
                                    }

                                    public enum `Type`: String, Codable, CaseIterable {
                                        case fixedCount = "fixed_count"
                                    }

                                    public init(count: Int, interval: Interval, type: `Type`) {
                                        self.count = count
                                        self.interval = interval
                                        self.type = type
                                    }

                                    public var asQuery: [(String, String?)] {
                                        let encoder = URLQueryEncoder()
                                        encoder.encode(count, forKey: "count")
                                        encoder.encode(interval, forKey: "interval")
                                        encoder.encode(type, forKey: "type")
                                        return encoder.items
                                    }
                                }

                                public enum B: String, Codable, CaseIterable {
                                    case empty = ""
                                }

                                public init(a: A? = nil, b: B? = nil) {
                                    self.a = a
                                    self.b = b
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(a, forKey: "a")
                                    encoder.encode(b, forKey: "b")
                                    return encoder.items
                                }
                            }

                            public init(isEnabled: Bool? = nil, plan: Plan? = nil) {
                                self.isEnabled = isEnabled
                                self.plan = plan
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(isEnabled, forKey: "enabled")
                                encoder.encode(plan, forKey: "plan")
                                return encoder.items
                            }
                        }

                        /// Mandate_options_param
                        public struct MandateOptions: Encodable {
                            public var amount: Int
                            public var amountType: AmountType
                            public var description: String?
                            public var endDate: Int?
                            public var interval: Interval
                            public var intervalCount: Int?
                            public var reference: String
                            public var startDate: Int
                            public var supportedTypes: [SupportedType]?

                            public enum AmountType: String, Codable, CaseIterable {
                                case fixed
                                case maximum
                            }

                            public enum Interval: String, Codable, CaseIterable {
                                case day
                                case month
                                case sporadic
                                case week
                                case year
                            }

                            public enum SupportedType: String, Codable, CaseIterable {
                                case india
                            }

                            public init(amount: Int, amountType: AmountType, description: String? = nil, endDate: Int? = nil, interval: Interval, intervalCount: Int? = nil, reference: String, startDate: Int, supportedTypes: [SupportedType]? = nil) {
                                self.amount = amount
                                self.amountType = amountType
                                self.description = description
                                self.endDate = endDate
                                self.interval = interval
                                self.intervalCount = intervalCount
                                self.reference = reference
                                self.startDate = startDate
                                self.supportedTypes = supportedTypes
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(amount, forKey: "amount")
                                encoder.encode(amountType, forKey: "amount_type")
                                encoder.encode(description, forKey: "description")
                                encoder.encode(endDate, forKey: "end_date")
                                encoder.encode(interval, forKey: "interval")
                                encoder.encode(intervalCount, forKey: "interval_count")
                                encoder.encode(reference, forKey: "reference")
                                encoder.encode(startDate, forKey: "start_date")
                                encoder.encode(supportedTypes, forKey: "supported_types")
                                return encoder.items
                            }
                        }

                        public enum Network: String, Codable, CaseIterable {
                            case amex
                            case cartesBancaires = "cartes_bancaires"
                            case diners
                            case discover
                            case interac
                            case jcb
                            case mastercard
                            case unionpay
                            case unknown
                            case visa
                        }

                        public enum RequestThreeDSecure: String, Codable, CaseIterable {
                            case any
                            case automatic
                        }

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case empty = ""
                            case `none`
                            case offSession = "off_session"
                            case onSession = "on_session"
                        }

                        public struct StatementDescriptorSuffixKana: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct StatementDescriptorSuffixKanji: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public init(captureMethod: CaptureMethod? = nil, cvcToken: String? = nil, installments: Installments? = nil, mandateOptions: MandateOptions? = nil, network: Network? = nil, requestThreeDSecure: RequestThreeDSecure? = nil, setupFutureUsage: SetupFutureUsage? = nil, statementDescriptorSuffixKana: StatementDescriptorSuffixKana? = nil, statementDescriptorSuffixKanji: StatementDescriptorSuffixKanji? = nil) {
                            self.captureMethod = captureMethod
                            self.cvcToken = cvcToken
                            self.installments = installments
                            self.mandateOptions = mandateOptions
                            self.network = network
                            self.requestThreeDSecure = requestThreeDSecure
                            self.setupFutureUsage = setupFutureUsage
                            self.statementDescriptorSuffixKana = statementDescriptorSuffixKana
                            self.statementDescriptorSuffixKanji = statementDescriptorSuffixKanji
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(captureMethod, forKey: "capture_method")
                            encoder.encode(cvcToken, forKey: "cvc_token")
                            encoder.encode(installments, forKey: "installments")
                            encoder.encode(mandateOptions, forKey: "mandate_options")
                            encoder.encode(network, forKey: "network")
                            encoder.encode(requestThreeDSecure, forKey: "request_three_d_secure")
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            encoder.encode(statementDescriptorSuffixKana, forKey: "statement_descriptor_suffix_kana")
                            encoder.encode(statementDescriptorSuffixKanji, forKey: "statement_descriptor_suffix_kanji")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct CardPresent: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var isRequestExtendedAuthorization: Bool?
                        public var isRequestIncrementalAuthorizationSupport: Bool?

                        public init(isRequestExtendedAuthorization: Bool? = nil, isRequestIncrementalAuthorizationSupport: Bool? = nil) {
                            self.isRequestExtendedAuthorization = isRequestExtendedAuthorization
                            self.isRequestIncrementalAuthorizationSupport = isRequestIncrementalAuthorizationSupport
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(isRequestExtendedAuthorization, forKey: "request_extended_authorization")
                            encoder.encode(isRequestIncrementalAuthorizationSupport, forKey: "request_incremental_authorization_support")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct CustomerBalance: Encodable {
                    /// Payment_intent_payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_intent_payment_method_options_param
                    public struct A: Encodable {
                        /// Bank_transfer_param
                        public var bankTransfer: BankTransfer?
                        public var fundingType: FundingType?
                        public var setupFutureUsage: SetupFutureUsage?

                        /// Bank_transfer_param
                        public struct BankTransfer: Encodable {
                            /// Eu_bank_transfer_params
                            public var euBankTransfer: EuBankTransfer?
                            public var requestedAddressTypes: [RequestedAddressType]?
                            public var type: `Type`

                            /// Eu_bank_transfer_params
                            public struct EuBankTransfer: Encodable {
                                public var country: String

                                public init(country: String) {
                                    self.country = country
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(country, forKey: "country")
                                    return encoder.items
                                }
                            }

                            public enum RequestedAddressType: String, Codable, CaseIterable {
                                case iban
                                case sepa
                                case sortCode = "sort_code"
                                case spei
                                case zengin
                            }

                            public enum `Type`: String, Codable, CaseIterable {
                                case euBankTransfer = "eu_bank_transfer"
                                case gbBankTransfer = "gb_bank_transfer"
                                case jpBankTransfer = "jp_bank_transfer"
                                case mxBankTransfer = "mx_bank_transfer"
                            }

                            public init(euBankTransfer: EuBankTransfer? = nil, requestedAddressTypes: [RequestedAddressType]? = nil, type: `Type`) {
                                self.euBankTransfer = euBankTransfer
                                self.requestedAddressTypes = requestedAddressTypes
                                self.type = type
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(euBankTransfer, forKey: "eu_bank_transfer")
                                encoder.encode(requestedAddressTypes, forKey: "requested_address_types")
                                encoder.encode(type, forKey: "type")
                                return encoder.items
                            }
                        }

                        public enum FundingType: String, Codable, CaseIterable {
                            case bankTransfer = "bank_transfer"
                        }

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case `none`
                        }

                        public init(bankTransfer: BankTransfer? = nil, fundingType: FundingType? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                            self.bankTransfer = bankTransfer
                            self.fundingType = fundingType
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(bankTransfer, forKey: "bank_transfer")
                            encoder.encode(fundingType, forKey: "funding_type")
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Eps: Encodable {
                    /// Payment_intent_payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_intent_payment_method_options_param
                    public struct A: Encodable {
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case `none`
                        }

                        public init(setupFutureUsage: SetupFutureUsage? = nil) {
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Fpx: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case `none`
                        }

                        public init(setupFutureUsage: SetupFutureUsage? = nil) {
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Giropay: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case `none`
                        }

                        public init(setupFutureUsage: SetupFutureUsage? = nil) {
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Grabpay: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case `none`
                        }

                        public init(setupFutureUsage: SetupFutureUsage? = nil) {
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Ideal: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case empty = ""
                            case `none`
                            case offSession = "off_session"
                        }

                        public init(setupFutureUsage: SetupFutureUsage? = nil) {
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct InteracPresent: Encodable {
                    /// Payment_method_options_param
                    public var object: [String: AnyJSON]?
                    public var object2: Object2?

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object: [String: AnyJSON]? = nil, object2: Object2? = nil) {
                        self.object = object
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct Klarna: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var captureMethod: CaptureMethod?
                        public var preferredLocale: PreferredLocale?
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum CaptureMethod: String, Codable, CaseIterable {
                            case empty = ""
                            case manual
                        }

                        public enum PreferredLocale: String, Codable, CaseIterable {
                            case daDK = "da-DK"
                            case deAT = "de-AT"
                            case deDE = "de-DE"
                            case enAT = "en-AT"
                            case enAU = "en-AU"
                            case enBE = "en-BE"
                            case enCA = "en-CA"
                            case enDE = "en-DE"
                            case enDK = "en-DK"
                            case enES = "en-ES"
                            case enFI = "en-FI"
                            case enFR = "en-FR"
                            case enGB = "en-GB"
                            case enIE = "en-IE"
                            case enIT = "en-IT"
                            case enNL = "en-NL"
                            case enNO = "en-NO"
                            case enNZ = "en-NZ"
                            case enSE = "en-SE"
                            case enUS = "en-US"
                            case esES = "es-ES"
                            case esUS = "es-US"
                            case fiFI = "fi-FI"
                            case frBE = "fr-BE"
                            case frCA = "fr-CA"
                            case frFR = "fr-FR"
                            case itIT = "it-IT"
                            case nbNO = "nb-NO"
                            case nlBE = "nl-BE"
                            case nlNL = "nl-NL"
                            case svFI = "sv-FI"
                            case svSE = "sv-SE"
                        }

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case `none`
                        }

                        public init(captureMethod: CaptureMethod? = nil, preferredLocale: PreferredLocale? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                            self.captureMethod = captureMethod
                            self.preferredLocale = preferredLocale
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(captureMethod, forKey: "capture_method")
                            encoder.encode(preferredLocale, forKey: "preferred_locale")
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Konbini: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var confirmationNumber: String?
                        public var expiresAfterDays: ExpiresAfterDays?
                        public var expiresAt: ExpiresAt?
                        public var productDescription: String?
                        public var setupFutureUsage: SetupFutureUsage?

                        public struct ExpiresAfterDays: Encodable {
                            public var int: Int?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(int: Int? = nil, object: Object? = nil) {
                                self.int = int
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(int, forKey: "int")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct ExpiresAt: Encodable {
                            public var int: Int?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(int: Int? = nil, object: Object? = nil) {
                                self.int = int
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(int, forKey: "int")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case `none`
                        }

                        public init(confirmationNumber: String? = nil, expiresAfterDays: ExpiresAfterDays? = nil, expiresAt: ExpiresAt? = nil, productDescription: String? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                            self.confirmationNumber = confirmationNumber
                            self.expiresAfterDays = expiresAfterDays
                            self.expiresAt = expiresAt
                            self.productDescription = productDescription
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(confirmationNumber, forKey: "confirmation_number")
                            encoder.encode(expiresAfterDays, forKey: "expires_after_days")
                            encoder.encode(expiresAt, forKey: "expires_at")
                            encoder.encode(productDescription, forKey: "product_description")
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Link: Encodable {
                    /// Payment_intent_payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_intent_payment_method_options_param
                    public struct A: Encodable {
                        public var captureMethod: CaptureMethod?
                        public var persistentToken: String?
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum CaptureMethod: String, Codable, CaseIterable {
                            case empty = ""
                            case manual
                        }

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case empty = ""
                            case `none`
                            case offSession = "off_session"
                        }

                        public init(captureMethod: CaptureMethod? = nil, persistentToken: String? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                            self.captureMethod = captureMethod
                            self.persistentToken = persistentToken
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(captureMethod, forKey: "capture_method")
                            encoder.encode(persistentToken, forKey: "persistent_token")
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Oxxo: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var expiresAfterDays: Int?
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case `none`
                        }

                        public init(expiresAfterDays: Int? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                            self.expiresAfterDays = expiresAfterDays
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(expiresAfterDays, forKey: "expires_after_days")
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct P24: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var setupFutureUsage: SetupFutureUsage?
                        public var isTosShownAndAccepted: Bool?

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case `none`
                        }

                        public init(setupFutureUsage: SetupFutureUsage? = nil, isTosShownAndAccepted: Bool? = nil) {
                            self.setupFutureUsage = setupFutureUsage
                            self.isTosShownAndAccepted = isTosShownAndAccepted
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            encoder.encode(isTosShownAndAccepted, forKey: "tos_shown_and_accepted")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Paynow: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case `none`
                        }

                        public init(setupFutureUsage: SetupFutureUsage? = nil) {
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Promptpay: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case `none`
                        }

                        public init(setupFutureUsage: SetupFutureUsage? = nil) {
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct SepaDebit: Encodable {
                    /// Payment_intent_payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_intent_payment_method_options_param
                    public struct A: Encodable {
                        /// Payment_method_options_mandate_options_param
                        public var mandateOptions: [String: AnyJSON]?
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case empty = ""
                            case `none`
                            case offSession = "off_session"
                            case onSession = "on_session"
                        }

                        public init(mandateOptions: [String: AnyJSON]? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                            self.mandateOptions = mandateOptions
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(mandateOptions, forKey: "mandate_options")
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Sofort: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var preferredLanguage: PreferredLanguage?
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum PreferredLanguage: String, Codable, CaseIterable {
                            case empty = ""
                            case de
                            case en
                            case es
                            case fr
                            case it
                            case nl
                            case pl
                        }

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case empty = ""
                            case `none`
                            case offSession = "off_session"
                        }

                        public init(preferredLanguage: PreferredLanguage? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                            self.preferredLanguage = preferredLanguage
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(preferredLanguage, forKey: "preferred_language")
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct UsBankAccount: Encodable {
                    /// Payment_intent_payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_intent_payment_method_options_param
                    public struct A: Encodable {
                        /// Linked_account_options_param
                        public var financialConnections: FinancialConnections?
                        /// Networks_options_param
                        public var networks: Networks?
                        public var setupFutureUsage: SetupFutureUsage?
                        public var verificationMethod: VerificationMethod?

                        /// Linked_account_options_param
                        public struct FinancialConnections: Encodable {
                            public var permissions: [Permission]?
                            public var returnURL: String?

                            public enum Permission: String, Codable, CaseIterable {
                                case balances
                                case ownership
                                case paymentMethod = "payment_method"
                                case transactions
                            }

                            public init(permissions: [Permission]? = nil, returnURL: String? = nil) {
                                self.permissions = permissions
                                self.returnURL = returnURL
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(permissions, forKey: "permissions")
                                encoder.encode(returnURL, forKey: "return_url")
                                return encoder.items
                            }
                        }

                        /// Networks_options_param
                        public struct Networks: Encodable {
                            public var requested: [RequestedItem]?

                            public enum RequestedItem: String, Codable, CaseIterable {
                                case ach
                                case usDomesticWire = "us_domestic_wire"
                            }

                            public init(requested: [RequestedItem]? = nil) {
                                self.requested = requested
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(requested, forKey: "requested")
                                return encoder.items
                            }
                        }

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case empty = ""
                            case `none`
                            case offSession = "off_session"
                            case onSession = "on_session"
                        }

                        public enum VerificationMethod: String, Codable, CaseIterable {
                            case automatic
                            case instant
                            case microdeposits
                        }

                        public init(financialConnections: FinancialConnections? = nil, networks: Networks? = nil, setupFutureUsage: SetupFutureUsage? = nil, verificationMethod: VerificationMethod? = nil) {
                            self.financialConnections = financialConnections
                            self.networks = networks
                            self.setupFutureUsage = setupFutureUsage
                            self.verificationMethod = verificationMethod
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(financialConnections, forKey: "financial_connections")
                            encoder.encode(networks, forKey: "networks")
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            encoder.encode(verificationMethod, forKey: "verification_method")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct WechatPay: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var appID: String?
                        public var client: Client
                        public var setupFutureUsage: SetupFutureUsage?

                        public enum Client: String, Codable, CaseIterable {
                            case android
                            case ios
                            case web
                        }

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case `none`
                        }

                        public init(appID: String? = nil, client: Client, setupFutureUsage: SetupFutureUsage? = nil) {
                            self.appID = appID
                            self.client = client
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(appID, forKey: "app_id")
                            encoder.encode(client, forKey: "client")
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public init(acssDebit: AcssDebit? = nil, affirm: Affirm? = nil, afterpayClearpay: AfterpayClearpay? = nil, alipay: Alipay? = nil, auBecsDebit: AuBecsDebit? = nil, bacsDebit: BacsDebit? = nil, bancontact: Bancontact? = nil, blik: Blik? = nil, boleto: Boleto? = nil, card: Card? = nil, cardPresent: CardPresent? = nil, customerBalance: CustomerBalance? = nil, eps: Eps? = nil, fpx: Fpx? = nil, giropay: Giropay? = nil, grabpay: Grabpay? = nil, ideal: Ideal? = nil, interacPresent: InteracPresent? = nil, klarna: Klarna? = nil, konbini: Konbini? = nil, link: Link? = nil, oxxo: Oxxo? = nil, p24: P24? = nil, paynow: Paynow? = nil, promptpay: Promptpay? = nil, sepaDebit: SepaDebit? = nil, sofort: Sofort? = nil, usBankAccount: UsBankAccount? = nil, wechatPay: WechatPay? = nil) {
                    self.acssDebit = acssDebit
                    self.affirm = affirm
                    self.afterpayClearpay = afterpayClearpay
                    self.alipay = alipay
                    self.auBecsDebit = auBecsDebit
                    self.bacsDebit = bacsDebit
                    self.bancontact = bancontact
                    self.blik = blik
                    self.boleto = boleto
                    self.card = card
                    self.cardPresent = cardPresent
                    self.customerBalance = customerBalance
                    self.eps = eps
                    self.fpx = fpx
                    self.giropay = giropay
                    self.grabpay = grabpay
                    self.ideal = ideal
                    self.interacPresent = interacPresent
                    self.klarna = klarna
                    self.konbini = konbini
                    self.link = link
                    self.oxxo = oxxo
                    self.p24 = p24
                    self.paynow = paynow
                    self.promptpay = promptpay
                    self.sepaDebit = sepaDebit
                    self.sofort = sofort
                    self.usBankAccount = usBankAccount
                    self.wechatPay = wechatPay
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acssDebit, forKey: "acss_debit")
                    encoder.encode(affirm, forKey: "affirm")
                    encoder.encode(afterpayClearpay, forKey: "afterpay_clearpay")
                    encoder.encode(alipay, forKey: "alipay")
                    encoder.encode(auBecsDebit, forKey: "au_becs_debit")
                    encoder.encode(bacsDebit, forKey: "bacs_debit")
                    encoder.encode(bancontact, forKey: "bancontact")
                    encoder.encode(blik, forKey: "blik")
                    encoder.encode(boleto, forKey: "boleto")
                    encoder.encode(card, forKey: "card")
                    encoder.encode(cardPresent, forKey: "card_present")
                    encoder.encode(customerBalance, forKey: "customer_balance")
                    encoder.encode(eps, forKey: "eps")
                    encoder.encode(fpx, forKey: "fpx")
                    encoder.encode(giropay, forKey: "giropay")
                    encoder.encode(grabpay, forKey: "grabpay")
                    encoder.encode(ideal, forKey: "ideal")
                    encoder.encode(interacPresent, forKey: "interac_present")
                    encoder.encode(klarna, forKey: "klarna")
                    encoder.encode(konbini, forKey: "konbini")
                    encoder.encode(link, forKey: "link")
                    encoder.encode(oxxo, forKey: "oxxo")
                    encoder.encode(p24, forKey: "p24")
                    encoder.encode(paynow, forKey: "paynow")
                    encoder.encode(promptpay, forKey: "promptpay")
                    encoder.encode(sepaDebit, forKey: "sepa_debit")
                    encoder.encode(sofort, forKey: "sofort")
                    encoder.encode(usBankAccount, forKey: "us_bank_account")
                    encoder.encode(wechatPay, forKey: "wechat_pay")
                    return encoder.items
                }
            }

            /// Email address that the receipt for the resulting payment will be sent to. If `receipt_email` is specified for a payment in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
            public struct ReceiptEmail: Encodable {
                public var string: String?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(string: String? = nil, object: Object? = nil) {
                    self.string = string
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(string, forKey: "string")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Indicates that you intend to make future payments with this PaymentIntent's payment method.
            /// 
            /// Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.
            /// 
            /// When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).
            /// 
            /// If `setup_future_usage` is already set and you are performing a request using a publishable key, you may only update the value from `on_session` to `off_session`.
            public enum SetupFutureUsage: String, Codable, CaseIterable {
                case empty = ""
                case offSession = "off_session"
                case onSession = "on_session"
            }

            /// Shipping information for this PaymentIntent.
            public struct Shipping: Encodable {
                /// Optional_fields_shipping
                public var a: A?
                public var b: B?

                /// Optional_fields_shipping
                public struct A: Encodable {
                    /// Optional_fields_address
                    public var address: Address
                    public var carrier: String?
                    public var name: String
                    public var phone: String?
                    public var trackingNumber: String?

                    /// Optional_fields_address
                    public struct Address: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String?
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?

                        public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            return encoder.items
                        }
                    }

                    public init(address: Address, carrier: String? = nil, name: String, phone: String? = nil, trackingNumber: String? = nil) {
                        self.address = address
                        self.carrier = carrier
                        self.name = name
                        self.phone = phone
                        self.trackingNumber = trackingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(address, forKey: "address")
                        encoder.encode(carrier, forKey: "carrier")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(phone, forKey: "phone")
                        encoder.encode(trackingNumber, forKey: "tracking_number")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Transfer_data_update_params
            ///
            /// The parameters used to automatically create a Transfer when the payment succeeds. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
            public struct TransferData: Encodable {
                public var amount: Int?

                public init(amount: Int? = nil) {
                    self.amount = amount
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    return encoder.items
                }
            }

            public init(amount: Int? = nil, applicationFeeAmount: ApplicationFeeAmount? = nil, captureMethod: CaptureMethod? = nil, currency: String? = nil, customer: String? = nil, description: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil, paymentMethod: String? = nil, paymentMethodData: PaymentMethodData? = nil, paymentMethodOptions: PaymentMethodOptions? = nil, paymentMethodTypes: [String]? = nil, receiptEmail: ReceiptEmail? = nil, setupFutureUsage: SetupFutureUsage? = nil, shipping: Shipping? = nil, statementDescriptor: String? = nil, statementDescriptorSuffix: String? = nil, transferData: TransferData? = nil, transferGroup: String? = nil) {
                self.amount = amount
                self.applicationFeeAmount = applicationFeeAmount
                self.captureMethod = captureMethod
                self.currency = currency
                self.customer = customer
                self.description = description
                self.expand = expand
                self.metadata = metadata
                self.paymentMethod = paymentMethod
                self.paymentMethodData = paymentMethodData
                self.paymentMethodOptions = paymentMethodOptions
                self.paymentMethodTypes = paymentMethodTypes
                self.receiptEmail = receiptEmail
                self.setupFutureUsage = setupFutureUsage
                self.shipping = shipping
                self.statementDescriptor = statementDescriptor
                self.statementDescriptorSuffix = statementDescriptorSuffix
                self.transferData = transferData
                self.transferGroup = transferGroup
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                encoder.encode(captureMethod, forKey: "capture_method")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(description, forKey: "description")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(paymentMethod, forKey: "payment_method")
                encoder.encode(paymentMethodData, forKey: "payment_method_data")
                encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                encoder.encode(receiptEmail, forKey: "receipt_email")
                encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                encoder.encode(shipping, forKey: "shipping")
                encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                encoder.encode(statementDescriptorSuffix, forKey: "statement_descriptor_suffix")
                encoder.encode(transferData, forKey: "transfer_data")
                encoder.encode(transferGroup, forKey: "transfer_group")
                return encoder.items
            }
        }
    }
}
