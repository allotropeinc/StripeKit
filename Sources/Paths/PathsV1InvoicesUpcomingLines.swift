// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths.Invoices.Upcoming {
    public var lines: Lines {
        Lines(path: path + "/lines")
    }

    public struct Lines {
        /// Path: `/v1/invoices/upcoming/lines`
        public let path: String

        /// <p>When retrieving an upcoming invoice, youâ€™ll get a <strong>lines</strong> property containing the total count of line items and the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            Request(method: "GET", url: path, query: parameters?.asQuery, id: "GetInvoicesUpcomingLines")
        }

        /// InvoiceLinesList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeKit.LineItem]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeKit.LineItem], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.data = try values.decode([StripeKit.LineItem].self, forKey: "data")
                self.hasMore = try values.decode(Bool.self, forKey: "has_more")
                self.object = try values.decode(Object.self, forKey: "object")
                self.url = try values.decode(String.self, forKey: "url")
            }
        }

        public struct GetParameters {
            /// Automatic_tax_param
            public var automaticTax: AutomaticTax?
            public var coupon: String?
            public var currency: String?
            public var customer: String?
            /// Customer_details_param
            public var customerDetails: CustomerDetails?
            public var discounts: Discounts?
            public var endingBefore: String?
            public var expand: [String]?
            public var invoiceItems: [InvoiceItems]?
            public var limit: Int?
            public var schedule: String?
            public var startingAfter: String?
            public var subscription: String?
            public var subscriptionBillingCycleAnchor: SubscriptionBillingCycleAnchor?
            public var subscriptionCancelAt: SubscriptionCancelAt?
            public var isSubscriptionCancelAtPeriodEnd: Bool?
            public var isSubscriptionCancelNow: Bool?
            public var subscriptionDefaultTaxRates: SubscriptionDefaultTaxRates?
            public var subscriptionItems: [SubscriptionItems]?
            public var subscriptionProrationBehavior: SubscriptionProrationBehavior?
            public var subscriptionProrationDate: Int?
            public var subscriptionStartDate: Int?
            public var subscriptionTrialEnd: SubscriptionTrialEnd?
            public var isSubscriptionTrialFromPlan: Bool?

            /// Automatic_tax_param
            public struct AutomaticTax: Codable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Customer_details_param
            public struct CustomerDetails: Codable {
                public var address: Address?
                public var shipping: Shipping?
                /// Tax_param
                public var tax: Tax?
                public var taxExempt: TaxExempt?
                public var taxIDs: [TaxID]?

                public struct Address: Codable {
                    /// Optional_fields_address
                    public var a: A?
                    public var b: B?

                    /// Optional_fields_address
                    public struct A: Codable {
                        public var city: String?
                        public var country: String?
                        public var line1: String?
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?

                        public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Shipping: Codable {
                    /// Customer_shipping
                    public var a: A?
                    public var b: B?

                    /// Customer_shipping
                    public struct A: Codable {
                        /// Optional_fields_address
                        public var address: Address
                        public var name: String
                        public var phone: String?

                        /// Optional_fields_address
                        public struct Address: Codable {
                            public var city: String?
                            public var country: String?
                            public var line1: String?
                            public var line2: String?
                            public var postalCode: String?
                            public var state: String?

                            public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                                self.city = city
                                self.country = country
                                self.line1 = line1
                                self.line2 = line2
                                self.postalCode = postalCode
                                self.state = state
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(city, forKey: "city")
                                encoder.encode(country, forKey: "country")
                                encoder.encode(line1, forKey: "line1")
                                encoder.encode(line2, forKey: "line2")
                                encoder.encode(postalCode, forKey: "postal_code")
                                encoder.encode(state, forKey: "state")
                                return encoder.items
                            }
                        }

                        public init(address: Address, name: String, phone: String? = nil) {
                            self.address = address
                            self.name = name
                            self.phone = phone
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(address, forKey: "address")
                            encoder.encode(name, forKey: "name")
                            encoder.encode(phone, forKey: "phone")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                /// Tax_param
                public struct Tax: Codable {
                    public var ipAddress: IpAddress?

                    public struct IpAddress: Codable {
                        public var string: String?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(string: String? = nil, object: Object? = nil) {
                            self.string = string
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(string, forKey: "string")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(ipAddress: IpAddress? = nil) {
                        self.ipAddress = ipAddress
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(ipAddress, forKey: "ip_address")
                        return encoder.items
                    }
                }

                public enum TaxExempt: String, Codable, CaseIterable {
                    case empty = ""
                    case exempt
                    case `none`
                    case reverse
                }

                /// Data_params
                public struct TaxID: Codable {
                    public var type: `Type`
                    public var value: String

                    public enum `Type`: String, Codable, CaseIterable {
                        case aeTrn = "ae_trn"
                        case auAbn = "au_abn"
                        case auArn = "au_arn"
                        case bgUic = "bg_uic"
                        case brCnpj = "br_cnpj"
                        case brCpf = "br_cpf"
                        case caBn = "ca_bn"
                        case caGstHst = "ca_gst_hst"
                        case caPstBc = "ca_pst_bc"
                        case caPstMb = "ca_pst_mb"
                        case caPstSk = "ca_pst_sk"
                        case caQst = "ca_qst"
                        case chVat = "ch_vat"
                        case clTin = "cl_tin"
                        case esCif = "es_cif"
                        case euOssVat = "eu_oss_vat"
                        case euVat = "eu_vat"
                        case gbVat = "gb_vat"
                        case geVat = "ge_vat"
                        case hkBr = "hk_br"
                        case huTin = "hu_tin"
                        case idNpwp = "id_npwp"
                        case ilVat = "il_vat"
                        case inGst = "in_gst"
                        case isVat = "is_vat"
                        case jpCn = "jp_cn"
                        case jpRn = "jp_rn"
                        case krBrn = "kr_brn"
                        case liUid = "li_uid"
                        case mxRfc = "mx_rfc"
                        case myFrp = "my_frp"
                        case myItn = "my_itn"
                        case mySst = "my_sst"
                        case noVat = "no_vat"
                        case nzGst = "nz_gst"
                        case ruInn = "ru_inn"
                        case ruKpp = "ru_kpp"
                        case saVat = "sa_vat"
                        case sgGst = "sg_gst"
                        case sgUen = "sg_uen"
                        case siTin = "si_tin"
                        case thVat = "th_vat"
                        case twVat = "tw_vat"
                        case uaVat = "ua_vat"
                        case usEin = "us_ein"
                        case zaVat = "za_vat"
                    }

                    public init(type: `Type`, value: String) {
                        self.type = type
                        self.value = value
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(type, forKey: "type")
                        encoder.encode(value, forKey: "value")
                        return encoder.items
                    }
                }

                public init(address: Address? = nil, shipping: Shipping? = nil, tax: Tax? = nil, taxExempt: TaxExempt? = nil, taxIDs: [TaxID]? = nil) {
                    self.address = address
                    self.shipping = shipping
                    self.tax = tax
                    self.taxExempt = taxExempt
                    self.taxIDs = taxIDs
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(shipping, forKey: "shipping")
                    encoder.encode(tax, forKey: "tax")
                    encoder.encode(taxExempt, forKey: "tax_exempt")
                    encoder.encode(taxIDs, forKey: "tax_ids")
                    return encoder.items
                }
            }

            public struct Discounts: Codable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Discounts_data_param
                public struct PlaceholderItem: Codable {
                    public var coupon: String?
                    public var discount: String?

                    public init(coupon: String? = nil, discount: String? = nil) {
                        self.coupon = coupon
                        self.discount = discount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(coupon, forKey: "coupon")
                        encoder.encode(discount, forKey: "discount")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Invoice_item_preview_params
            public struct InvoiceItems: Codable {
                public var amount: Int?
                public var currency: String?
                public var description: String?
                public var isDiscountable: Bool?
                public var discounts: Discounts?
                public var invoiceitem: String?
                public var metadata: Metadata?
                public var period: Period?
                public var price: String?
                /// One_time_price_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: TaxRates?
                public var unitAmount: Int?
                public var unitAmountDecimal: String?

                public struct Discounts: Codable {
                    public var placeholderItems: [PlaceholderItem]?
                    public var object: Object?

                    /// Discounts_data_param
                    public struct PlaceholderItem: Codable {
                        public var coupon: String?
                        public var discount: String?

                        public init(coupon: String? = nil, discount: String? = nil) {
                            self.coupon = coupon
                            self.discount = discount
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(coupon, forKey: "coupon")
                            encoder.encode(discount, forKey: "discount")
                            return encoder.items
                        }
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                        self.placeholderItems = placeholderItems
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(placeholderItems, forKey: "placeholderItems")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public struct Metadata: Codable {
                    public var stringString: [String: String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(stringString: [String: String]? = nil, object: Object? = nil) {
                        self.stringString = stringString
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(stringString, forKey: "stringString")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public struct Period: Codable {
                    public var end: Int
                    public var start: Int

                    public init(end: Int, start: Int) {
                        self.end = end
                        self.start = start
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(end, forKey: "end")
                        encoder.encode(start, forKey: "start")
                        return encoder.items
                    }
                }

                /// One_time_price_data
                public struct PriceData: Codable {
                    public var currency: String
                    public var product: String
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public struct TaxRates: Codable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(amount: Int? = nil, currency: String? = nil, description: String? = nil, isDiscountable: Bool? = nil, discounts: Discounts? = nil, invoiceitem: String? = nil, metadata: Metadata? = nil, period: Period? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                    self.amount = amount
                    self.currency = currency
                    self.description = description
                    self.isDiscountable = isDiscountable
                    self.discounts = discounts
                    self.invoiceitem = invoiceitem
                    self.metadata = metadata
                    self.period = period
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                    self.unitAmount = unitAmount
                    self.unitAmountDecimal = unitAmountDecimal
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    encoder.encode(currency, forKey: "currency")
                    encoder.encode(description, forKey: "description")
                    encoder.encode(isDiscountable, forKey: "discountable")
                    encoder.encode(discounts, forKey: "discounts")
                    encoder.encode(invoiceitem, forKey: "invoiceitem")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(period, forKey: "period")
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    encoder.encode(unitAmount, forKey: "unit_amount")
                    encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                    return encoder.items
                }
            }

            public struct SubscriptionBillingCycleAnchor: Codable {
                public var object: Object?
                public var int: Int?

                public enum Object: String, Codable, CaseIterable {
                    case now
                    case unchanged
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public struct SubscriptionCancelAt: Codable {
                public var int: Int?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(int: Int? = nil, object: Object? = nil) {
                    self.int = int
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(int, forKey: "int")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public struct SubscriptionDefaultTaxRates: Codable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Subscription_item_update_params
            public struct SubscriptionItems: Codable {
                public var billingThresholds: BillingThresholds?
                public var isClearUsage: Bool?
                public var isDeleted: Bool?
                public var id: String?
                public var metadata: Metadata?
                public var price: String?
                /// Recurring_price_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: TaxRates?

                public struct BillingThresholds: Codable {
                    /// Item_billing_thresholds_param
                    public var a: A?
                    public var b: B?

                    /// Item_billing_thresholds_param
                    public struct A: Codable {
                        public var usageGte: Int

                        public init(usageGte: Int) {
                            self.usageGte = usageGte
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(usageGte, forKey: "usage_gte")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Metadata: Codable {
                    public var stringString: [String: String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(stringString: [String: String]? = nil, object: Object? = nil) {
                        self.stringString = stringString
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(stringString, forKey: "stringString")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                /// Recurring_price_data
                public struct PriceData: Codable {
                    public var currency: String
                    public var product: String
                    /// Recurring_adhoc
                    public var recurring: Recurring
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    /// Recurring_adhoc
                    public struct Recurring: Codable {
                        public var interval: Interval
                        public var intervalCount: Int?

                        public enum Interval: String, Codable, CaseIterable {
                            case day
                            case month
                            case week
                            case year
                        }

                        public init(interval: Interval, intervalCount: Int? = nil) {
                            self.interval = interval
                            self.intervalCount = intervalCount
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(interval, forKey: "interval")
                            encoder.encode(intervalCount, forKey: "interval_count")
                            return encoder.items
                        }
                    }

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String, recurring: Recurring, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.recurring = recurring
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(recurring, forKey: "recurring")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public struct TaxRates: Codable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(billingThresholds: BillingThresholds? = nil, isClearUsage: Bool? = nil, isDeleted: Bool? = nil, id: String? = nil, metadata: Metadata? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                    self.billingThresholds = billingThresholds
                    self.isClearUsage = isClearUsage
                    self.isDeleted = isDeleted
                    self.id = id
                    self.metadata = metadata
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(billingThresholds, forKey: "billing_thresholds")
                    encoder.encode(isClearUsage, forKey: "clear_usage")
                    encoder.encode(isDeleted, forKey: "deleted")
                    encoder.encode(id, forKey: "id")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    return encoder.items
                }
            }

            public enum SubscriptionProrationBehavior: String, Codable, CaseIterable {
                case alwaysInvoice = "always_invoice"
                case createProrations = "create_prorations"
                case `none`
            }

            public struct SubscriptionTrialEnd: Codable {
                public var object: Object?
                public var int: Int?

                public enum Object: String, Codable, CaseIterable {
                    case now
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(automaticTax: AutomaticTax? = nil, coupon: String? = nil, currency: String? = nil, customer: String? = nil, customerDetails: CustomerDetails? = nil, discounts: Discounts? = nil, endingBefore: String? = nil, expand: [String]? = nil, invoiceItems: [InvoiceItems]? = nil, limit: Int? = nil, schedule: String? = nil, startingAfter: String? = nil, subscription: String? = nil, subscriptionBillingCycleAnchor: SubscriptionBillingCycleAnchor? = nil, subscriptionCancelAt: SubscriptionCancelAt? = nil, isSubscriptionCancelAtPeriodEnd: Bool? = nil, isSubscriptionCancelNow: Bool? = nil, subscriptionDefaultTaxRates: SubscriptionDefaultTaxRates? = nil, subscriptionItems: [SubscriptionItems]? = nil, subscriptionProrationBehavior: SubscriptionProrationBehavior? = nil, subscriptionProrationDate: Int? = nil, subscriptionStartDate: Int? = nil, subscriptionTrialEnd: SubscriptionTrialEnd? = nil, isSubscriptionTrialFromPlan: Bool? = nil) {
                self.automaticTax = automaticTax
                self.coupon = coupon
                self.currency = currency
                self.customer = customer
                self.customerDetails = customerDetails
                self.discounts = discounts
                self.endingBefore = endingBefore
                self.expand = expand
                self.invoiceItems = invoiceItems
                self.limit = limit
                self.schedule = schedule
                self.startingAfter = startingAfter
                self.subscription = subscription
                self.subscriptionBillingCycleAnchor = subscriptionBillingCycleAnchor
                self.subscriptionCancelAt = subscriptionCancelAt
                self.isSubscriptionCancelAtPeriodEnd = isSubscriptionCancelAtPeriodEnd
                self.isSubscriptionCancelNow = isSubscriptionCancelNow
                self.subscriptionDefaultTaxRates = subscriptionDefaultTaxRates
                self.subscriptionItems = subscriptionItems
                self.subscriptionProrationBehavior = subscriptionProrationBehavior
                self.subscriptionProrationDate = subscriptionProrationDate
                self.subscriptionStartDate = subscriptionStartDate
                self.subscriptionTrialEnd = subscriptionTrialEnd
                self.isSubscriptionTrialFromPlan = isSubscriptionTrialFromPlan
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(automaticTax, forKey: "automatic_tax", isDeepObject: true)
                encoder.encode(coupon, forKey: "coupon")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(customerDetails, forKey: "customer_details", isDeepObject: true)
                encoder.encode(discounts, forKey: "discounts", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(invoiceItems, forKey: "invoice_items", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(schedule, forKey: "schedule")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(subscription, forKey: "subscription")
                encoder.encode(subscriptionBillingCycleAnchor, forKey: "subscription_billing_cycle_anchor", isDeepObject: true)
                encoder.encode(subscriptionCancelAt, forKey: "subscription_cancel_at", isDeepObject: true)
                encoder.encode(isSubscriptionCancelAtPeriodEnd, forKey: "subscription_cancel_at_period_end")
                encoder.encode(isSubscriptionCancelNow, forKey: "subscription_cancel_now")
                encoder.encode(subscriptionDefaultTaxRates, forKey: "subscription_default_tax_rates", isDeepObject: true)
                encoder.encode(subscriptionItems, forKey: "subscription_items", isDeepObject: true)
                encoder.encode(subscriptionProrationBehavior, forKey: "subscription_proration_behavior")
                encoder.encode(subscriptionProrationDate, forKey: "subscription_proration_date")
                encoder.encode(subscriptionStartDate, forKey: "subscription_start_date")
                encoder.encode(subscriptionTrialEnd, forKey: "subscription_trial_end", isDeepObject: true)
                encoder.encode(isSubscriptionTrialFromPlan, forKey: "subscription_trial_from_plan")
                return encoder.items
            }
        }
    }
}
