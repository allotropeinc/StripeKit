// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var plans: Plans {
        Plans(path: "/v1/plans")
    }

    public struct Plans {
        /// Path: `/v1/plans`
        public let path: String

        /// <p>Returns a list of your plans.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            Request(method: "GET", url: path, query: parameters?.asQuery, id: "GetPlans")
        }

        /// PlanList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeKit.Plan]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeKit.Plan], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.data = try values.decode([StripeKit.Plan].self, forKey: "data")
                self.hasMore = try values.decode(Bool.self, forKey: "has_more")
                self.object = try values.decode(Object.self, forKey: "object")
                self.url = try values.decode(String.self, forKey: "url")
            }
        }

        public struct GetParameters {
            public var isActive: Bool?
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var product: String?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(isActive: Bool? = nil, created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, product: String? = nil, startingAfter: String? = nil) {
                self.isActive = isActive
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.product = product
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(product, forKey: "product")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>You can now model subscriptions more flexibly using the <a href="#prices">Prices API</a>. It replaces the Plans API and is backwards compatible to simplify your migration.</p>
        public func post(_ body: PostRequest) -> Request<StripeKit.Plan> {
            Request(method: "POST", url: path, body: URLQueryEncoder.encode(body).percentEncodedQuery, id: "PostPlans")
        }

        public struct PostRequest: Encodable {
            /// Whether the plan is currently available for new subscriptions. Defaults to `true`.
            public var isActive: Bool?
            /// Specifies a usage aggregation strategy for plans of `usage_type=metered`. Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max` which uses the usage record with the maximum reported usage during a period. Defaults to `sum`.
            public var aggregateUsage: AggregateUsage?
            /// A positive integer in cents (or local equivalent) (or 0 for a free plan) representing how much to charge on a recurring basis.
            public var amount: Int?
            /// Same as `amount`, but accepts a decimal value with at most 12 decimal places. Only one of `amount` and `amount_decimal` can be set.
            public var amountDecimal: String?
            /// Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `amount`) will be charged per unit in `quantity` (for plans with `usage_type=licensed`), or per unit of total usage (for plans with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.
            public var billingScheme: BillingScheme?
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
            public var currency: String
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// An identifier randomly generated by Stripe. Used to identify this plan when subscribing a customer. You can optionally override this ID, but the ID must be unique across all plans in your Stripe account. You can, however, use the same plan ID in both live and test modes.
            public var id: String?
            /// Specifies billing frequency. Either `day`, `week`, `month` or `year`.
            public var interval: Interval
            /// The number of intervals between subscription billings. For example, `interval=month` and `interval_count=3` bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
            public var intervalCount: Int?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// A brief description of the plan, hidden from customers.
            public var nickname: String?
            public var product: Product?
            /// Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`. See also the documentation for `billing_scheme`.
            public var tiers: [Tier]?
            /// Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price, in `graduated` tiering pricing can successively change as the quantity grows.
            public var tiersMode: TiersMode?
            /// Transform_usage_param
            ///
            /// Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with `tiers`.
            public var transformUsage: TransformUsage?
            /// Default number of trial days when subscribing a customer to this plan using [`trial_from_plan=true`](https://stripe.com/docs/api#create_subscription-trial_from_plan).
            public var trialPeriodDays: Int?
            /// Configures how the quantity per period should be determined. Can be either `metered` or `licensed`. `licensed` automatically bills the `quantity` set when adding it to a subscription. `metered` aggregates the total usage based on usage records. Defaults to `licensed`.
            public var usageType: UsageType?

            /// Specifies a usage aggregation strategy for plans of `usage_type=metered`. Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max` which uses the usage record with the maximum reported usage during a period. Defaults to `sum`.
            public enum AggregateUsage: String, Codable, CaseIterable {
                case lastDuringPeriod = "last_during_period"
                case lastEver = "last_ever"
                case max
                case sum
            }

            /// Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `amount`) will be charged per unit in `quantity` (for plans with `usage_type=licensed`), or per unit of total usage (for plans with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.
            public enum BillingScheme: String, Codable, CaseIterable {
                case perUnit = "per_unit"
                case tiered
            }

            /// Specifies billing frequency. Either `day`, `week`, `month` or `year`.
            public enum Interval: String, Codable, CaseIterable {
                case day
                case month
                case week
                case year
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public struct Product: Encodable {
                /// Inline_product_params
                ///
                /// The product whose pricing the created plan will represent. This can either be the ID of an existing product, or a dictionary containing fields used to create a [service product](https://stripe.com/docs/api#product_object-type).
                public var object: Object?
                /// The ID of the product whose pricing the created plan will represent.
                public var string: String?

                /// Inline_product_params
                ///
                /// The product whose pricing the created plan will represent. This can either be the ID of an existing product, or a dictionary containing fields used to create a [service product](https://stripe.com/docs/api#product_object-type).
                public struct Object: Encodable {
                    public var isActive: Bool?
                    public var id: String?
                    public var metadata: [String: String]?
                    public var name: String
                    public var statementDescriptor: String?
                    public var taxCode: String?
                    public var unitLabel: String?

                    public init(isActive: Bool? = nil, id: String? = nil, metadata: [String: String]? = nil, name: String, statementDescriptor: String? = nil, taxCode: String? = nil, unitLabel: String? = nil) {
                        self.isActive = isActive
                        self.id = id
                        self.metadata = metadata
                        self.name = name
                        self.statementDescriptor = statementDescriptor
                        self.taxCode = taxCode
                        self.unitLabel = unitLabel
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isActive, forKey: "active")
                        encoder.encode(id, forKey: "id")
                        encoder.encode(metadata, forKey: "metadata")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                        encoder.encode(taxCode, forKey: "tax_code")
                        encoder.encode(unitLabel, forKey: "unit_label")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            public struct Tier: Encodable {
                public var flatAmount: Int?
                public var flatAmountDecimal: String?
                public var unitAmount: Int?
                public var unitAmountDecimal: String?
                public var upTo: UpTo

                public struct UpTo: Encodable {
                    public var object: Object?
                    public var int: Int?

                    public enum Object: String, Codable, CaseIterable {
                        case inf
                    }

                    public init(object: Object? = nil, int: Int? = nil) {
                        self.object = object
                        self.int = int
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(int, forKey: "int")
                        return encoder.items
                    }
                }

                public init(flatAmount: Int? = nil, flatAmountDecimal: String? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil, upTo: UpTo) {
                    self.flatAmount = flatAmount
                    self.flatAmountDecimal = flatAmountDecimal
                    self.unitAmount = unitAmount
                    self.unitAmountDecimal = unitAmountDecimal
                    self.upTo = upTo
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(flatAmount, forKey: "flat_amount")
                    encoder.encode(flatAmountDecimal, forKey: "flat_amount_decimal")
                    encoder.encode(unitAmount, forKey: "unit_amount")
                    encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                    encoder.encode(upTo, forKey: "up_to")
                    return encoder.items
                }
            }

            /// Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price, in `graduated` tiering pricing can successively change as the quantity grows.
            public enum TiersMode: String, Codable, CaseIterable {
                case graduated
                case volume
            }

            /// Transform_usage_param
            ///
            /// Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with `tiers`.
            public struct TransformUsage: Encodable {
                public var divideBy: Int
                public var round: Round

                public enum Round: String, Codable, CaseIterable {
                    case down
                    case up
                }

                public init(divideBy: Int, round: Round) {
                    self.divideBy = divideBy
                    self.round = round
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(divideBy, forKey: "divide_by")
                    encoder.encode(round, forKey: "round")
                    return encoder.items
                }
            }

            /// Configures how the quantity per period should be determined. Can be either `metered` or `licensed`. `licensed` automatically bills the `quantity` set when adding it to a subscription. `metered` aggregates the total usage based on usage records. Defaults to `licensed`.
            public enum UsageType: String, Codable, CaseIterable {
                case licensed
                case metered
            }

            public init(isActive: Bool? = nil, aggregateUsage: AggregateUsage? = nil, amount: Int? = nil, amountDecimal: String? = nil, billingScheme: BillingScheme? = nil, currency: String, expand: [String]? = nil, id: String? = nil, interval: Interval, intervalCount: Int? = nil, metadata: Metadata? = nil, nickname: String? = nil, product: Product? = nil, tiers: [Tier]? = nil, tiersMode: TiersMode? = nil, transformUsage: TransformUsage? = nil, trialPeriodDays: Int? = nil, usageType: UsageType? = nil) {
                self.isActive = isActive
                self.aggregateUsage = aggregateUsage
                self.amount = amount
                self.amountDecimal = amountDecimal
                self.billingScheme = billingScheme
                self.currency = currency
                self.expand = expand
                self.id = id
                self.interval = interval
                self.intervalCount = intervalCount
                self.metadata = metadata
                self.nickname = nickname
                self.product = product
                self.tiers = tiers
                self.tiersMode = tiersMode
                self.transformUsage = transformUsage
                self.trialPeriodDays = trialPeriodDays
                self.usageType = usageType
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(aggregateUsage, forKey: "aggregate_usage")
                encoder.encode(amount, forKey: "amount")
                encoder.encode(amountDecimal, forKey: "amount_decimal")
                encoder.encode(billingScheme, forKey: "billing_scheme")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(id, forKey: "id")
                encoder.encode(interval, forKey: "interval")
                encoder.encode(intervalCount, forKey: "interval_count")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(nickname, forKey: "nickname")
                encoder.encode(product, forKey: "product")
                encoder.encode(tiers, forKey: "tiers")
                encoder.encode(tiersMode, forKey: "tiers_mode")
                encoder.encode(transformUsage, forKey: "transform_usage")
                encoder.encode(trialPeriodDays, forKey: "trial_period_days")
                encoder.encode(usageType, forKey: "usage_type")
                return encoder.items
            }
        }
    }
}
