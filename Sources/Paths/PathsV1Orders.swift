// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var orders: Orders {
        Orders(path: "/v1/orders")
    }

    public struct Orders {
        /// Path: `/v1/orders`
        public let path: String

        /// <p>Returns a list of your orders. The orders are returned sorted by creation date, with the most recently created orders appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            Request(method: "GET", url: path, query: parameters?.asQuery, id: "GetOrders")
        }

        /// OrdersV2ResourceOrderList
        public struct GetResponse: Decodable {
            public var data: [StripeKit.Order]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeKit.Order], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.data = try values.decode([StripeKit.Order].self, forKey: "data")
                self.hasMore = try values.decode(Bool.self, forKey: "has_more")
                self.object = try values.decode(Object.self, forKey: "object")
                self.url = try values.decode(String.self, forKey: "url")
            }
        }

        public struct GetParameters {
            public var customer: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(customer: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.customer = customer
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(customer, forKey: "customer")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a new <code>open</code> order object.</p>
        public func post(_ body: PostRequest) -> Request<StripeKit.Order> {
            Request(method: "POST", url: path, body: URLQueryEncoder.encode(body).percentEncodedQuery, id: "PostOrders")
        }

        public struct PostRequest: Encodable {
            /// Automatic_tax
            ///
            /// Settings for automatic tax calculation for this order.
            public var automaticTax: AutomaticTax?
            /// Billing details for the customer. If a customer is provided, this will be automatically populated with values from that customer if override values are not provided.
            public var billingDetails: BillingDetails?
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
            public var currency: String
            /// The customer associated with this order.
            public var customer: String?
            /// An arbitrary string attached to the object. Often useful for displaying to users.
            public var description: String?
            /// The coupons, promotion codes, and/or discounts to apply to the order.
            public var discounts: Discounts?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The IP address of the purchaser for this order.
            public var ipAddress: String?
            /// A list of line items the customer is ordering. Each line item includes information about the product, the quantity, and the resulting cost.
            public var lineItems: [LineItem]
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// Create_params
            ///
            /// Payment information associated with the order, including payment settings.
            public var payment: Payment?
            /// Settings for the customer cost of shipping for this order.
            public var shippingCost: ShippingCost?
            /// Shipping details for the order.
            public var shippingDetails: ShippingDetails?
            /// Tax_details
            ///
            /// Additional tax details about the purchaser to be used for this order.
            public var taxDetails: TaxDetails?

            /// Automatic_tax
            ///
            /// Settings for automatic tax calculation for this order.
            public struct AutomaticTax: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Billing details for the customer. If a customer is provided, this will be automatically populated with values from that customer if override values are not provided.
            public struct BillingDetails: Encodable {
                /// Billing_details
                public var a: A?
                public var b: B?

                /// Billing_details
                public struct A: Encodable {
                    /// Validated_optional_fields_address
                    public var address: Address?
                    public var email: String?
                    public var name: String?
                    public var phone: String?

                    /// Validated_optional_fields_address
                    public struct Address: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String?
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?

                        public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            return encoder.items
                        }
                    }

                    public init(address: Address? = nil, email: String? = nil, name: String? = nil, phone: String? = nil) {
                        self.address = address
                        self.email = email
                        self.name = name
                        self.phone = phone
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(address, forKey: "address")
                        encoder.encode(email, forKey: "email")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(phone, forKey: "phone")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// The coupons, promotion codes, and/or discounts to apply to the order.
            public struct Discounts: Encodable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Discounts_data_param
                public struct PlaceholderItem: Encodable {
                    public var coupon: String?
                    public var discount: String?
                    public var promotionCode: String?

                    public init(coupon: String? = nil, discount: String? = nil, promotionCode: String? = nil) {
                        self.coupon = coupon
                        self.discount = discount
                        self.promotionCode = promotionCode
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(coupon, forKey: "coupon")
                        encoder.encode(discount, forKey: "discount")
                        encoder.encode(promotionCode, forKey: "promotion_code")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Create_params
            public struct LineItem: Encodable {
                public var description: String?
                public var discounts: Discounts?
                public var price: String?
                /// Price_data_with_optional_product
                public var priceData: PriceData?
                public var product: String?
                /// Product_upsert_data
                public var productData: ProductData?
                public var quantity: Int?
                public var taxRates: TaxRates?

                public struct Discounts: Encodable {
                    public var placeholderItems: [PlaceholderItem]?
                    public var object: Object?

                    /// Discounts_data_param
                    public struct PlaceholderItem: Encodable {
                        public var coupon: String?
                        public var discount: String?

                        public init(coupon: String? = nil, discount: String? = nil) {
                            self.coupon = coupon
                            self.discount = discount
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(coupon, forKey: "coupon")
                            encoder.encode(discount, forKey: "discount")
                            return encoder.items
                        }
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                        self.placeholderItems = placeholderItems
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(placeholderItems, forKey: "placeholderItems")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                /// Price_data_with_optional_product
                public struct PriceData: Encodable {
                    public var currency: String?
                    public var product: String?
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String? = nil, product: String? = nil, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                /// Product_upsert_data
                public struct ProductData: Encodable {
                    public var description: String?
                    public var id: String
                    public var images: Images?
                    public var metadata: Metadata?
                    public var name: String
                    public var packageDimensions: PackageDimensions?
                    public var isShippable: Bool?
                    public var taxCode: String?
                    public var url: URL?

                    public struct Images: Encodable {
                        public var strings: [String]?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(strings: [String]? = nil, object: Object? = nil) {
                            self.strings = strings
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(strings, forKey: "strings")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public struct Metadata: Encodable {
                        public var stringString: [String: String]?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(stringString: [String: String]? = nil, object: Object? = nil) {
                            self.stringString = stringString
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(stringString, forKey: "stringString")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public struct PackageDimensions: Encodable {
                        /// Package_dimensions_specs
                        public var a: A?
                        public var b: B?

                        /// Package_dimensions_specs
                        public struct A: Encodable {
                            public var height: Double
                            public var length: Double
                            public var weight: Double
                            public var width: Double

                            public init(height: Double, length: Double, weight: Double, width: Double) {
                                self.height = height
                                self.length = length
                                self.weight = weight
                                self.width = width
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(height, forKey: "height")
                                encoder.encode(length, forKey: "length")
                                encoder.encode(weight, forKey: "weight")
                                encoder.encode(width, forKey: "width")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct URL: Encodable {
                        public var string: String?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(string: String? = nil, object: Object? = nil) {
                            self.string = string
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(string, forKey: "string")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(description: String? = nil, id: String, images: Images? = nil, metadata: Metadata? = nil, name: String, packageDimensions: PackageDimensions? = nil, isShippable: Bool? = nil, taxCode: String? = nil, url: URL? = nil) {
                        self.description = description
                        self.id = id
                        self.images = images
                        self.metadata = metadata
                        self.name = name
                        self.packageDimensions = packageDimensions
                        self.isShippable = isShippable
                        self.taxCode = taxCode
                        self.url = url
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(description, forKey: "description")
                        encoder.encode(id, forKey: "id")
                        encoder.encode(images, forKey: "images")
                        encoder.encode(metadata, forKey: "metadata")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(packageDimensions, forKey: "package_dimensions")
                        encoder.encode(isShippable, forKey: "shippable")
                        encoder.encode(taxCode, forKey: "tax_code")
                        encoder.encode(url, forKey: "url")
                        return encoder.items
                    }
                }

                public struct TaxRates: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(description: String? = nil, discounts: Discounts? = nil, price: String? = nil, priceData: PriceData? = nil, product: String? = nil, productData: ProductData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                    self.description = description
                    self.discounts = discounts
                    self.price = price
                    self.priceData = priceData
                    self.product = product
                    self.productData = productData
                    self.quantity = quantity
                    self.taxRates = taxRates
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(description, forKey: "description")
                    encoder.encode(discounts, forKey: "discounts")
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(product, forKey: "product")
                    encoder.encode(productData, forKey: "product_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    return encoder.items
                }
            }

            /// Create_params
            ///
            /// Payment information associated with the order, including payment settings.
            public struct Payment: Encodable {
                /// Create_params
                public var settings: Settings

                /// Create_params
                public struct Settings: Encodable {
                    public var applicationFeeAmount: Int?
                    /// Create_params
                    public var paymentMethodOptions: PaymentMethodOptions?
                    public var paymentMethodTypes: [PaymentMethodType]?
                    public var returnURL: String?
                    public var statementDescriptor: String?
                    public var statementDescriptorSuffix: String?
                    /// Transfer_data
                    public var transferData: TransferData?

                    /// Create_params
                    public struct PaymentMethodOptions: Encodable {
                        /// Payment_intent_payment_method_options_param
                        public var acssDebit: AcssDebit?
                        /// Afterpay_clearpay_payment_method_options_param
                        public var afterpayClearpay: AfterpayClearpay?
                        /// Payment_method_options_param
                        public var alipay: Alipay?
                        /// Payment_method_options_param
                        public var bancontact: Bancontact?
                        /// Card_payment_method_options
                        public var card: Card?
                        /// Payment_intent_payment_method_options_param
                        public var customerBalance: CustomerBalance?
                        /// Payment_method_options_param
                        public var ideal: Ideal?
                        /// Payment_method_options_param
                        public var klarna: Klarna?
                        /// Payment_intent_payment_method_options_param
                        public var link: Link?
                        /// Payment_method_options_param
                        public var oxxo: Oxxo?
                        /// Payment_method_options_param
                        public var p24: P24?
                        /// Payment_intent_payment_method_options_param
                        public var sepaDebit: SepaDebit?
                        /// Payment_method_options_param
                        public var sofort: Sofort?
                        /// Payment_method_options_param
                        public var wechatPay: WechatPay?

                        /// Payment_intent_payment_method_options_param
                        public struct AcssDebit: Encodable {
                            /// Payment_intent_payment_method_options_mandate_options_param
                            public var mandateOptions: MandateOptions?
                            public var setupFutureUsage: SetupFutureUsage?
                            public var verificationMethod: VerificationMethod?

                            /// Payment_intent_payment_method_options_mandate_options_param
                            public struct MandateOptions: Encodable {
                                public var customMandateURL: CustomMandateURL?
                                public var intervalDescription: String?
                                public var paymentSchedule: PaymentSchedule?
                                public var transactionType: TransactionType?

                                public struct CustomMandateURL: Encodable {
                                    public var string: String?
                                    public var object: Object?

                                    public enum Object: String, Codable, CaseIterable {
                                        case empty = ""
                                    }

                                    public init(string: String? = nil, object: Object? = nil) {
                                        self.string = string
                                        self.object = object
                                    }

                                    public var asQuery: [(String, String?)] {
                                        let encoder = URLQueryEncoder()
                                        encoder.encode(string, forKey: "string")
                                        encoder.encode(object, forKey: "object")
                                        return encoder.items
                                    }
                                }

                                public enum PaymentSchedule: String, Codable, CaseIterable {
                                    case combined
                                    case interval
                                    case sporadic
                                }

                                public enum TransactionType: String, Codable, CaseIterable {
                                    case business
                                    case personal
                                }

                                public init(customMandateURL: CustomMandateURL? = nil, intervalDescription: String? = nil, paymentSchedule: PaymentSchedule? = nil, transactionType: TransactionType? = nil) {
                                    self.customMandateURL = customMandateURL
                                    self.intervalDescription = intervalDescription
                                    self.paymentSchedule = paymentSchedule
                                    self.transactionType = transactionType
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(customMandateURL, forKey: "custom_mandate_url")
                                    encoder.encode(intervalDescription, forKey: "interval_description")
                                    encoder.encode(paymentSchedule, forKey: "payment_schedule")
                                    encoder.encode(transactionType, forKey: "transaction_type")
                                    return encoder.items
                                }
                            }

                            public enum SetupFutureUsage: String, Codable, CaseIterable {
                                case empty = ""
                                case `none`
                                case offSession = "off_session"
                                case onSession = "on_session"
                            }

                            public enum VerificationMethod: String, Codable, CaseIterable {
                                case automatic
                                case instant
                                case microdeposits
                            }

                            public init(mandateOptions: MandateOptions? = nil, setupFutureUsage: SetupFutureUsage? = nil, verificationMethod: VerificationMethod? = nil) {
                                self.mandateOptions = mandateOptions
                                self.setupFutureUsage = setupFutureUsage
                                self.verificationMethod = verificationMethod
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(mandateOptions, forKey: "mandate_options")
                                encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                                encoder.encode(verificationMethod, forKey: "verification_method")
                                return encoder.items
                            }
                        }

                        /// Afterpay_clearpay_payment_method_options_param
                        public struct AfterpayClearpay: Encodable {
                            public var captureMethod: CaptureMethod?
                            public var reference: String?
                            public var setupFutureUsage: SetupFutureUsage?

                            public enum CaptureMethod: String, Codable, CaseIterable {
                                case automatic
                                case manual
                            }

                            public enum SetupFutureUsage: String, Codable, CaseIterable {
                                case `none`
                            }

                            public init(captureMethod: CaptureMethod? = nil, reference: String? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                                self.captureMethod = captureMethod
                                self.reference = reference
                                self.setupFutureUsage = setupFutureUsage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(captureMethod, forKey: "capture_method")
                                encoder.encode(reference, forKey: "reference")
                                encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                                return encoder.items
                            }
                        }

                        /// Payment_method_options_param
                        public struct Alipay: Encodable {
                            public var setupFutureUsage: SetupFutureUsage?

                            public enum SetupFutureUsage: String, Codable, CaseIterable {
                                case empty = ""
                                case `none`
                                case offSession = "off_session"
                            }

                            public init(setupFutureUsage: SetupFutureUsage? = nil) {
                                self.setupFutureUsage = setupFutureUsage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                                return encoder.items
                            }
                        }

                        /// Payment_method_options_param
                        public struct Bancontact: Encodable {
                            public var preferredLanguage: PreferredLanguage?
                            public var setupFutureUsage: SetupFutureUsage?

                            public enum PreferredLanguage: String, Codable, CaseIterable {
                                case de
                                case en
                                case fr
                                case nl
                            }

                            public enum SetupFutureUsage: String, Codable, CaseIterable {
                                case empty = ""
                                case `none`
                                case offSession = "off_session"
                            }

                            public init(preferredLanguage: PreferredLanguage? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                                self.preferredLanguage = preferredLanguage
                                self.setupFutureUsage = setupFutureUsage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(preferredLanguage, forKey: "preferred_language")
                                encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                                return encoder.items
                            }
                        }

                        /// Card_payment_method_options
                        public struct Card: Encodable {
                            public var captureMethod: CaptureMethod?
                            public var setupFutureUsage: SetupFutureUsage?

                            public enum CaptureMethod: String, Codable, CaseIterable {
                                case automatic
                                case manual
                            }

                            public enum SetupFutureUsage: String, Codable, CaseIterable {
                                case `none`
                                case offSession = "off_session"
                                case onSession = "on_session"
                            }

                            public init(captureMethod: CaptureMethod? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                                self.captureMethod = captureMethod
                                self.setupFutureUsage = setupFutureUsage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(captureMethod, forKey: "capture_method")
                                encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                                return encoder.items
                            }
                        }

                        /// Payment_intent_payment_method_options_param
                        public struct CustomerBalance: Encodable {
                            /// Bank_transfer_param
                            public var bankTransfer: BankTransfer?
                            public var fundingType: FundingType?
                            public var setupFutureUsage: SetupFutureUsage?

                            /// Bank_transfer_param
                            public struct BankTransfer: Encodable {
                                /// Eu_bank_transfer_params
                                public var euBankTransfer: EuBankTransfer?
                                public var requestedAddressTypes: [RequestedAddressType]?
                                public var type: `Type`

                                /// Eu_bank_transfer_params
                                public struct EuBankTransfer: Encodable {
                                    public var country: String

                                    public init(country: String) {
                                        self.country = country
                                    }

                                    public var asQuery: [(String, String?)] {
                                        let encoder = URLQueryEncoder()
                                        encoder.encode(country, forKey: "country")
                                        return encoder.items
                                    }
                                }

                                public enum RequestedAddressType: String, Codable, CaseIterable {
                                    case iban
                                    case sepa
                                    case sortCode = "sort_code"
                                    case spei
                                    case zengin
                                }

                                public enum `Type`: String, Codable, CaseIterable {
                                    case euBankTransfer = "eu_bank_transfer"
                                    case gbBankTransfer = "gb_bank_transfer"
                                    case jpBankTransfer = "jp_bank_transfer"
                                    case mxBankTransfer = "mx_bank_transfer"
                                }

                                public init(euBankTransfer: EuBankTransfer? = nil, requestedAddressTypes: [RequestedAddressType]? = nil, type: `Type`) {
                                    self.euBankTransfer = euBankTransfer
                                    self.requestedAddressTypes = requestedAddressTypes
                                    self.type = type
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(euBankTransfer, forKey: "eu_bank_transfer")
                                    encoder.encode(requestedAddressTypes, forKey: "requested_address_types")
                                    encoder.encode(type, forKey: "type")
                                    return encoder.items
                                }
                            }

                            public enum FundingType: String, Codable, CaseIterable {
                                case bankTransfer = "bank_transfer"
                            }

                            public enum SetupFutureUsage: String, Codable, CaseIterable {
                                case `none`
                            }

                            public init(bankTransfer: BankTransfer? = nil, fundingType: FundingType? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                                self.bankTransfer = bankTransfer
                                self.fundingType = fundingType
                                self.setupFutureUsage = setupFutureUsage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(bankTransfer, forKey: "bank_transfer")
                                encoder.encode(fundingType, forKey: "funding_type")
                                encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                                return encoder.items
                            }
                        }

                        /// Payment_method_options_param
                        public struct Ideal: Encodable {
                            public var setupFutureUsage: SetupFutureUsage?

                            public enum SetupFutureUsage: String, Codable, CaseIterable {
                                case empty = ""
                                case `none`
                                case offSession = "off_session"
                            }

                            public init(setupFutureUsage: SetupFutureUsage? = nil) {
                                self.setupFutureUsage = setupFutureUsage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                                return encoder.items
                            }
                        }

                        /// Payment_method_options_param
                        public struct Klarna: Encodable {
                            public var captureMethod: CaptureMethod?
                            public var preferredLocale: PreferredLocale?
                            public var setupFutureUsage: SetupFutureUsage?

                            public enum CaptureMethod: String, Codable, CaseIterable {
                                case empty = ""
                                case manual
                            }

                            public enum PreferredLocale: String, Codable, CaseIterable {
                                case daDK = "da-DK"
                                case deAT = "de-AT"
                                case deDE = "de-DE"
                                case enAT = "en-AT"
                                case enAU = "en-AU"
                                case enBE = "en-BE"
                                case enCA = "en-CA"
                                case enDE = "en-DE"
                                case enDK = "en-DK"
                                case enES = "en-ES"
                                case enFI = "en-FI"
                                case enFR = "en-FR"
                                case enGB = "en-GB"
                                case enIE = "en-IE"
                                case enIT = "en-IT"
                                case enNL = "en-NL"
                                case enNO = "en-NO"
                                case enNZ = "en-NZ"
                                case enSE = "en-SE"
                                case enUS = "en-US"
                                case esES = "es-ES"
                                case esUS = "es-US"
                                case fiFI = "fi-FI"
                                case frBE = "fr-BE"
                                case frCA = "fr-CA"
                                case frFR = "fr-FR"
                                case itIT = "it-IT"
                                case nbNO = "nb-NO"
                                case nlBE = "nl-BE"
                                case nlNL = "nl-NL"
                                case svFI = "sv-FI"
                                case svSE = "sv-SE"
                            }

                            public enum SetupFutureUsage: String, Codable, CaseIterable {
                                case `none`
                            }

                            public init(captureMethod: CaptureMethod? = nil, preferredLocale: PreferredLocale? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                                self.captureMethod = captureMethod
                                self.preferredLocale = preferredLocale
                                self.setupFutureUsage = setupFutureUsage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(captureMethod, forKey: "capture_method")
                                encoder.encode(preferredLocale, forKey: "preferred_locale")
                                encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                                return encoder.items
                            }
                        }

                        /// Payment_intent_payment_method_options_param
                        public struct Link: Encodable {
                            public var captureMethod: CaptureMethod?
                            public var persistentToken: String?
                            public var setupFutureUsage: SetupFutureUsage?

                            public enum CaptureMethod: String, Codable, CaseIterable {
                                case empty = ""
                                case manual
                            }

                            public enum SetupFutureUsage: String, Codable, CaseIterable {
                                case empty = ""
                                case `none`
                                case offSession = "off_session"
                            }

                            public init(captureMethod: CaptureMethod? = nil, persistentToken: String? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                                self.captureMethod = captureMethod
                                self.persistentToken = persistentToken
                                self.setupFutureUsage = setupFutureUsage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(captureMethod, forKey: "capture_method")
                                encoder.encode(persistentToken, forKey: "persistent_token")
                                encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                                return encoder.items
                            }
                        }

                        /// Payment_method_options_param
                        public struct Oxxo: Encodable {
                            public var expiresAfterDays: Int?
                            public var setupFutureUsage: SetupFutureUsage?

                            public enum SetupFutureUsage: String, Codable, CaseIterable {
                                case `none`
                            }

                            public init(expiresAfterDays: Int? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                                self.expiresAfterDays = expiresAfterDays
                                self.setupFutureUsage = setupFutureUsage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(expiresAfterDays, forKey: "expires_after_days")
                                encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                                return encoder.items
                            }
                        }

                        /// Payment_method_options_param
                        public struct P24: Encodable {
                            public var setupFutureUsage: SetupFutureUsage?
                            public var isTosShownAndAccepted: Bool?

                            public enum SetupFutureUsage: String, Codable, CaseIterable {
                                case `none`
                            }

                            public init(setupFutureUsage: SetupFutureUsage? = nil, isTosShownAndAccepted: Bool? = nil) {
                                self.setupFutureUsage = setupFutureUsage
                                self.isTosShownAndAccepted = isTosShownAndAccepted
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                                encoder.encode(isTosShownAndAccepted, forKey: "tos_shown_and_accepted")
                                return encoder.items
                            }
                        }

                        /// Payment_intent_payment_method_options_param
                        public struct SepaDebit: Encodable {
                            /// Payment_method_options_mandate_options_param
                            public var mandateOptions: [String: AnyJSON]?
                            public var setupFutureUsage: SetupFutureUsage?

                            public enum SetupFutureUsage: String, Codable, CaseIterable {
                                case empty = ""
                                case `none`
                                case offSession = "off_session"
                                case onSession = "on_session"
                            }

                            public init(mandateOptions: [String: AnyJSON]? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                                self.mandateOptions = mandateOptions
                                self.setupFutureUsage = setupFutureUsage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(mandateOptions, forKey: "mandate_options")
                                encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                                return encoder.items
                            }
                        }

                        /// Payment_method_options_param
                        public struct Sofort: Encodable {
                            public var preferredLanguage: PreferredLanguage?
                            public var setupFutureUsage: SetupFutureUsage?

                            public enum PreferredLanguage: String, Codable, CaseIterable {
                                case empty = ""
                                case de
                                case en
                                case es
                                case fr
                                case it
                                case nl
                                case pl
                            }

                            public enum SetupFutureUsage: String, Codable, CaseIterable {
                                case empty = ""
                                case `none`
                                case offSession = "off_session"
                            }

                            public init(preferredLanguage: PreferredLanguage? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                                self.preferredLanguage = preferredLanguage
                                self.setupFutureUsage = setupFutureUsage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(preferredLanguage, forKey: "preferred_language")
                                encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                                return encoder.items
                            }
                        }

                        /// Payment_method_options_param
                        public struct WechatPay: Encodable {
                            public var appID: String?
                            public var client: Client
                            public var setupFutureUsage: SetupFutureUsage?

                            public enum Client: String, Codable, CaseIterable {
                                case android
                                case ios
                                case web
                            }

                            public enum SetupFutureUsage: String, Codable, CaseIterable {
                                case `none`
                            }

                            public init(appID: String? = nil, client: Client, setupFutureUsage: SetupFutureUsage? = nil) {
                                self.appID = appID
                                self.client = client
                                self.setupFutureUsage = setupFutureUsage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(appID, forKey: "app_id")
                                encoder.encode(client, forKey: "client")
                                encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                                return encoder.items
                            }
                        }

                        public init(acssDebit: AcssDebit? = nil, afterpayClearpay: AfterpayClearpay? = nil, alipay: Alipay? = nil, bancontact: Bancontact? = nil, card: Card? = nil, customerBalance: CustomerBalance? = nil, ideal: Ideal? = nil, klarna: Klarna? = nil, link: Link? = nil, oxxo: Oxxo? = nil, p24: P24? = nil, sepaDebit: SepaDebit? = nil, sofort: Sofort? = nil, wechatPay: WechatPay? = nil) {
                            self.acssDebit = acssDebit
                            self.afterpayClearpay = afterpayClearpay
                            self.alipay = alipay
                            self.bancontact = bancontact
                            self.card = card
                            self.customerBalance = customerBalance
                            self.ideal = ideal
                            self.klarna = klarna
                            self.link = link
                            self.oxxo = oxxo
                            self.p24 = p24
                            self.sepaDebit = sepaDebit
                            self.sofort = sofort
                            self.wechatPay = wechatPay
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(acssDebit, forKey: "acss_debit")
                            encoder.encode(afterpayClearpay, forKey: "afterpay_clearpay")
                            encoder.encode(alipay, forKey: "alipay")
                            encoder.encode(bancontact, forKey: "bancontact")
                            encoder.encode(card, forKey: "card")
                            encoder.encode(customerBalance, forKey: "customer_balance")
                            encoder.encode(ideal, forKey: "ideal")
                            encoder.encode(klarna, forKey: "klarna")
                            encoder.encode(link, forKey: "link")
                            encoder.encode(oxxo, forKey: "oxxo")
                            encoder.encode(p24, forKey: "p24")
                            encoder.encode(sepaDebit, forKey: "sepa_debit")
                            encoder.encode(sofort, forKey: "sofort")
                            encoder.encode(wechatPay, forKey: "wechat_pay")
                            return encoder.items
                        }
                    }

                    public enum PaymentMethodType: String, Codable, CaseIterable {
                        case acssDebit = "acss_debit"
                        case afterpayClearpay = "afterpay_clearpay"
                        case alipay
                        case auBecsDebit = "au_becs_debit"
                        case bacsDebit = "bacs_debit"
                        case bancontact
                        case card
                        case customerBalance = "customer_balance"
                        case eps
                        case fpx
                        case giropay
                        case grabpay
                        case ideal
                        case klarna
                        case link
                        case oxxo
                        case p24
                        case paypal
                        case sepaDebit = "sepa_debit"
                        case sofort
                        case wechatPay = "wechat_pay"
                    }

                    /// Transfer_data
                    public struct TransferData: Encodable {
                        public var amount: Int?
                        public var destination: String

                        public init(amount: Int? = nil, destination: String) {
                            self.amount = amount
                            self.destination = destination
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(amount, forKey: "amount")
                            encoder.encode(destination, forKey: "destination")
                            return encoder.items
                        }
                    }

                    public init(applicationFeeAmount: Int? = nil, paymentMethodOptions: PaymentMethodOptions? = nil, paymentMethodTypes: [PaymentMethodType]? = nil, returnURL: String? = nil, statementDescriptor: String? = nil, statementDescriptorSuffix: String? = nil, transferData: TransferData? = nil) {
                        self.applicationFeeAmount = applicationFeeAmount
                        self.paymentMethodOptions = paymentMethodOptions
                        self.paymentMethodTypes = paymentMethodTypes
                        self.returnURL = returnURL
                        self.statementDescriptor = statementDescriptor
                        self.statementDescriptorSuffix = statementDescriptorSuffix
                        self.transferData = transferData
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                        encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                        encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                        encoder.encode(returnURL, forKey: "return_url")
                        encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                        encoder.encode(statementDescriptorSuffix, forKey: "statement_descriptor_suffix")
                        encoder.encode(transferData, forKey: "transfer_data")
                        return encoder.items
                    }
                }

                public init(settings: Settings) {
                    self.settings = settings
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(settings, forKey: "settings")
                    return encoder.items
                }
            }

            /// Settings for the customer cost of shipping for this order.
            public struct ShippingCost: Encodable {
                /// Shipping_cost
                public var a: A?
                public var b: B?

                /// Shipping_cost
                public struct A: Encodable {
                    public var shippingRate: String?
                    /// Method_params
                    public var shippingRateData: ShippingRateData?

                    /// Method_params
                    public struct ShippingRateData: Encodable {
                        /// Delivery_estimate
                        public var deliveryEstimate: DeliveryEstimate?
                        public var displayName: String
                        /// Fixed_amount
                        public var fixedAmount: FixedAmount?
                        public var metadata: [String: String]?
                        public var taxBehavior: TaxBehavior?
                        public var taxCode: String?
                        public var type: `Type`?

                        /// Delivery_estimate
                        public struct DeliveryEstimate: Encodable {
                            /// Delivery_estimate_bound
                            public var maximum: Maximum?
                            /// Delivery_estimate_bound
                            public var minimum: Minimum?

                            /// Delivery_estimate_bound
                            public struct Maximum: Encodable {
                                public var unit: Unit
                                public var value: Int

                                public enum Unit: String, Codable, CaseIterable {
                                    case businessDay = "business_day"
                                    case day
                                    case hour
                                    case month
                                    case week
                                }

                                public init(unit: Unit, value: Int) {
                                    self.unit = unit
                                    self.value = value
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(unit, forKey: "unit")
                                    encoder.encode(value, forKey: "value")
                                    return encoder.items
                                }
                            }

                            /// Delivery_estimate_bound
                            public struct Minimum: Encodable {
                                public var unit: Unit
                                public var value: Int

                                public enum Unit: String, Codable, CaseIterable {
                                    case businessDay = "business_day"
                                    case day
                                    case hour
                                    case month
                                    case week
                                }

                                public init(unit: Unit, value: Int) {
                                    self.unit = unit
                                    self.value = value
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(unit, forKey: "unit")
                                    encoder.encode(value, forKey: "value")
                                    return encoder.items
                                }
                            }

                            public init(maximum: Maximum? = nil, minimum: Minimum? = nil) {
                                self.maximum = maximum
                                self.minimum = minimum
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(maximum, forKey: "maximum")
                                encoder.encode(minimum, forKey: "minimum")
                                return encoder.items
                            }
                        }

                        /// Fixed_amount
                        public struct FixedAmount: Encodable {
                            public var amount: Int
                            public var currency: String
                            public var currencyOptions: [String: CurrencyOption]?

                            /// Currency_option
                            public struct CurrencyOption: Encodable {
                                public var amount: Int
                                public var taxBehavior: TaxBehavior?

                                public enum TaxBehavior: String, Codable, CaseIterable {
                                    case exclusive
                                    case inclusive
                                    case unspecified
                                }

                                public init(amount: Int, taxBehavior: TaxBehavior? = nil) {
                                    self.amount = amount
                                    self.taxBehavior = taxBehavior
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(amount, forKey: "amount")
                                    encoder.encode(taxBehavior, forKey: "tax_behavior")
                                    return encoder.items
                                }
                            }

                            public init(amount: Int, currency: String, currencyOptions: [String: CurrencyOption]? = nil) {
                                self.amount = amount
                                self.currency = currency
                                self.currencyOptions = currencyOptions
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(amount, forKey: "amount")
                                encoder.encode(currency, forKey: "currency")
                                encoder.encode(currencyOptions, forKey: "currency_options")
                                return encoder.items
                            }
                        }

                        public enum TaxBehavior: String, Codable, CaseIterable {
                            case exclusive
                            case inclusive
                            case unspecified
                        }

                        public enum `Type`: String, Codable, CaseIterable {
                            case fixedAmount = "fixed_amount"
                        }

                        public init(deliveryEstimate: DeliveryEstimate? = nil, displayName: String, fixedAmount: FixedAmount? = nil, metadata: [String: String]? = nil, taxBehavior: TaxBehavior? = nil, taxCode: String? = nil, type: `Type`? = nil) {
                            self.deliveryEstimate = deliveryEstimate
                            self.displayName = displayName
                            self.fixedAmount = fixedAmount
                            self.metadata = metadata
                            self.taxBehavior = taxBehavior
                            self.taxCode = taxCode
                            self.type = type
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(deliveryEstimate, forKey: "delivery_estimate")
                            encoder.encode(displayName, forKey: "display_name")
                            encoder.encode(fixedAmount, forKey: "fixed_amount")
                            encoder.encode(metadata, forKey: "metadata")
                            encoder.encode(taxBehavior, forKey: "tax_behavior")
                            encoder.encode(taxCode, forKey: "tax_code")
                            encoder.encode(type, forKey: "type")
                            return encoder.items
                        }
                    }

                    public init(shippingRate: String? = nil, shippingRateData: ShippingRateData? = nil) {
                        self.shippingRate = shippingRate
                        self.shippingRateData = shippingRateData
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(shippingRate, forKey: "shipping_rate")
                        encoder.encode(shippingRateData, forKey: "shipping_rate_data")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Shipping details for the order.
            public struct ShippingDetails: Encodable {
                /// Shipping_details
                public var a: A?
                public var b: B?

                /// Shipping_details
                public struct A: Encodable {
                    /// Validated_optional_fields_address
                    public var address: Address
                    public var name: String
                    public var phone: String?

                    /// Validated_optional_fields_address
                    public struct Address: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String?
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?

                        public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            return encoder.items
                        }
                    }

                    public init(address: Address, name: String, phone: String? = nil) {
                        self.address = address
                        self.name = name
                        self.phone = phone
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(address, forKey: "address")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(phone, forKey: "phone")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Tax_details
            ///
            /// Additional tax details about the purchaser to be used for this order.
            public struct TaxDetails: Encodable {
                public var taxExempt: TaxExempt?
                public var taxIDs: [TaxID]?

                public enum TaxExempt: String, Codable, CaseIterable {
                    case empty = ""
                    case exempt
                    case `none`
                    case reverse
                }

                /// Data_params
                public struct TaxID: Encodable {
                    public var type: `Type`
                    public var value: String

                    public enum `Type`: String, Codable, CaseIterable {
                        case aeTrn = "ae_trn"
                        case auAbn = "au_abn"
                        case auArn = "au_arn"
                        case bgUic = "bg_uic"
                        case brCnpj = "br_cnpj"
                        case brCpf = "br_cpf"
                        case caBn = "ca_bn"
                        case caGstHst = "ca_gst_hst"
                        case caPstBc = "ca_pst_bc"
                        case caPstMb = "ca_pst_mb"
                        case caPstSk = "ca_pst_sk"
                        case caQst = "ca_qst"
                        case chVat = "ch_vat"
                        case clTin = "cl_tin"
                        case esCif = "es_cif"
                        case euOssVat = "eu_oss_vat"
                        case euVat = "eu_vat"
                        case gbVat = "gb_vat"
                        case geVat = "ge_vat"
                        case hkBr = "hk_br"
                        case huTin = "hu_tin"
                        case idNpwp = "id_npwp"
                        case ilVat = "il_vat"
                        case inGst = "in_gst"
                        case isVat = "is_vat"
                        case jpCn = "jp_cn"
                        case jpRn = "jp_rn"
                        case krBrn = "kr_brn"
                        case liUid = "li_uid"
                        case mxRfc = "mx_rfc"
                        case myFrp = "my_frp"
                        case myItn = "my_itn"
                        case mySst = "my_sst"
                        case noVat = "no_vat"
                        case nzGst = "nz_gst"
                        case ruInn = "ru_inn"
                        case ruKpp = "ru_kpp"
                        case saVat = "sa_vat"
                        case sgGst = "sg_gst"
                        case sgUen = "sg_uen"
                        case siTin = "si_tin"
                        case thVat = "th_vat"
                        case twVat = "tw_vat"
                        case uaVat = "ua_vat"
                        case usEin = "us_ein"
                        case zaVat = "za_vat"
                    }

                    public init(type: `Type`, value: String) {
                        self.type = type
                        self.value = value
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(type, forKey: "type")
                        encoder.encode(value, forKey: "value")
                        return encoder.items
                    }
                }

                public init(taxExempt: TaxExempt? = nil, taxIDs: [TaxID]? = nil) {
                    self.taxExempt = taxExempt
                    self.taxIDs = taxIDs
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(taxExempt, forKey: "tax_exempt")
                    encoder.encode(taxIDs, forKey: "tax_ids")
                    return encoder.items
                }
            }

            public init(automaticTax: AutomaticTax? = nil, billingDetails: BillingDetails? = nil, currency: String, customer: String? = nil, description: String? = nil, discounts: Discounts? = nil, expand: [String]? = nil, ipAddress: String? = nil, lineItems: [LineItem], metadata: [String: String]? = nil, payment: Payment? = nil, shippingCost: ShippingCost? = nil, shippingDetails: ShippingDetails? = nil, taxDetails: TaxDetails? = nil) {
                self.automaticTax = automaticTax
                self.billingDetails = billingDetails
                self.currency = currency
                self.customer = customer
                self.description = description
                self.discounts = discounts
                self.expand = expand
                self.ipAddress = ipAddress
                self.lineItems = lineItems
                self.metadata = metadata
                self.payment = payment
                self.shippingCost = shippingCost
                self.shippingDetails = shippingDetails
                self.taxDetails = taxDetails
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(automaticTax, forKey: "automatic_tax")
                encoder.encode(billingDetails, forKey: "billing_details")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(description, forKey: "description")
                encoder.encode(discounts, forKey: "discounts")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(ipAddress, forKey: "ip_address")
                encoder.encode(lineItems, forKey: "line_items")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(payment, forKey: "payment")
                encoder.encode(shippingCost, forKey: "shipping_cost")
                encoder.encode(shippingDetails, forKey: "shipping_details")
                encoder.encode(taxDetails, forKey: "tax_details")
                return encoder.items
            }
        }
    }
}
