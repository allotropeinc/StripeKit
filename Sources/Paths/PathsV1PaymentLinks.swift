// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var paymentLinks: PaymentLinks {
        PaymentLinks(path: "/v1/payment_links")
    }

    public struct PaymentLinks {
        /// Path: `/v1/payment_links`
        public let path: String

        /// <p>Returns a list of your payment links.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            Request(method: "GET", url: path, query: parameters?.asQuery, id: "GetPaymentLinks")
        }

        /// PaymentLinksResourcePaymentLinkList
        public struct GetResponse: Decodable {
            public var data: [StripeKit.PaymentLink]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeKit.PaymentLink], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.data = try values.decode([StripeKit.PaymentLink].self, forKey: "data")
                self.hasMore = try values.decode(Bool.self, forKey: "has_more")
                self.object = try values.decode(Object.self, forKey: "object")
                self.url = try values.decode(String.self, forKey: "url")
            }
        }

        public struct GetParameters {
            public var isActive: Bool?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(isActive: Bool? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.isActive = isActive
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a payment link.</p>
        public func post(_ body: PostRequest) -> Request<StripeKit.PaymentLink> {
            Request(method: "POST", url: path, body: URLQueryEncoder.encode(body).percentEncodedQuery, id: "PostPaymentLinks")
        }

        public struct PostRequest: Encodable {
            /// After_completion_params
            ///
            /// Behavior after the purchase is complete.
            public var afterCompletion: AfterCompletion?
            /// Enables user redeemable promotion codes.
            public var allowPromotionCodes: Bool?
            /// The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. Can only be applied when there are no line items with recurring prices.
            public var applicationFeeAmount: Int?
            /// A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. There must be at least 1 line item with a recurring price to use this field.
            public var applicationFeePercent: Double?
            /// Automatic_tax_params
            ///
            /// Configuration for automatic tax collection.
            public var automaticTax: AutomaticTax?
            /// Configuration for collecting the customer's billing address.
            public var billingAddressCollection: BillingAddressCollection?
            /// Consent_collection_params
            ///
            /// Configure fields to gather active consent from customers.
            public var consentCollection: ConsentCollection?
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies) and supported by each line item's price.
            public var currency: String?
            /// Configures whether [checkout sessions](https://stripe.com/docs/api/checkout/sessions) created by this payment link create a [Customer](https://stripe.com/docs/api/customers).
            public var customerCreation: CustomerCreation?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The line items representing what is being sold. Each line item represents an item being sold. Up to 20 line items are supported.
            public var lineItems: [LineItem]
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`. Metadata associated with this Payment Link will automatically be copied to [checkout sessions](https://stripe.com/docs/api/checkout/sessions) created by this payment link.
            public var metadata: [String: String]?
            /// The account on behalf of which to charge.
            public var onBehalfOf: String?
            /// Payment_intent_data_params
            ///
            /// A subset of parameters to be passed to PaymentIntent creation for Checkout Sessions in `payment` mode.
            public var paymentIntentData: PaymentIntentData?
            /// Specify whether Checkout should collect a payment method. When set to `if_required`, Checkout will not collect a payment method when the total due for the session is 0.This may occur if the Checkout Session includes a free trial or a discount.
            /// 
            /// Can only be set in `subscription` mode.
            /// 
            /// If you'd like information on how to collect a payment method outside of Checkout, read the guide on [configuring subscriptions with a free trial](https://stripe.com/docs/payments/checkout/free-trials).
            public var paymentMethodCollection: PaymentMethodCollection?
            /// The list of payment method types that customers can use. If no value is passed, Stripe will dynamically show relevant payment methods from your [payment method settings](https://dashboard.stripe.com/settings/payment_methods) (20+ payment methods [supported](https://stripe.com/docs/payments/payment-methods/integration-options#payment-method-product-support)).
            public var paymentMethodTypes: [PaymentMethodType]?
            /// Phone_number_collection_params
            ///
            /// Controls phone number collection settings during checkout.
            /// 
            /// We recommend that you review your privacy policy and check with your legal contacts.
            public var phoneNumberCollection: PhoneNumberCollection?
            /// Shipping_address_collection_params
            ///
            /// Configuration for collecting the customer's shipping address.
            public var shippingAddressCollection: ShippingAddressCollection?
            /// The shipping rate options to apply to [checkout sessions](https://stripe.com/docs/api/checkout/sessions) created by this payment link.
            public var shippingOptions: [ShippingOption]?
            /// Describes the type of transaction being performed in order to customize relevant text on the page, such as the submit button. Changing this value will also affect the hostname in the [url](https://stripe.com/docs/api/payment_links/payment_links/object#url) property (example: `donate.stripe.com`).
            public var submitType: SubmitType?
            /// Subscription_data_params
            ///
            /// When creating a subscription, the specified configuration data will be used. There must be at least one line item with a recurring price to use `subscription_data`.
            public var subscriptionData: SubscriptionData?
            /// Tax_id_collection_params
            ///
            /// Controls tax ID collection during checkout.
            public var taxIDCollection: TaxIDCollection?
            /// Transfer_data_params
            ///
            /// The account (if any) the payments will be attributed to for tax reporting, and where funds from each payment will be transferred to.
            public var transferData: TransferData?

            /// After_completion_params
            ///
            /// Behavior after the purchase is complete.
            public struct AfterCompletion: Encodable {
                /// After_completion_confirmation_page_params
                public var hostedConfirmation: HostedConfirmation?
                /// After_completion_redirect_params
                public var redirect: Redirect?
                public var type: `Type`

                /// After_completion_confirmation_page_params
                public struct HostedConfirmation: Encodable {
                    public var customMessage: String?

                    public init(customMessage: String? = nil) {
                        self.customMessage = customMessage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(customMessage, forKey: "custom_message")
                        return encoder.items
                    }
                }

                /// After_completion_redirect_params
                public struct Redirect: Encodable {
                    public var url: String

                    public init(url: String) {
                        self.url = url
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(url, forKey: "url")
                        return encoder.items
                    }
                }

                public enum `Type`: String, Codable, CaseIterable {
                    case hostedConfirmation = "hosted_confirmation"
                    case redirect
                }

                public init(hostedConfirmation: HostedConfirmation? = nil, redirect: Redirect? = nil, type: `Type`) {
                    self.hostedConfirmation = hostedConfirmation
                    self.redirect = redirect
                    self.type = type
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(hostedConfirmation, forKey: "hosted_confirmation")
                    encoder.encode(redirect, forKey: "redirect")
                    encoder.encode(type, forKey: "type")
                    return encoder.items
                }
            }

            /// Automatic_tax_params
            ///
            /// Configuration for automatic tax collection.
            public struct AutomaticTax: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Configuration for collecting the customer's billing address.
            public enum BillingAddressCollection: String, Codable, CaseIterable {
                case auto
                case required
            }

            /// Consent_collection_params
            ///
            /// Configure fields to gather active consent from customers.
            public struct ConsentCollection: Encodable {
                public var promotions: Promotions?

                public enum Promotions: String, Codable, CaseIterable {
                    case auto
                    case `none`
                }

                public init(promotions: Promotions? = nil) {
                    self.promotions = promotions
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(promotions, forKey: "promotions")
                    return encoder.items
                }
            }

            /// Configures whether [checkout sessions](https://stripe.com/docs/api/checkout/sessions) created by this payment link create a [Customer](https://stripe.com/docs/api/customers).
            public enum CustomerCreation: String, Codable, CaseIterable {
                case always
                case ifRequired = "if_required"
            }

            /// Line_items_create_params
            public struct LineItem: Encodable {
                /// Adjustable_quantity_params
                public var adjustableQuantity: AdjustableQuantity?
                public var price: String
                public var quantity: Int

                /// Adjustable_quantity_params
                public struct AdjustableQuantity: Encodable {
                    public var isEnabled: Bool
                    public var maximum: Int?
                    public var minimum: Int?

                    public init(isEnabled: Bool, maximum: Int? = nil, minimum: Int? = nil) {
                        self.isEnabled = isEnabled
                        self.maximum = maximum
                        self.minimum = minimum
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isEnabled, forKey: "enabled")
                        encoder.encode(maximum, forKey: "maximum")
                        encoder.encode(minimum, forKey: "minimum")
                        return encoder.items
                    }
                }

                public init(adjustableQuantity: AdjustableQuantity? = nil, price: String, quantity: Int) {
                    self.adjustableQuantity = adjustableQuantity
                    self.price = price
                    self.quantity = quantity
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(adjustableQuantity, forKey: "adjustable_quantity")
                    encoder.encode(price, forKey: "price")
                    encoder.encode(quantity, forKey: "quantity")
                    return encoder.items
                }
            }

            /// Payment_intent_data_params
            ///
            /// A subset of parameters to be passed to PaymentIntent creation for Checkout Sessions in `payment` mode.
            public struct PaymentIntentData: Encodable {
                public var captureMethod: CaptureMethod?
                public var setupFutureUsage: SetupFutureUsage?

                public enum CaptureMethod: String, Codable, CaseIterable {
                    case automatic
                    case manual
                }

                public enum SetupFutureUsage: String, Codable, CaseIterable {
                    case offSession = "off_session"
                    case onSession = "on_session"
                }

                public init(captureMethod: CaptureMethod? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                    self.captureMethod = captureMethod
                    self.setupFutureUsage = setupFutureUsage
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(captureMethod, forKey: "capture_method")
                    encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                    return encoder.items
                }
            }

            /// Specify whether Checkout should collect a payment method. When set to `if_required`, Checkout will not collect a payment method when the total due for the session is 0.This may occur if the Checkout Session includes a free trial or a discount.
            /// 
            /// Can only be set in `subscription` mode.
            /// 
            /// If you'd like information on how to collect a payment method outside of Checkout, read the guide on [configuring subscriptions with a free trial](https://stripe.com/docs/payments/checkout/free-trials).
            public enum PaymentMethodCollection: String, Codable, CaseIterable {
                case always
                case ifRequired = "if_required"
            }

            public enum PaymentMethodType: String, Codable, CaseIterable {
                case affirm
                case afterpayClearpay = "afterpay_clearpay"
                case alipay
                case auBecsDebit = "au_becs_debit"
                case bacsDebit = "bacs_debit"
                case bancontact
                case blik
                case boleto
                case card
                case eps
                case fpx
                case giropay
                case grabpay
                case ideal
                case klarna
                case konbini
                case oxxo
                case p24
                case paynow
                case promptpay
                case sepaDebit = "sepa_debit"
                case sofort
                case usBankAccount = "us_bank_account"
                case wechatPay = "wechat_pay"
            }

            /// Phone_number_collection_params
            ///
            /// Controls phone number collection settings during checkout.
            /// 
            /// We recommend that you review your privacy policy and check with your legal contacts.
            public struct PhoneNumberCollection: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Shipping_address_collection_params
            ///
            /// Configuration for collecting the customer's shipping address.
            public struct ShippingAddressCollection: Encodable {
                public var allowedCountries: [AllowedCountry]

                public enum AllowedCountry: String, Codable, CaseIterable {
                    case ac = "AC"
                    case ad = "AD"
                    case ae = "AE"
                    case af = "AF"
                    case ag = "AG"
                    case ai = "AI"
                    case al = "AL"
                    case am = "AM"
                    case ao = "AO"
                    case aq = "AQ"
                    case ar = "AR"
                    case at = "AT"
                    case au = "AU"
                    case aw = "AW"
                    case ax = "AX"
                    case az = "AZ"
                    case ba = "BA"
                    case bb = "BB"
                    case bd = "BD"
                    case be = "BE"
                    case bf = "BF"
                    case bg = "BG"
                    case bh = "BH"
                    case bi = "BI"
                    case bj = "BJ"
                    case bl = "BL"
                    case bm = "BM"
                    case bn = "BN"
                    case bo = "BO"
                    case bq = "BQ"
                    case br = "BR"
                    case bs = "BS"
                    case bt = "BT"
                    case bv = "BV"
                    case bw = "BW"
                    case by = "BY"
                    case bz = "BZ"
                    case ca = "CA"
                    case cd = "CD"
                    case cf = "CF"
                    case cg = "CG"
                    case ch = "CH"
                    case ci = "CI"
                    case ck = "CK"
                    case cl = "CL"
                    case cm = "CM"
                    case cn = "CN"
                    case co = "CO"
                    case cr = "CR"
                    case cv = "CV"
                    case cw = "CW"
                    case cy = "CY"
                    case cz = "CZ"
                    case de = "DE"
                    case dj = "DJ"
                    case dk = "DK"
                    case dm = "DM"
                    case `do` = "DO"
                    case dz = "DZ"
                    case ec = "EC"
                    case ee = "EE"
                    case eg = "EG"
                    case eh = "EH"
                    case er = "ER"
                    case es = "ES"
                    case et = "ET"
                    case fi = "FI"
                    case fj = "FJ"
                    case fk = "FK"
                    case fo = "FO"
                    case fr = "FR"
                    case ga = "GA"
                    case gb = "GB"
                    case gd = "GD"
                    case ge = "GE"
                    case gf = "GF"
                    case gg = "GG"
                    case gh = "GH"
                    case gi = "GI"
                    case gl = "GL"
                    case gm = "GM"
                    case gn = "GN"
                    case gp = "GP"
                    case gq = "GQ"
                    case gr = "GR"
                    case gs = "GS"
                    case gt = "GT"
                    case gu = "GU"
                    case gw = "GW"
                    case gy = "GY"
                    case hk = "HK"
                    case hn = "HN"
                    case hr = "HR"
                    case ht = "HT"
                    case hu = "HU"
                    case id = "ID"
                    case ie = "IE"
                    case il = "IL"
                    case im = "IM"
                    case `in` = "IN"
                    case io = "IO"
                    case iq = "IQ"
                    case `is` = "IS"
                    case it = "IT"
                    case je = "JE"
                    case jm = "JM"
                    case jo = "JO"
                    case jp = "JP"
                    case ke = "KE"
                    case kg = "KG"
                    case kh = "KH"
                    case ki = "KI"
                    case km = "KM"
                    case kn = "KN"
                    case kr = "KR"
                    case kw = "KW"
                    case ky = "KY"
                    case kz = "KZ"
                    case la = "LA"
                    case lb = "LB"
                    case lc = "LC"
                    case li = "LI"
                    case lk = "LK"
                    case lr = "LR"
                    case ls = "LS"
                    case lt = "LT"
                    case lu = "LU"
                    case lv = "LV"
                    case ly = "LY"
                    case ma = "MA"
                    case mc = "MC"
                    case md = "MD"
                    case me = "ME"
                    case mf = "MF"
                    case mg = "MG"
                    case mk = "MK"
                    case ml = "ML"
                    case mm = "MM"
                    case mn = "MN"
                    case mo = "MO"
                    case mq = "MQ"
                    case mr = "MR"
                    case ms = "MS"
                    case mt = "MT"
                    case mu = "MU"
                    case mv = "MV"
                    case mw = "MW"
                    case mx = "MX"
                    case my = "MY"
                    case mz = "MZ"
                    case na = "NA"
                    case nc = "NC"
                    case ne = "NE"
                    case ng = "NG"
                    case ni = "NI"
                    case nl = "NL"
                    case no = "NO"
                    case np = "NP"
                    case nr = "NR"
                    case nu = "NU"
                    case nz = "NZ"
                    case om = "OM"
                    case pa = "PA"
                    case pe = "PE"
                    case pf = "PF"
                    case pg = "PG"
                    case ph = "PH"
                    case pk = "PK"
                    case pl = "PL"
                    case pm = "PM"
                    case pn = "PN"
                    case pr = "PR"
                    case ps = "PS"
                    case pt = "PT"
                    case py = "PY"
                    case qa = "QA"
                    case re = "RE"
                    case ro = "RO"
                    case rs = "RS"
                    case ru = "RU"
                    case rw = "RW"
                    case sa = "SA"
                    case sb = "SB"
                    case sc = "SC"
                    case se = "SE"
                    case sg = "SG"
                    case sh = "SH"
                    case si = "SI"
                    case sj = "SJ"
                    case sk = "SK"
                    case sl = "SL"
                    case sm = "SM"
                    case sn = "SN"
                    case so = "SO"
                    case sr = "SR"
                    case ss = "SS"
                    case st = "ST"
                    case sv = "SV"
                    case sx = "SX"
                    case sz = "SZ"
                    case ta = "TA"
                    case tc = "TC"
                    case td = "TD"
                    case tf = "TF"
                    case tg = "TG"
                    case th = "TH"
                    case tj = "TJ"
                    case tk = "TK"
                    case tl = "TL"
                    case tm = "TM"
                    case tn = "TN"
                    case to = "TO"
                    case tr = "TR"
                    case tt = "TT"
                    case tv = "TV"
                    case tw = "TW"
                    case tz = "TZ"
                    case ua = "UA"
                    case ug = "UG"
                    case us = "US"
                    case uy = "UY"
                    case uz = "UZ"
                    case va = "VA"
                    case vc = "VC"
                    case ve = "VE"
                    case vg = "VG"
                    case vn = "VN"
                    case vu = "VU"
                    case wf = "WF"
                    case ws = "WS"
                    case xk = "XK"
                    case ye = "YE"
                    case yt = "YT"
                    case za = "ZA"
                    case zm = "ZM"
                    case zw = "ZW"
                    case zz = "ZZ"
                }

                public init(allowedCountries: [AllowedCountry]) {
                    self.allowedCountries = allowedCountries
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(allowedCountries, forKey: "allowed_countries")
                    return encoder.items
                }
            }

            /// Shipping_option_params
            public struct ShippingOption: Encodable {
                public var shippingRate: String?

                public init(shippingRate: String? = nil) {
                    self.shippingRate = shippingRate
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(shippingRate, forKey: "shipping_rate")
                    return encoder.items
                }
            }

            /// Describes the type of transaction being performed in order to customize relevant text on the page, such as the submit button. Changing this value will also affect the hostname in the [url](https://stripe.com/docs/api/payment_links/payment_links/object#url) property (example: `donate.stripe.com`).
            public enum SubmitType: String, Codable, CaseIterable {
                case auto
                case book
                case donate
                case pay
            }

            /// Subscription_data_params
            ///
            /// When creating a subscription, the specified configuration data will be used. There must be at least one line item with a recurring price to use `subscription_data`.
            public struct SubscriptionData: Encodable {
                public var trialPeriodDays: Int?

                public init(trialPeriodDays: Int? = nil) {
                    self.trialPeriodDays = trialPeriodDays
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(trialPeriodDays, forKey: "trial_period_days")
                    return encoder.items
                }
            }

            /// Tax_id_collection_params
            ///
            /// Controls tax ID collection during checkout.
            public struct TaxIDCollection: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Transfer_data_params
            ///
            /// The account (if any) the payments will be attributed to for tax reporting, and where funds from each payment will be transferred to.
            public struct TransferData: Encodable {
                public var amount: Int?
                public var destination: String

                public init(amount: Int? = nil, destination: String) {
                    self.amount = amount
                    self.destination = destination
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    encoder.encode(destination, forKey: "destination")
                    return encoder.items
                }
            }

            public init(afterCompletion: AfterCompletion? = nil, allowPromotionCodes: Bool? = nil, applicationFeeAmount: Int? = nil, applicationFeePercent: Double? = nil, automaticTax: AutomaticTax? = nil, billingAddressCollection: BillingAddressCollection? = nil, consentCollection: ConsentCollection? = nil, currency: String? = nil, customerCreation: CustomerCreation? = nil, expand: [String]? = nil, lineItems: [LineItem], metadata: [String: String]? = nil, onBehalfOf: String? = nil, paymentIntentData: PaymentIntentData? = nil, paymentMethodCollection: PaymentMethodCollection? = nil, paymentMethodTypes: [PaymentMethodType]? = nil, phoneNumberCollection: PhoneNumberCollection? = nil, shippingAddressCollection: ShippingAddressCollection? = nil, shippingOptions: [ShippingOption]? = nil, submitType: SubmitType? = nil, subscriptionData: SubscriptionData? = nil, taxIDCollection: TaxIDCollection? = nil, transferData: TransferData? = nil) {
                self.afterCompletion = afterCompletion
                self.allowPromotionCodes = allowPromotionCodes
                self.applicationFeeAmount = applicationFeeAmount
                self.applicationFeePercent = applicationFeePercent
                self.automaticTax = automaticTax
                self.billingAddressCollection = billingAddressCollection
                self.consentCollection = consentCollection
                self.currency = currency
                self.customerCreation = customerCreation
                self.expand = expand
                self.lineItems = lineItems
                self.metadata = metadata
                self.onBehalfOf = onBehalfOf
                self.paymentIntentData = paymentIntentData
                self.paymentMethodCollection = paymentMethodCollection
                self.paymentMethodTypes = paymentMethodTypes
                self.phoneNumberCollection = phoneNumberCollection
                self.shippingAddressCollection = shippingAddressCollection
                self.shippingOptions = shippingOptions
                self.submitType = submitType
                self.subscriptionData = subscriptionData
                self.taxIDCollection = taxIDCollection
                self.transferData = transferData
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(afterCompletion, forKey: "after_completion")
                encoder.encode(allowPromotionCodes, forKey: "allow_promotion_codes")
                encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                encoder.encode(automaticTax, forKey: "automatic_tax")
                encoder.encode(billingAddressCollection, forKey: "billing_address_collection")
                encoder.encode(consentCollection, forKey: "consent_collection")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(customerCreation, forKey: "customer_creation")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(lineItems, forKey: "line_items")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(onBehalfOf, forKey: "on_behalf_of")
                encoder.encode(paymentIntentData, forKey: "payment_intent_data")
                encoder.encode(paymentMethodCollection, forKey: "payment_method_collection")
                encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                encoder.encode(phoneNumberCollection, forKey: "phone_number_collection")
                encoder.encode(shippingAddressCollection, forKey: "shipping_address_collection")
                encoder.encode(shippingOptions, forKey: "shipping_options")
                encoder.encode(submitType, forKey: "submit_type")
                encoder.encode(subscriptionData, forKey: "subscription_data")
                encoder.encode(taxIDCollection, forKey: "tax_id_collection")
                encoder.encode(transferData, forKey: "transfer_data")
                return encoder.items
            }
        }
    }
}
