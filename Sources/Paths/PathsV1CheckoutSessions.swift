// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths.Checkout {
    public var sessions: Sessions {
        Sessions(path: path + "/sessions")
    }

    public struct Sessions {
        /// Path: `/v1/checkout/sessions`
        public let path: String

        /// <p>Returns a list of Checkout Sessions.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            Request(method: "GET", url: path, query: parameters?.asQuery, id: "GetCheckoutSessions")
        }

        /// PaymentPagesCheckoutSessionList
        public struct GetResponse: Decodable {
            public var data: [StripeKit.CheckoutSession]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeKit.CheckoutSession], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.data = try values.decode([StripeKit.CheckoutSession].self, forKey: "data")
                self.hasMore = try values.decode(Bool.self, forKey: "has_more")
                self.object = try values.decode(Object.self, forKey: "object")
                self.url = try values.decode(String.self, forKey: "url")
            }
        }

        public struct GetParameters {
            public var customer: String?
            /// Customer_details_params
            public var customerDetails: CustomerDetails?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var paymentIntent: String?
            public var startingAfter: String?
            public var subscription: String?

            /// Customer_details_params
            public struct CustomerDetails: Codable {
                public var email: String

                public init(email: String) {
                    self.email = email
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(email, forKey: "email")
                    return encoder.items
                }
            }

            public init(customer: String? = nil, customerDetails: CustomerDetails? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, paymentIntent: String? = nil, startingAfter: String? = nil, subscription: String? = nil) {
                self.customer = customer
                self.customerDetails = customerDetails
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.paymentIntent = paymentIntent
                self.startingAfter = startingAfter
                self.subscription = subscription
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(customer, forKey: "customer")
                encoder.encode(customerDetails, forKey: "customer_details", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(paymentIntent, forKey: "payment_intent")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(subscription, forKey: "subscription")
                return encoder.items
            }
        }

        /// <p>Creates a Session object.</p>
        public func post(_ body: PostRequest) -> Request<StripeKit.CheckoutSession> {
            Request(method: "POST", url: path, body: URLQueryEncoder.encode(body).percentEncodedQuery, id: "PostCheckoutSessions")
        }

        public struct PostRequest: Encodable {
            /// After_expiration_params
            ///
            /// Configure actions after a Checkout Session has expired.
            public var afterExpiration: AfterExpiration?
            /// Enables user redeemable promotion codes.
            public var allowPromotionCodes: Bool?
            /// Automatic_tax_params
            ///
            /// Settings for automatic tax lookup for this session and resulting payments, invoices, and subscriptions.
            public var automaticTax: AutomaticTax?
            /// Specify whether Checkout should collect the customer's billing address.
            public var billingAddressCollection: BillingAddressCollection?
            /// The URL the customer will be directed to if they decide to cancel payment and return to your website.
            public var cancelURL: String
            /// A unique string to reference the Checkout Session. This can be a
            /// customer ID, a cart ID, or similar, and can be used to reconcile the
            /// session with your internal systems.
            public var clientReferenceID: String?
            /// Consent_collection_params
            ///
            /// Configure fields for the Checkout Session to gather active consent from customers.
            public var consentCollection: ConsentCollection?
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
            public var currency: String?
            /// ID of an existing Customer, if one exists. In `payment` mode, the customer’s most recent card
            /// payment method will be used to prefill the email, name, card details, and billing address
            /// on the Checkout page. In `subscription` mode, the customer’s [default payment method](https://stripe.com/docs/api/customers/update#update_customer-invoice_settings-default_payment_method)
            /// will be used if it’s a card, and otherwise the most recent card will be used. A valid billing address, billing name and billing email are required on the payment method for Checkout to prefill the customer's card details.
            /// 
            /// If the Customer already has a valid [email](https://stripe.com/docs/api/customers/object#customer_object-email) set, the email will be prefilled and not editable in Checkout.
            /// If the Customer does not have a valid `email`, Checkout will set the email entered during the session on the Customer.
            /// 
            /// If blank for Checkout Sessions in `payment` or `subscription` mode, Checkout will create a new Customer object based on information provided during the payment flow.
            /// 
            /// You can set [`payment_intent_data.setup_future_usage`](https://stripe.com/docs/api/checkout/sessions/create#create_checkout_session-payment_intent_data-setup_future_usage) to have Checkout automatically attach the payment method to the Customer you pass in for future reuse.
            public var customer: String?
            /// Configure whether a Checkout Session creates a [Customer](https://stripe.com/docs/api/customers) during Session confirmation.
            /// 
            /// When a Customer is not created, you can still retrieve email, address, and other customer data entered in Checkout
            /// with [customer_details](https://stripe.com/docs/api/checkout/sessions/object#checkout_session_object-customer_details).
            /// 
            /// Sessions that don't create Customers instead create [Guest Customers](https://support.stripe.com/questions/guest-customer-faq)
            /// in the Dashboard. Promotion codes limited to first time customers will return invalid for these Sessions.
            /// 
            /// Can only be set in `payment` and `setup` mode.
            public var customerCreation: CustomerCreation?
            /// If provided, this value will be used when the Customer object is created.
            /// If not provided, customers will be asked to enter their email address.
            /// Use this parameter to prefill customer data if you already have an email
            /// on file. To access information about the customer once a session is
            /// complete, use the `customer` field.
            public var customerEmail: String?
            /// Customer_update_params
            ///
            /// Controls what fields on Customer can be updated by the Checkout Session. Can only be provided when `customer` is provided.
            public var customerUpdate: CustomerUpdate?
            /// The coupon or promotion code to apply to this Session. Currently, only up to one may be specified.
            public var discounts: [Discount]?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The Epoch time in seconds at which the Checkout Session will expire. It can be anywhere from 30 minutes to 24 hours after Checkout Session creation. By default, this value is 24 hours from creation.
            public var expiresAt: Int?
            /// A list of items the customer is purchasing. Use this parameter to pass one-time or recurring [Prices](https://stripe.com/docs/api/prices).
            /// 
            /// For `payment` mode, there is a maximum of 100 line items, however it is recommended to consolidate line items if there are more than a few dozen.
            /// 
            /// For `subscription` mode, there is a maximum of 20 line items with recurring Prices and 20 line items with one-time Prices. Line items with one-time Prices in will be on the initial invoice only.
            public var lineItems: [LineItem]?
            /// The IETF language tag of the locale Checkout is displayed in. If blank or `auto`, the browser's locale is used.
            public var locale: Locale?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// The mode of the Checkout Session. Required when using prices or `setup` mode. Pass `subscription` if the Checkout Session includes at least one recurring item.
            public var mode: Mode?
            /// Payment_intent_data_params
            ///
            /// A subset of parameters to be passed to PaymentIntent creation for Checkout Sessions in `payment` mode.
            public var paymentIntentData: PaymentIntentData?
            /// Specify whether Checkout should collect a payment method. When set to `if_required`, Checkout will not collect a payment method when the total due for the session is 0.
            /// This may occur if the Checkout Session includes a free trial or a discount.
            /// 
            /// Can only be set in `subscription` mode.
            /// 
            /// If you'd like information on how to collect a payment method outside of Checkout, read the guide on configuring [subscriptions with a free trial](https://stripe.com/docs/payments/checkout/free-trials).
            public var paymentMethodCollection: PaymentMethodCollection?
            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration.
            public var paymentMethodOptions: PaymentMethodOptions?
            /// A list of the types of payment methods (e.g., `card`) this Checkout Session can accept.
            /// 
            /// Do not include this attribute if you prefer to manage your payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods).
            /// 
            /// Read more about the supported payment methods and their requirements in our [payment
            /// method details guide](/docs/payments/checkout/payment-methods).
            /// 
            /// If multiple payment methods are passed, Checkout will dynamically reorder them to
            /// prioritize the most relevant payment methods based on the customer's location and
            /// other characteristics.
            public var paymentMethodTypes: [PaymentMethodType]?
            /// Phone_number_collection_params
            ///
            /// Controls phone number collection settings for the session.
            /// 
            /// We recommend that you review your privacy policy and check with your legal contacts
            /// before using this feature. Learn more about [collecting phone numbers with Checkout](https://stripe.com/docs/payments/checkout/phone-numbers).
            public var phoneNumberCollection: PhoneNumberCollection?
            /// Setup_intent_data_param
            ///
            /// A subset of parameters to be passed to SetupIntent creation for Checkout Sessions in `setup` mode.
            public var setupIntentData: SetupIntentData?
            /// Shipping_address_collection_params
            ///
            /// When set, provides configuration for Checkout to collect a shipping address from a customer.
            public var shippingAddressCollection: ShippingAddressCollection?
            /// The shipping rate options to apply to this Session.
            public var shippingOptions: [ShippingOption]?
            /// Describes the type of transaction being performed by Checkout in order to customize
            /// relevant text on the page, such as the submit button. `submit_type` can only be
            /// specified on Checkout Sessions in `payment` mode, but not Checkout Sessions
            /// in `subscription` or `setup` mode.
            public var submitType: SubmitType?
            /// Subscription_data_params
            ///
            /// A subset of parameters to be passed to subscription creation for Checkout Sessions in `subscription` mode.
            public var subscriptionData: SubscriptionData?
            /// The URL to which Stripe should send customers when payment or setup
            /// is complete.
            /// If you’d like to use information from the successful Checkout Session on your page,
            /// read the guide on [customizing your success page](https://stripe.com/docs/payments/checkout/custom-success-page).
            public var successURL: String
            /// Tax_id_collection_params
            ///
            /// Controls tax ID collection settings for the session.
            public var taxIDCollection: TaxIDCollection?

            /// After_expiration_params
            ///
            /// Configure actions after a Checkout Session has expired.
            public struct AfterExpiration: Encodable {
                /// Recovery_params
                public var recovery: Recovery?

                /// Recovery_params
                public struct Recovery: Encodable {
                    public var allowPromotionCodes: Bool?
                    public var isEnabled: Bool

                    public init(allowPromotionCodes: Bool? = nil, isEnabled: Bool) {
                        self.allowPromotionCodes = allowPromotionCodes
                        self.isEnabled = isEnabled
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(allowPromotionCodes, forKey: "allow_promotion_codes")
                        encoder.encode(isEnabled, forKey: "enabled")
                        return encoder.items
                    }
                }

                public init(recovery: Recovery? = nil) {
                    self.recovery = recovery
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(recovery, forKey: "recovery")
                    return encoder.items
                }
            }

            /// Automatic_tax_params
            ///
            /// Settings for automatic tax lookup for this session and resulting payments, invoices, and subscriptions.
            public struct AutomaticTax: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Specify whether Checkout should collect the customer's billing address.
            public enum BillingAddressCollection: String, Codable, CaseIterable {
                case auto
                case required
            }

            /// Consent_collection_params
            ///
            /// Configure fields for the Checkout Session to gather active consent from customers.
            public struct ConsentCollection: Encodable {
                public var promotions: Promotions?

                public enum Promotions: String, Codable, CaseIterable {
                    case auto
                    case `none`
                }

                public init(promotions: Promotions? = nil) {
                    self.promotions = promotions
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(promotions, forKey: "promotions")
                    return encoder.items
                }
            }

            /// Configure whether a Checkout Session creates a [Customer](https://stripe.com/docs/api/customers) during Session confirmation.
            /// 
            /// When a Customer is not created, you can still retrieve email, address, and other customer data entered in Checkout
            /// with [customer_details](https://stripe.com/docs/api/checkout/sessions/object#checkout_session_object-customer_details).
            /// 
            /// Sessions that don't create Customers instead create [Guest Customers](https://support.stripe.com/questions/guest-customer-faq)
            /// in the Dashboard. Promotion codes limited to first time customers will return invalid for these Sessions.
            /// 
            /// Can only be set in `payment` and `setup` mode.
            public enum CustomerCreation: String, Codable, CaseIterable {
                case always
                case ifRequired = "if_required"
            }

            /// Customer_update_params
            ///
            /// Controls what fields on Customer can be updated by the Checkout Session. Can only be provided when `customer` is provided.
            public struct CustomerUpdate: Encodable {
                public var address: Address?
                public var name: Name?
                public var shipping: Shipping?

                public enum Address: String, Codable, CaseIterable {
                    case auto
                    case never
                }

                public enum Name: String, Codable, CaseIterable {
                    case auto
                    case never
                }

                public enum Shipping: String, Codable, CaseIterable {
                    case auto
                    case never
                }

                public init(address: Address? = nil, name: Name? = nil, shipping: Shipping? = nil) {
                    self.address = address
                    self.name = name
                    self.shipping = shipping
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(shipping, forKey: "shipping")
                    return encoder.items
                }
            }

            /// Discount_params
            public struct Discount: Encodable {
                public var coupon: String?
                public var promotionCode: String?

                public init(coupon: String? = nil, promotionCode: String? = nil) {
                    self.coupon = coupon
                    self.promotionCode = promotionCode
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(coupon, forKey: "coupon")
                    encoder.encode(promotionCode, forKey: "promotion_code")
                    return encoder.items
                }
            }

            /// Line_item_params
            public struct LineItem: Encodable {
                /// Adjustable_quantity_params
                public var adjustableQuantity: AdjustableQuantity?
                public var dynamicTaxRates: [String]?
                public var price: String?
                /// Price_data_with_product_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: [String]?

                /// Adjustable_quantity_params
                public struct AdjustableQuantity: Encodable {
                    public var isEnabled: Bool
                    public var maximum: Int?
                    public var minimum: Int?

                    public init(isEnabled: Bool, maximum: Int? = nil, minimum: Int? = nil) {
                        self.isEnabled = isEnabled
                        self.maximum = maximum
                        self.minimum = minimum
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isEnabled, forKey: "enabled")
                        encoder.encode(maximum, forKey: "maximum")
                        encoder.encode(minimum, forKey: "minimum")
                        return encoder.items
                    }
                }

                /// Price_data_with_product_data
                public struct PriceData: Encodable {
                    public var currency: String
                    public var product: String?
                    /// Product_data
                    public var productData: ProductData?
                    /// Recurring_adhoc
                    public var recurring: Recurring?
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    /// Product_data
                    public struct ProductData: Encodable {
                        public var description: String?
                        public var images: [String]?
                        public var metadata: [String: String]?
                        public var name: String
                        public var taxCode: String?

                        public init(description: String? = nil, images: [String]? = nil, metadata: [String: String]? = nil, name: String, taxCode: String? = nil) {
                            self.description = description
                            self.images = images
                            self.metadata = metadata
                            self.name = name
                            self.taxCode = taxCode
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(description, forKey: "description")
                            encoder.encode(images, forKey: "images")
                            encoder.encode(metadata, forKey: "metadata")
                            encoder.encode(name, forKey: "name")
                            encoder.encode(taxCode, forKey: "tax_code")
                            return encoder.items
                        }
                    }

                    /// Recurring_adhoc
                    public struct Recurring: Encodable {
                        public var interval: Interval
                        public var intervalCount: Int?

                        public enum Interval: String, Codable, CaseIterable {
                            case day
                            case month
                            case week
                            case year
                        }

                        public init(interval: Interval, intervalCount: Int? = nil) {
                            self.interval = interval
                            self.intervalCount = intervalCount
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(interval, forKey: "interval")
                            encoder.encode(intervalCount, forKey: "interval_count")
                            return encoder.items
                        }
                    }

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String? = nil, productData: ProductData? = nil, recurring: Recurring? = nil, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.productData = productData
                        self.recurring = recurring
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(productData, forKey: "product_data")
                        encoder.encode(recurring, forKey: "recurring")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public init(adjustableQuantity: AdjustableQuantity? = nil, dynamicTaxRates: [String]? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: [String]? = nil) {
                    self.adjustableQuantity = adjustableQuantity
                    self.dynamicTaxRates = dynamicTaxRates
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(adjustableQuantity, forKey: "adjustable_quantity")
                    encoder.encode(dynamicTaxRates, forKey: "dynamic_tax_rates")
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    return encoder.items
                }
            }

            /// The IETF language tag of the locale Checkout is displayed in. If blank or `auto`, the browser's locale is used.
            public enum Locale: String, Codable, CaseIterable {
                case auto
                case bg
                case cs
                case da
                case de
                case el
                case en
                case enGB = "en-GB"
                case es
                case es419 = "es-419"
                case et
                case fi
                case fil
                case fr
                case frCA = "fr-CA"
                case hr
                case hu
                case id
                case it
                case ja
                case ko
                case lt
                case lv
                case ms
                case mt
                case nb
                case nl
                case pl
                case pt
                case ptBR = "pt-BR"
                case ro
                case ru
                case sk
                case sl
                case sv
                case th
                case tr
                case vi
                case zh
                case zhHK = "zh-HK"
                case zhTW = "zh-TW"
            }

            /// The mode of the Checkout Session. Required when using prices or `setup` mode. Pass `subscription` if the Checkout Session includes at least one recurring item.
            public enum Mode: String, Codable, CaseIterable {
                case payment
                case setup
                case subscription
            }

            /// Payment_intent_data_params
            ///
            /// A subset of parameters to be passed to PaymentIntent creation for Checkout Sessions in `payment` mode.
            public struct PaymentIntentData: Encodable {
                public var applicationFeeAmount: Int?
                public var captureMethod: CaptureMethod?
                public var description: String?
                public var metadata: [String: String]?
                public var onBehalfOf: String?
                public var receiptEmail: String?
                public var setupFutureUsage: SetupFutureUsage?
                public var shipping: Shipping?
                public var statementDescriptor: String?
                public var statementDescriptorSuffix: String?
                /// Transfer_data_params
                public var transferData: TransferData?
                public var transferGroup: String?

                public enum CaptureMethod: String, Codable, CaseIterable {
                    case automatic
                    case manual
                }

                public enum SetupFutureUsage: String, Codable, CaseIterable {
                    case offSession = "off_session"
                    case onSession = "on_session"
                }

                public struct Shipping: Encodable {
                    public var address: Address
                    public var carrier: String?
                    public var name: String
                    public var phone: String?
                    public var trackingNumber: String?

                    public struct Address: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?

                        public init(city: String? = nil, country: String? = nil, line1: String, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            return encoder.items
                        }
                    }

                    public init(address: Address, carrier: String? = nil, name: String, phone: String? = nil, trackingNumber: String? = nil) {
                        self.address = address
                        self.carrier = carrier
                        self.name = name
                        self.phone = phone
                        self.trackingNumber = trackingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(address, forKey: "address")
                        encoder.encode(carrier, forKey: "carrier")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(phone, forKey: "phone")
                        encoder.encode(trackingNumber, forKey: "tracking_number")
                        return encoder.items
                    }
                }

                /// Transfer_data_params
                public struct TransferData: Encodable {
                    public var amount: Int?
                    public var destination: String

                    public init(amount: Int? = nil, destination: String) {
                        self.amount = amount
                        self.destination = destination
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amount, forKey: "amount")
                        encoder.encode(destination, forKey: "destination")
                        return encoder.items
                    }
                }

                public init(applicationFeeAmount: Int? = nil, captureMethod: CaptureMethod? = nil, description: String? = nil, metadata: [String: String]? = nil, onBehalfOf: String? = nil, receiptEmail: String? = nil, setupFutureUsage: SetupFutureUsage? = nil, shipping: Shipping? = nil, statementDescriptor: String? = nil, statementDescriptorSuffix: String? = nil, transferData: TransferData? = nil, transferGroup: String? = nil) {
                    self.applicationFeeAmount = applicationFeeAmount
                    self.captureMethod = captureMethod
                    self.description = description
                    self.metadata = metadata
                    self.onBehalfOf = onBehalfOf
                    self.receiptEmail = receiptEmail
                    self.setupFutureUsage = setupFutureUsage
                    self.shipping = shipping
                    self.statementDescriptor = statementDescriptor
                    self.statementDescriptorSuffix = statementDescriptorSuffix
                    self.transferData = transferData
                    self.transferGroup = transferGroup
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                    encoder.encode(captureMethod, forKey: "capture_method")
                    encoder.encode(description, forKey: "description")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(onBehalfOf, forKey: "on_behalf_of")
                    encoder.encode(receiptEmail, forKey: "receipt_email")
                    encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                    encoder.encode(shipping, forKey: "shipping")
                    encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                    encoder.encode(statementDescriptorSuffix, forKey: "statement_descriptor_suffix")
                    encoder.encode(transferData, forKey: "transfer_data")
                    encoder.encode(transferGroup, forKey: "transfer_group")
                    return encoder.items
                }
            }

            /// Specify whether Checkout should collect a payment method. When set to `if_required`, Checkout will not collect a payment method when the total due for the session is 0.
            /// This may occur if the Checkout Session includes a free trial or a discount.
            /// 
            /// Can only be set in `subscription` mode.
            /// 
            /// If you'd like information on how to collect a payment method outside of Checkout, read the guide on configuring [subscriptions with a free trial](https://stripe.com/docs/payments/checkout/free-trials).
            public enum PaymentMethodCollection: String, Codable, CaseIterable {
                case always
                case ifRequired = "if_required"
            }

            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration.
            public struct PaymentMethodOptions: Encodable {
                /// Payment_method_options_param
                public var acssDebit: AcssDebit?
                /// Payment_method_options_param
                public var affirm: Affirm?
                /// Payment_method_options_param
                public var afterpayClearpay: AfterpayClearpay?
                /// Payment_method_options_param
                public var alipay: Alipay?
                /// Payment_method_options_param
                public var auBecsDebit: AuBecsDebit?
                /// Payment_method_options_param
                public var bacsDebit: BacsDebit?
                /// Payment_method_options_param
                public var bancontact: Bancontact?
                /// Payment_method_options_param
                public var boleto: Boleto?
                /// Payment_method_options_param
                public var card: Card?
                /// Payment_method_options_param
                public var customerBalance: CustomerBalance?
                /// Payment_method_options_param
                public var eps: Eps?
                /// Payment_method_options_param
                public var fpx: Fpx?
                /// Payment_method_options_param
                public var giropay: Giropay?
                /// Payment_method_options_param
                public var grabpay: Grabpay?
                /// Payment_method_options_param
                public var ideal: Ideal?
                /// Payment_method_options_param
                public var klarna: Klarna?
                /// Payment_method_options_param
                public var konbini: Konbini?
                /// Payment_method_options_param
                public var oxxo: Oxxo?
                /// Payment_method_options_param
                public var p24: P24?
                /// Payment_method_options_param
                public var paynow: Paynow?
                /// Payment_method_options_param
                public var sepaDebit: SepaDebit?
                /// Payment_method_options_param
                public var sofort: Sofort?
                /// Payment_method_options_param
                public var usBankAccount: UsBankAccount?
                /// Payment_method_options_param
                public var wechatPay: WechatPay?

                /// Payment_method_options_param
                public struct AcssDebit: Encodable {
                    public var currency: Currency?
                    /// Mandate_options_param
                    public var mandateOptions: MandateOptions?
                    public var setupFutureUsage: SetupFutureUsage?
                    public var verificationMethod: VerificationMethod?

                    public enum Currency: String, Codable, CaseIterable {
                        case cad
                        case usd
                    }

                    /// Mandate_options_param
                    public struct MandateOptions: Encodable {
                        public var customMandateURL: CustomMandateURL?
                        public var defaultFor: [DefaultForItem]?
                        public var intervalDescription: String?
                        public var paymentSchedule: PaymentSchedule?
                        public var transactionType: TransactionType?

                        public struct CustomMandateURL: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public enum DefaultForItem: String, Codable, CaseIterable {
                            case invoice
                            case subscription
                        }

                        public enum PaymentSchedule: String, Codable, CaseIterable {
                            case combined
                            case interval
                            case sporadic
                        }

                        public enum TransactionType: String, Codable, CaseIterable {
                            case business
                            case personal
                        }

                        public init(customMandateURL: CustomMandateURL? = nil, defaultFor: [DefaultForItem]? = nil, intervalDescription: String? = nil, paymentSchedule: PaymentSchedule? = nil, transactionType: TransactionType? = nil) {
                            self.customMandateURL = customMandateURL
                            self.defaultFor = defaultFor
                            self.intervalDescription = intervalDescription
                            self.paymentSchedule = paymentSchedule
                            self.transactionType = transactionType
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(customMandateURL, forKey: "custom_mandate_url")
                            encoder.encode(defaultFor, forKey: "default_for")
                            encoder.encode(intervalDescription, forKey: "interval_description")
                            encoder.encode(paymentSchedule, forKey: "payment_schedule")
                            encoder.encode(transactionType, forKey: "transaction_type")
                            return encoder.items
                        }
                    }

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                        case offSession = "off_session"
                        case onSession = "on_session"
                    }

                    public enum VerificationMethod: String, Codable, CaseIterable {
                        case automatic
                        case instant
                        case microdeposits
                    }

                    public init(currency: Currency? = nil, mandateOptions: MandateOptions? = nil, setupFutureUsage: SetupFutureUsage? = nil, verificationMethod: VerificationMethod? = nil) {
                        self.currency = currency
                        self.mandateOptions = mandateOptions
                        self.setupFutureUsage = setupFutureUsage
                        self.verificationMethod = verificationMethod
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(mandateOptions, forKey: "mandate_options")
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        encoder.encode(verificationMethod, forKey: "verification_method")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct Affirm: Encodable {
                    public var setupFutureUsage: SetupFutureUsage?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                    }

                    public init(setupFutureUsage: SetupFutureUsage? = nil) {
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct AfterpayClearpay: Encodable {
                    public var setupFutureUsage: SetupFutureUsage?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                    }

                    public init(setupFutureUsage: SetupFutureUsage? = nil) {
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct Alipay: Encodable {
                    public var setupFutureUsage: SetupFutureUsage?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                    }

                    public init(setupFutureUsage: SetupFutureUsage? = nil) {
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct AuBecsDebit: Encodable {
                    public var setupFutureUsage: SetupFutureUsage?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                    }

                    public init(setupFutureUsage: SetupFutureUsage? = nil) {
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct BacsDebit: Encodable {
                    public var setupFutureUsage: SetupFutureUsage?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                        case offSession = "off_session"
                        case onSession = "on_session"
                    }

                    public init(setupFutureUsage: SetupFutureUsage? = nil) {
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct Bancontact: Encodable {
                    public var setupFutureUsage: SetupFutureUsage?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                    }

                    public init(setupFutureUsage: SetupFutureUsage? = nil) {
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct Boleto: Encodable {
                    public var expiresAfterDays: Int?
                    public var setupFutureUsage: SetupFutureUsage?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                        case offSession = "off_session"
                        case onSession = "on_session"
                    }

                    public init(expiresAfterDays: Int? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                        self.expiresAfterDays = expiresAfterDays
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(expiresAfterDays, forKey: "expires_after_days")
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct Card: Encodable {
                    /// Installments_param
                    public var installments: Installments?
                    public var setupFutureUsage: SetupFutureUsage?
                    public var statementDescriptorSuffixKana: String?
                    public var statementDescriptorSuffixKanji: String?

                    /// Installments_param
                    public struct Installments: Encodable {
                        public var isEnabled: Bool?
                        public var plan: Plan?

                        public struct Plan: Encodable {
                            /// Installment_plan
                            public var a: A?
                            public var b: B?

                            /// Installment_plan
                            public struct A: Encodable {
                                public var count: Int
                                public var interval: Interval
                                public var type: `Type`

                                public enum Interval: String, Codable, CaseIterable {
                                    case month
                                }

                                public enum `Type`: String, Codable, CaseIterable {
                                    case fixedCount = "fixed_count"
                                }

                                public init(count: Int, interval: Interval, type: `Type`) {
                                    self.count = count
                                    self.interval = interval
                                    self.type = type
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(count, forKey: "count")
                                    encoder.encode(interval, forKey: "interval")
                                    encoder.encode(type, forKey: "type")
                                    return encoder.items
                                }
                            }

                            public enum B: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(a: A? = nil, b: B? = nil) {
                                self.a = a
                                self.b = b
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(a, forKey: "a")
                                encoder.encode(b, forKey: "b")
                                return encoder.items
                            }
                        }

                        public init(isEnabled: Bool? = nil, plan: Plan? = nil) {
                            self.isEnabled = isEnabled
                            self.plan = plan
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(isEnabled, forKey: "enabled")
                            encoder.encode(plan, forKey: "plan")
                            return encoder.items
                        }
                    }

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case offSession = "off_session"
                        case onSession = "on_session"
                    }

                    public init(installments: Installments? = nil, setupFutureUsage: SetupFutureUsage? = nil, statementDescriptorSuffixKana: String? = nil, statementDescriptorSuffixKanji: String? = nil) {
                        self.installments = installments
                        self.setupFutureUsage = setupFutureUsage
                        self.statementDescriptorSuffixKana = statementDescriptorSuffixKana
                        self.statementDescriptorSuffixKanji = statementDescriptorSuffixKanji
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(installments, forKey: "installments")
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        encoder.encode(statementDescriptorSuffixKana, forKey: "statement_descriptor_suffix_kana")
                        encoder.encode(statementDescriptorSuffixKanji, forKey: "statement_descriptor_suffix_kanji")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct CustomerBalance: Encodable {
                    /// Bank_transfer_param
                    public var bankTransfer: BankTransfer?
                    public var fundingType: FundingType?
                    public var setupFutureUsage: SetupFutureUsage?

                    /// Bank_transfer_param
                    public struct BankTransfer: Encodable {
                        /// Eu_bank_transfer_params
                        public var euBankTransfer: EuBankTransfer?
                        public var requestedAddressTypes: [RequestedAddressType]?
                        public var type: `Type`

                        /// Eu_bank_transfer_params
                        public struct EuBankTransfer: Encodable {
                            public var country: String

                            public init(country: String) {
                                self.country = country
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(country, forKey: "country")
                                return encoder.items
                            }
                        }

                        public enum RequestedAddressType: String, Codable, CaseIterable {
                            case iban
                            case sepa
                            case sortCode = "sort_code"
                            case spei
                            case zengin
                        }

                        public enum `Type`: String, Codable, CaseIterable {
                            case euBankTransfer = "eu_bank_transfer"
                            case gbBankTransfer = "gb_bank_transfer"
                            case jpBankTransfer = "jp_bank_transfer"
                            case mxBankTransfer = "mx_bank_transfer"
                        }

                        public init(euBankTransfer: EuBankTransfer? = nil, requestedAddressTypes: [RequestedAddressType]? = nil, type: `Type`) {
                            self.euBankTransfer = euBankTransfer
                            self.requestedAddressTypes = requestedAddressTypes
                            self.type = type
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(euBankTransfer, forKey: "eu_bank_transfer")
                            encoder.encode(requestedAddressTypes, forKey: "requested_address_types")
                            encoder.encode(type, forKey: "type")
                            return encoder.items
                        }
                    }

                    public enum FundingType: String, Codable, CaseIterable {
                        case bankTransfer = "bank_transfer"
                    }

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                    }

                    public init(bankTransfer: BankTransfer? = nil, fundingType: FundingType? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                        self.bankTransfer = bankTransfer
                        self.fundingType = fundingType
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bankTransfer, forKey: "bank_transfer")
                        encoder.encode(fundingType, forKey: "funding_type")
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct Eps: Encodable {
                    public var setupFutureUsage: SetupFutureUsage?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                    }

                    public init(setupFutureUsage: SetupFutureUsage? = nil) {
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct Fpx: Encodable {
                    public var setupFutureUsage: SetupFutureUsage?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                    }

                    public init(setupFutureUsage: SetupFutureUsage? = nil) {
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct Giropay: Encodable {
                    public var setupFutureUsage: SetupFutureUsage?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                    }

                    public init(setupFutureUsage: SetupFutureUsage? = nil) {
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct Grabpay: Encodable {
                    public var setupFutureUsage: SetupFutureUsage?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                    }

                    public init(setupFutureUsage: SetupFutureUsage? = nil) {
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct Ideal: Encodable {
                    public var setupFutureUsage: SetupFutureUsage?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                    }

                    public init(setupFutureUsage: SetupFutureUsage? = nil) {
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct Klarna: Encodable {
                    public var setupFutureUsage: SetupFutureUsage?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                    }

                    public init(setupFutureUsage: SetupFutureUsage? = nil) {
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct Konbini: Encodable {
                    public var expiresAfterDays: Int?
                    public var setupFutureUsage: SetupFutureUsage?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                    }

                    public init(expiresAfterDays: Int? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                        self.expiresAfterDays = expiresAfterDays
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(expiresAfterDays, forKey: "expires_after_days")
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct Oxxo: Encodable {
                    public var expiresAfterDays: Int?
                    public var setupFutureUsage: SetupFutureUsage?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                    }

                    public init(expiresAfterDays: Int? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                        self.expiresAfterDays = expiresAfterDays
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(expiresAfterDays, forKey: "expires_after_days")
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct P24: Encodable {
                    public var setupFutureUsage: SetupFutureUsage?
                    public var isTosShownAndAccepted: Bool?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                    }

                    public init(setupFutureUsage: SetupFutureUsage? = nil, isTosShownAndAccepted: Bool? = nil) {
                        self.setupFutureUsage = setupFutureUsage
                        self.isTosShownAndAccepted = isTosShownAndAccepted
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        encoder.encode(isTosShownAndAccepted, forKey: "tos_shown_and_accepted")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct Paynow: Encodable {
                    public var setupFutureUsage: SetupFutureUsage?
                    public var isTosShownAndAccepted: Bool?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                    }

                    public init(setupFutureUsage: SetupFutureUsage? = nil, isTosShownAndAccepted: Bool? = nil) {
                        self.setupFutureUsage = setupFutureUsage
                        self.isTosShownAndAccepted = isTosShownAndAccepted
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        encoder.encode(isTosShownAndAccepted, forKey: "tos_shown_and_accepted")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct SepaDebit: Encodable {
                    public var setupFutureUsage: SetupFutureUsage?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                        case offSession = "off_session"
                        case onSession = "on_session"
                    }

                    public init(setupFutureUsage: SetupFutureUsage? = nil) {
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct Sofort: Encodable {
                    public var setupFutureUsage: SetupFutureUsage?

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                    }

                    public init(setupFutureUsage: SetupFutureUsage? = nil) {
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct UsBankAccount: Encodable {
                    /// Linked_account_options_param
                    public var financialConnections: FinancialConnections?
                    public var setupFutureUsage: SetupFutureUsage?
                    public var verificationMethod: VerificationMethod?

                    /// Linked_account_options_param
                    public struct FinancialConnections: Encodable {
                        public var permissions: [Permission]?

                        public enum Permission: String, Codable, CaseIterable {
                            case balances
                            case ownership
                            case paymentMethod = "payment_method"
                            case transactions
                        }

                        public init(permissions: [Permission]? = nil) {
                            self.permissions = permissions
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(permissions, forKey: "permissions")
                            return encoder.items
                        }
                    }

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                        case offSession = "off_session"
                        case onSession = "on_session"
                    }

                    public enum VerificationMethod: String, Codable, CaseIterable {
                        case automatic
                        case instant
                    }

                    public init(financialConnections: FinancialConnections? = nil, setupFutureUsage: SetupFutureUsage? = nil, verificationMethod: VerificationMethod? = nil) {
                        self.financialConnections = financialConnections
                        self.setupFutureUsage = setupFutureUsage
                        self.verificationMethod = verificationMethod
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(financialConnections, forKey: "financial_connections")
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        encoder.encode(verificationMethod, forKey: "verification_method")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct WechatPay: Encodable {
                    public var appID: String?
                    public var client: Client
                    public var setupFutureUsage: SetupFutureUsage?

                    public enum Client: String, Codable, CaseIterable {
                        case android
                        case ios
                        case web
                    }

                    public enum SetupFutureUsage: String, Codable, CaseIterable {
                        case `none`
                    }

                    public init(appID: String? = nil, client: Client, setupFutureUsage: SetupFutureUsage? = nil) {
                        self.appID = appID
                        self.client = client
                        self.setupFutureUsage = setupFutureUsage
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(appID, forKey: "app_id")
                        encoder.encode(client, forKey: "client")
                        encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                        return encoder.items
                    }
                }

                public init(acssDebit: AcssDebit? = nil, affirm: Affirm? = nil, afterpayClearpay: AfterpayClearpay? = nil, alipay: Alipay? = nil, auBecsDebit: AuBecsDebit? = nil, bacsDebit: BacsDebit? = nil, bancontact: Bancontact? = nil, boleto: Boleto? = nil, card: Card? = nil, customerBalance: CustomerBalance? = nil, eps: Eps? = nil, fpx: Fpx? = nil, giropay: Giropay? = nil, grabpay: Grabpay? = nil, ideal: Ideal? = nil, klarna: Klarna? = nil, konbini: Konbini? = nil, oxxo: Oxxo? = nil, p24: P24? = nil, paynow: Paynow? = nil, sepaDebit: SepaDebit? = nil, sofort: Sofort? = nil, usBankAccount: UsBankAccount? = nil, wechatPay: WechatPay? = nil) {
                    self.acssDebit = acssDebit
                    self.affirm = affirm
                    self.afterpayClearpay = afterpayClearpay
                    self.alipay = alipay
                    self.auBecsDebit = auBecsDebit
                    self.bacsDebit = bacsDebit
                    self.bancontact = bancontact
                    self.boleto = boleto
                    self.card = card
                    self.customerBalance = customerBalance
                    self.eps = eps
                    self.fpx = fpx
                    self.giropay = giropay
                    self.grabpay = grabpay
                    self.ideal = ideal
                    self.klarna = klarna
                    self.konbini = konbini
                    self.oxxo = oxxo
                    self.p24 = p24
                    self.paynow = paynow
                    self.sepaDebit = sepaDebit
                    self.sofort = sofort
                    self.usBankAccount = usBankAccount
                    self.wechatPay = wechatPay
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acssDebit, forKey: "acss_debit")
                    encoder.encode(affirm, forKey: "affirm")
                    encoder.encode(afterpayClearpay, forKey: "afterpay_clearpay")
                    encoder.encode(alipay, forKey: "alipay")
                    encoder.encode(auBecsDebit, forKey: "au_becs_debit")
                    encoder.encode(bacsDebit, forKey: "bacs_debit")
                    encoder.encode(bancontact, forKey: "bancontact")
                    encoder.encode(boleto, forKey: "boleto")
                    encoder.encode(card, forKey: "card")
                    encoder.encode(customerBalance, forKey: "customer_balance")
                    encoder.encode(eps, forKey: "eps")
                    encoder.encode(fpx, forKey: "fpx")
                    encoder.encode(giropay, forKey: "giropay")
                    encoder.encode(grabpay, forKey: "grabpay")
                    encoder.encode(ideal, forKey: "ideal")
                    encoder.encode(klarna, forKey: "klarna")
                    encoder.encode(konbini, forKey: "konbini")
                    encoder.encode(oxxo, forKey: "oxxo")
                    encoder.encode(p24, forKey: "p24")
                    encoder.encode(paynow, forKey: "paynow")
                    encoder.encode(sepaDebit, forKey: "sepa_debit")
                    encoder.encode(sofort, forKey: "sofort")
                    encoder.encode(usBankAccount, forKey: "us_bank_account")
                    encoder.encode(wechatPay, forKey: "wechat_pay")
                    return encoder.items
                }
            }

            public enum PaymentMethodType: String, Codable, CaseIterable {
                case acssDebit = "acss_debit"
                case affirm
                case afterpayClearpay = "afterpay_clearpay"
                case alipay
                case auBecsDebit = "au_becs_debit"
                case bacsDebit = "bacs_debit"
                case bancontact
                case blik
                case boleto
                case card
                case customerBalance = "customer_balance"
                case eps
                case fpx
                case giropay
                case grabpay
                case ideal
                case klarna
                case konbini
                case oxxo
                case p24
                case paynow
                case promptpay
                case sepaDebit = "sepa_debit"
                case sofort
                case usBankAccount = "us_bank_account"
                case wechatPay = "wechat_pay"
            }

            /// Phone_number_collection_params
            ///
            /// Controls phone number collection settings for the session.
            /// 
            /// We recommend that you review your privacy policy and check with your legal contacts
            /// before using this feature. Learn more about [collecting phone numbers with Checkout](https://stripe.com/docs/payments/checkout/phone-numbers).
            public struct PhoneNumberCollection: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Setup_intent_data_param
            ///
            /// A subset of parameters to be passed to SetupIntent creation for Checkout Sessions in `setup` mode.
            public struct SetupIntentData: Encodable {
                public var description: String?
                public var metadata: [String: String]?
                public var onBehalfOf: String?

                public init(description: String? = nil, metadata: [String: String]? = nil, onBehalfOf: String? = nil) {
                    self.description = description
                    self.metadata = metadata
                    self.onBehalfOf = onBehalfOf
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(description, forKey: "description")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(onBehalfOf, forKey: "on_behalf_of")
                    return encoder.items
                }
            }

            /// Shipping_address_collection_params
            ///
            /// When set, provides configuration for Checkout to collect a shipping address from a customer.
            public struct ShippingAddressCollection: Encodable {
                public var allowedCountries: [AllowedCountry]

                public enum AllowedCountry: String, Codable, CaseIterable {
                    case ac = "AC"
                    case ad = "AD"
                    case ae = "AE"
                    case af = "AF"
                    case ag = "AG"
                    case ai = "AI"
                    case al = "AL"
                    case am = "AM"
                    case ao = "AO"
                    case aq = "AQ"
                    case ar = "AR"
                    case at = "AT"
                    case au = "AU"
                    case aw = "AW"
                    case ax = "AX"
                    case az = "AZ"
                    case ba = "BA"
                    case bb = "BB"
                    case bd = "BD"
                    case be = "BE"
                    case bf = "BF"
                    case bg = "BG"
                    case bh = "BH"
                    case bi = "BI"
                    case bj = "BJ"
                    case bl = "BL"
                    case bm = "BM"
                    case bn = "BN"
                    case bo = "BO"
                    case bq = "BQ"
                    case br = "BR"
                    case bs = "BS"
                    case bt = "BT"
                    case bv = "BV"
                    case bw = "BW"
                    case by = "BY"
                    case bz = "BZ"
                    case ca = "CA"
                    case cd = "CD"
                    case cf = "CF"
                    case cg = "CG"
                    case ch = "CH"
                    case ci = "CI"
                    case ck = "CK"
                    case cl = "CL"
                    case cm = "CM"
                    case cn = "CN"
                    case co = "CO"
                    case cr = "CR"
                    case cv = "CV"
                    case cw = "CW"
                    case cy = "CY"
                    case cz = "CZ"
                    case de = "DE"
                    case dj = "DJ"
                    case dk = "DK"
                    case dm = "DM"
                    case `do` = "DO"
                    case dz = "DZ"
                    case ec = "EC"
                    case ee = "EE"
                    case eg = "EG"
                    case eh = "EH"
                    case er = "ER"
                    case es = "ES"
                    case et = "ET"
                    case fi = "FI"
                    case fj = "FJ"
                    case fk = "FK"
                    case fo = "FO"
                    case fr = "FR"
                    case ga = "GA"
                    case gb = "GB"
                    case gd = "GD"
                    case ge = "GE"
                    case gf = "GF"
                    case gg = "GG"
                    case gh = "GH"
                    case gi = "GI"
                    case gl = "GL"
                    case gm = "GM"
                    case gn = "GN"
                    case gp = "GP"
                    case gq = "GQ"
                    case gr = "GR"
                    case gs = "GS"
                    case gt = "GT"
                    case gu = "GU"
                    case gw = "GW"
                    case gy = "GY"
                    case hk = "HK"
                    case hn = "HN"
                    case hr = "HR"
                    case ht = "HT"
                    case hu = "HU"
                    case id = "ID"
                    case ie = "IE"
                    case il = "IL"
                    case im = "IM"
                    case `in` = "IN"
                    case io = "IO"
                    case iq = "IQ"
                    case `is` = "IS"
                    case it = "IT"
                    case je = "JE"
                    case jm = "JM"
                    case jo = "JO"
                    case jp = "JP"
                    case ke = "KE"
                    case kg = "KG"
                    case kh = "KH"
                    case ki = "KI"
                    case km = "KM"
                    case kn = "KN"
                    case kr = "KR"
                    case kw = "KW"
                    case ky = "KY"
                    case kz = "KZ"
                    case la = "LA"
                    case lb = "LB"
                    case lc = "LC"
                    case li = "LI"
                    case lk = "LK"
                    case lr = "LR"
                    case ls = "LS"
                    case lt = "LT"
                    case lu = "LU"
                    case lv = "LV"
                    case ly = "LY"
                    case ma = "MA"
                    case mc = "MC"
                    case md = "MD"
                    case me = "ME"
                    case mf = "MF"
                    case mg = "MG"
                    case mk = "MK"
                    case ml = "ML"
                    case mm = "MM"
                    case mn = "MN"
                    case mo = "MO"
                    case mq = "MQ"
                    case mr = "MR"
                    case ms = "MS"
                    case mt = "MT"
                    case mu = "MU"
                    case mv = "MV"
                    case mw = "MW"
                    case mx = "MX"
                    case my = "MY"
                    case mz = "MZ"
                    case na = "NA"
                    case nc = "NC"
                    case ne = "NE"
                    case ng = "NG"
                    case ni = "NI"
                    case nl = "NL"
                    case no = "NO"
                    case np = "NP"
                    case nr = "NR"
                    case nu = "NU"
                    case nz = "NZ"
                    case om = "OM"
                    case pa = "PA"
                    case pe = "PE"
                    case pf = "PF"
                    case pg = "PG"
                    case ph = "PH"
                    case pk = "PK"
                    case pl = "PL"
                    case pm = "PM"
                    case pn = "PN"
                    case pr = "PR"
                    case ps = "PS"
                    case pt = "PT"
                    case py = "PY"
                    case qa = "QA"
                    case re = "RE"
                    case ro = "RO"
                    case rs = "RS"
                    case ru = "RU"
                    case rw = "RW"
                    case sa = "SA"
                    case sb = "SB"
                    case sc = "SC"
                    case se = "SE"
                    case sg = "SG"
                    case sh = "SH"
                    case si = "SI"
                    case sj = "SJ"
                    case sk = "SK"
                    case sl = "SL"
                    case sm = "SM"
                    case sn = "SN"
                    case so = "SO"
                    case sr = "SR"
                    case ss = "SS"
                    case st = "ST"
                    case sv = "SV"
                    case sx = "SX"
                    case sz = "SZ"
                    case ta = "TA"
                    case tc = "TC"
                    case td = "TD"
                    case tf = "TF"
                    case tg = "TG"
                    case th = "TH"
                    case tj = "TJ"
                    case tk = "TK"
                    case tl = "TL"
                    case tm = "TM"
                    case tn = "TN"
                    case to = "TO"
                    case tr = "TR"
                    case tt = "TT"
                    case tv = "TV"
                    case tw = "TW"
                    case tz = "TZ"
                    case ua = "UA"
                    case ug = "UG"
                    case us = "US"
                    case uy = "UY"
                    case uz = "UZ"
                    case va = "VA"
                    case vc = "VC"
                    case ve = "VE"
                    case vg = "VG"
                    case vn = "VN"
                    case vu = "VU"
                    case wf = "WF"
                    case ws = "WS"
                    case xk = "XK"
                    case ye = "YE"
                    case yt = "YT"
                    case za = "ZA"
                    case zm = "ZM"
                    case zw = "ZW"
                    case zz = "ZZ"
                }

                public init(allowedCountries: [AllowedCountry]) {
                    self.allowedCountries = allowedCountries
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(allowedCountries, forKey: "allowed_countries")
                    return encoder.items
                }
            }

            /// Shipping_option_params
            public struct ShippingOption: Encodable {
                public var shippingRate: String?
                /// Method_params
                public var shippingRateData: ShippingRateData?

                /// Method_params
                public struct ShippingRateData: Encodable {
                    /// Delivery_estimate
                    public var deliveryEstimate: DeliveryEstimate?
                    public var displayName: String
                    /// Fixed_amount
                    public var fixedAmount: FixedAmount?
                    public var metadata: [String: String]?
                    public var taxBehavior: TaxBehavior?
                    public var taxCode: String?
                    public var type: `Type`?

                    /// Delivery_estimate
                    public struct DeliveryEstimate: Encodable {
                        /// Delivery_estimate_bound
                        public var maximum: Maximum?
                        /// Delivery_estimate_bound
                        public var minimum: Minimum?

                        /// Delivery_estimate_bound
                        public struct Maximum: Encodable {
                            public var unit: Unit
                            public var value: Int

                            public enum Unit: String, Codable, CaseIterable {
                                case businessDay = "business_day"
                                case day
                                case hour
                                case month
                                case week
                            }

                            public init(unit: Unit, value: Int) {
                                self.unit = unit
                                self.value = value
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(unit, forKey: "unit")
                                encoder.encode(value, forKey: "value")
                                return encoder.items
                            }
                        }

                        /// Delivery_estimate_bound
                        public struct Minimum: Encodable {
                            public var unit: Unit
                            public var value: Int

                            public enum Unit: String, Codable, CaseIterable {
                                case businessDay = "business_day"
                                case day
                                case hour
                                case month
                                case week
                            }

                            public init(unit: Unit, value: Int) {
                                self.unit = unit
                                self.value = value
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(unit, forKey: "unit")
                                encoder.encode(value, forKey: "value")
                                return encoder.items
                            }
                        }

                        public init(maximum: Maximum? = nil, minimum: Minimum? = nil) {
                            self.maximum = maximum
                            self.minimum = minimum
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(maximum, forKey: "maximum")
                            encoder.encode(minimum, forKey: "minimum")
                            return encoder.items
                        }
                    }

                    /// Fixed_amount
                    public struct FixedAmount: Encodable {
                        public var amount: Int
                        public var currency: String
                        public var currencyOptions: [String: CurrencyOption]?

                        /// Currency_option
                        public struct CurrencyOption: Encodable {
                            public var amount: Int
                            public var taxBehavior: TaxBehavior?

                            public enum TaxBehavior: String, Codable, CaseIterable {
                                case exclusive
                                case inclusive
                                case unspecified
                            }

                            public init(amount: Int, taxBehavior: TaxBehavior? = nil) {
                                self.amount = amount
                                self.taxBehavior = taxBehavior
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(amount, forKey: "amount")
                                encoder.encode(taxBehavior, forKey: "tax_behavior")
                                return encoder.items
                            }
                        }

                        public init(amount: Int, currency: String, currencyOptions: [String: CurrencyOption]? = nil) {
                            self.amount = amount
                            self.currency = currency
                            self.currencyOptions = currencyOptions
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(amount, forKey: "amount")
                            encoder.encode(currency, forKey: "currency")
                            encoder.encode(currencyOptions, forKey: "currency_options")
                            return encoder.items
                        }
                    }

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public enum `Type`: String, Codable, CaseIterable {
                        case fixedAmount = "fixed_amount"
                    }

                    public init(deliveryEstimate: DeliveryEstimate? = nil, displayName: String, fixedAmount: FixedAmount? = nil, metadata: [String: String]? = nil, taxBehavior: TaxBehavior? = nil, taxCode: String? = nil, type: `Type`? = nil) {
                        self.deliveryEstimate = deliveryEstimate
                        self.displayName = displayName
                        self.fixedAmount = fixedAmount
                        self.metadata = metadata
                        self.taxBehavior = taxBehavior
                        self.taxCode = taxCode
                        self.type = type
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(deliveryEstimate, forKey: "delivery_estimate")
                        encoder.encode(displayName, forKey: "display_name")
                        encoder.encode(fixedAmount, forKey: "fixed_amount")
                        encoder.encode(metadata, forKey: "metadata")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(taxCode, forKey: "tax_code")
                        encoder.encode(type, forKey: "type")
                        return encoder.items
                    }
                }

                public init(shippingRate: String? = nil, shippingRateData: ShippingRateData? = nil) {
                    self.shippingRate = shippingRate
                    self.shippingRateData = shippingRateData
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(shippingRate, forKey: "shipping_rate")
                    encoder.encode(shippingRateData, forKey: "shipping_rate_data")
                    return encoder.items
                }
            }

            /// Describes the type of transaction being performed by Checkout in order to customize
            /// relevant text on the page, such as the submit button. `submit_type` can only be
            /// specified on Checkout Sessions in `payment` mode, but not Checkout Sessions
            /// in `subscription` or `setup` mode.
            public enum SubmitType: String, Codable, CaseIterable {
                case auto
                case book
                case donate
                case pay
            }

            /// Subscription_data_params
            ///
            /// A subset of parameters to be passed to subscription creation for Checkout Sessions in `subscription` mode.
            public struct SubscriptionData: Encodable {
                public var applicationFeePercent: Double?
                public var defaultTaxRates: [String]?
                public var description: String?
                public var items: [Item]?
                public var metadata: [String: String]?
                /// Transfer_data_specs
                public var transferData: TransferData?
                public var trialEnd: Int?
                public var trialPeriodDays: Int?

                /// Subscription_data_item_param
                public struct Item: Encodable {
                    public var plan: String
                    public var quantity: Int?
                    public var taxRates: [String]?

                    public init(plan: String, quantity: Int? = nil, taxRates: [String]? = nil) {
                        self.plan = plan
                        self.quantity = quantity
                        self.taxRates = taxRates
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(plan, forKey: "plan")
                        encoder.encode(quantity, forKey: "quantity")
                        encoder.encode(taxRates, forKey: "tax_rates")
                        return encoder.items
                    }
                }

                /// Transfer_data_specs
                public struct TransferData: Encodable {
                    public var amountPercent: Double?
                    public var destination: String

                    public init(amountPercent: Double? = nil, destination: String) {
                        self.amountPercent = amountPercent
                        self.destination = destination
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amountPercent, forKey: "amount_percent")
                        encoder.encode(destination, forKey: "destination")
                        return encoder.items
                    }
                }

                public init(applicationFeePercent: Double? = nil, defaultTaxRates: [String]? = nil, description: String? = nil, items: [Item]? = nil, metadata: [String: String]? = nil, transferData: TransferData? = nil, trialEnd: Int? = nil, trialPeriodDays: Int? = nil) {
                    self.applicationFeePercent = applicationFeePercent
                    self.defaultTaxRates = defaultTaxRates
                    self.description = description
                    self.items = items
                    self.metadata = metadata
                    self.transferData = transferData
                    self.trialEnd = trialEnd
                    self.trialPeriodDays = trialPeriodDays
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                    encoder.encode(defaultTaxRates, forKey: "default_tax_rates")
                    encoder.encode(description, forKey: "description")
                    encoder.encode(items, forKey: "items")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(transferData, forKey: "transfer_data")
                    encoder.encode(trialEnd, forKey: "trial_end")
                    encoder.encode(trialPeriodDays, forKey: "trial_period_days")
                    return encoder.items
                }
            }

            /// Tax_id_collection_params
            ///
            /// Controls tax ID collection settings for the session.
            public struct TaxIDCollection: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            public init(afterExpiration: AfterExpiration? = nil, allowPromotionCodes: Bool? = nil, automaticTax: AutomaticTax? = nil, billingAddressCollection: BillingAddressCollection? = nil, cancelURL: String, clientReferenceID: String? = nil, consentCollection: ConsentCollection? = nil, currency: String? = nil, customer: String? = nil, customerCreation: CustomerCreation? = nil, customerEmail: String? = nil, customerUpdate: CustomerUpdate? = nil, discounts: [Discount]? = nil, expand: [String]? = nil, expiresAt: Int? = nil, lineItems: [LineItem]? = nil, locale: Locale? = nil, metadata: [String: String]? = nil, mode: Mode? = nil, paymentIntentData: PaymentIntentData? = nil, paymentMethodCollection: PaymentMethodCollection? = nil, paymentMethodOptions: PaymentMethodOptions? = nil, paymentMethodTypes: [PaymentMethodType]? = nil, phoneNumberCollection: PhoneNumberCollection? = nil, setupIntentData: SetupIntentData? = nil, shippingAddressCollection: ShippingAddressCollection? = nil, shippingOptions: [ShippingOption]? = nil, submitType: SubmitType? = nil, subscriptionData: SubscriptionData? = nil, successURL: String, taxIDCollection: TaxIDCollection? = nil) {
                self.afterExpiration = afterExpiration
                self.allowPromotionCodes = allowPromotionCodes
                self.automaticTax = automaticTax
                self.billingAddressCollection = billingAddressCollection
                self.cancelURL = cancelURL
                self.clientReferenceID = clientReferenceID
                self.consentCollection = consentCollection
                self.currency = currency
                self.customer = customer
                self.customerCreation = customerCreation
                self.customerEmail = customerEmail
                self.customerUpdate = customerUpdate
                self.discounts = discounts
                self.expand = expand
                self.expiresAt = expiresAt
                self.lineItems = lineItems
                self.locale = locale
                self.metadata = metadata
                self.mode = mode
                self.paymentIntentData = paymentIntentData
                self.paymentMethodCollection = paymentMethodCollection
                self.paymentMethodOptions = paymentMethodOptions
                self.paymentMethodTypes = paymentMethodTypes
                self.phoneNumberCollection = phoneNumberCollection
                self.setupIntentData = setupIntentData
                self.shippingAddressCollection = shippingAddressCollection
                self.shippingOptions = shippingOptions
                self.submitType = submitType
                self.subscriptionData = subscriptionData
                self.successURL = successURL
                self.taxIDCollection = taxIDCollection
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(afterExpiration, forKey: "after_expiration")
                encoder.encode(allowPromotionCodes, forKey: "allow_promotion_codes")
                encoder.encode(automaticTax, forKey: "automatic_tax")
                encoder.encode(billingAddressCollection, forKey: "billing_address_collection")
                encoder.encode(cancelURL, forKey: "cancel_url")
                encoder.encode(clientReferenceID, forKey: "client_reference_id")
                encoder.encode(consentCollection, forKey: "consent_collection")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(customerCreation, forKey: "customer_creation")
                encoder.encode(customerEmail, forKey: "customer_email")
                encoder.encode(customerUpdate, forKey: "customer_update")
                encoder.encode(discounts, forKey: "discounts")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(expiresAt, forKey: "expires_at")
                encoder.encode(lineItems, forKey: "line_items")
                encoder.encode(locale, forKey: "locale")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(mode, forKey: "mode")
                encoder.encode(paymentIntentData, forKey: "payment_intent_data")
                encoder.encode(paymentMethodCollection, forKey: "payment_method_collection")
                encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                encoder.encode(phoneNumberCollection, forKey: "phone_number_collection")
                encoder.encode(setupIntentData, forKey: "setup_intent_data")
                encoder.encode(shippingAddressCollection, forKey: "shipping_address_collection")
                encoder.encode(shippingOptions, forKey: "shipping_options")
                encoder.encode(submitType, forKey: "submit_type")
                encoder.encode(subscriptionData, forKey: "subscription_data")
                encoder.encode(successURL, forKey: "success_url")
                encoder.encode(taxIDCollection, forKey: "tax_id_collection")
                return encoder.items
            }
        }
    }
}
