// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var invoices: Invoices {
        Invoices(path: "/v1/invoices")
    }

    public struct Invoices {
        /// Path: `/v1/invoices`
        public let path: String

        /// <p>You can list all invoices, or list the invoices for a specific customer. The invoices are returned sorted by creation date, with the most recently created invoices appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            Request(method: "GET", url: path, query: parameters?.asQuery, id: "GetInvoices")
        }

        /// InvoicesList
        public struct GetResponse: Decodable {
            public var data: [StripeKit.Invoice]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeKit.Invoice], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.data = try values.decode([StripeKit.Invoice].self, forKey: "data")
                self.hasMore = try values.decode(Bool.self, forKey: "has_more")
                self.object = try values.decode(Object.self, forKey: "object")
                self.url = try values.decode(String.self, forKey: "url")
            }
        }

        public struct GetParameters {
            public var collectionMethod: CollectionMethod?
            public var created: Created?
            public var customer: String?
            public var dueDate: DueDate?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var status: Status?
            public var subscription: String?

            public enum CollectionMethod: String, Codable, CaseIterable {
                case chargeAutomatically = "charge_automatically"
                case sendInvoice = "send_invoice"
            }

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public struct DueDate: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public enum Status: String, Codable, CaseIterable {
                case draft
                case `open`
                case paid
                case uncollectible
                case void
            }

            public init(collectionMethod: CollectionMethod? = nil, created: Created? = nil, customer: String? = nil, dueDate: DueDate? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, status: Status? = nil, subscription: String? = nil) {
                self.collectionMethod = collectionMethod
                self.created = created
                self.customer = customer
                self.dueDate = dueDate
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
                self.status = status
                self.subscription = subscription
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(collectionMethod, forKey: "collection_method")
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(customer, forKey: "customer")
                encoder.encode(dueDate, forKey: "due_date", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(status, forKey: "status")
                encoder.encode(subscription, forKey: "subscription")
                return encoder.items
            }
        }

        /// <p>This endpoint creates a draft invoice for a given customer. The draft invoice created pulls in all pending invoice items on that customer, including prorations. The invoice remains a draft until you <a href="#finalize_invoice">finalize</a> the invoice, which allows you to <a href="#pay_invoice">pay</a> or <a href="#send_invoice">send</a> the invoice to your customers.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeKit.Invoice> {
            Request(method: "POST", url: path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery, id: "PostInvoices")
        }

        public struct PostRequest: Encodable {
            /// The account tax IDs associated with the invoice. Only editable when the invoice is a draft.
            public var accountTaxIDs: AccountTaxIDs?
            /// A fee in cents (or local equivalent) that will be applied to the invoice and transferred to the application owner's Stripe account. The request must be made with an OAuth key or the Stripe-Account header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/billing/invoices/connect#collecting-fees).
            public var applicationFeeAmount: Int?
            /// Controls whether Stripe will perform [automatic collection](https://stripe.com/docs/billing/invoices/workflow/#auto_advance) of the invoice. When `false`, the invoice's state will not automatically advance without an explicit action.
            public var isAutoAdvance: Bool?
            /// Automatic_tax_param
            ///
            /// Settings for automatic tax lookup for this invoice.
            public var automaticTax: AutomaticTax?
            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this invoice using the default source attached to the customer. When sending an invoice, Stripe will email this invoice to the customer with payment instructions. Defaults to `charge_automatically`.
            public var collectionMethod: CollectionMethod?
            /// The currency to create this invoice in. Defaults to that of `customer` if not specified.
            public var currency: String?
            /// A list of up to 4 custom fields to be displayed on the invoice.
            public var customFields: CustomFields?
            /// The ID of the customer who will be billed.
            public var customer: String?
            /// The number of days from when the invoice is created until it is due. Valid only for invoices where `collection_method=send_invoice`.
            public var daysUntilDue: Int?
            /// ID of the default payment method for the invoice. It must belong to the customer associated with the invoice. If not set, defaults to the subscription's default payment method, if any, or to the default payment method in the customer's invoice settings.
            public var defaultPaymentMethod: String?
            /// ID of the default payment source for the invoice. It must belong to the customer associated with the invoice and be in a chargeable state. If not set, defaults to the subscription's default source, if any, or to the customer's default source.
            public var defaultSource: String?
            /// The tax rates that will apply to any line item that does not have `tax_rates` set.
            public var defaultTaxRates: [String]?
            /// An arbitrary string attached to the object. Often useful for displaying to users. Referenced as 'memo' in the Dashboard.
            public var description: String?
            /// The coupons to redeem into discounts for the invoice. If not specified, inherits the discount from the invoice's customer. Pass an empty string to avoid inheriting any discounts.
            public var discounts: Discounts?
            /// The date on which payment for this invoice is due. Valid only for invoices where `collection_method=send_invoice`.
            public var dueDate: Int?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Footer to be displayed on the invoice.
            public var footer: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The account (if any) for which the funds of the invoice payment are intended. If set, the invoice will be presented with the branding and support information of the specified account. See the [Invoices with Connect](https://stripe.com/docs/billing/invoices/connect) documentation for details.
            public var onBehalfOf: String?
            /// Payment_settings
            ///
            /// Configuration settings for the PaymentIntent that is generated when the invoice is finalized.
            public var paymentSettings: PaymentSettings?
            /// How to handle pending invoice items on invoice creation. One of `include` or `exclude`. `include` will include any pending invoice items, and will create an empty draft invoice if no pending invoice items exist. `exclude` will always create an empty invoice draft regardless if there are pending invoice items or not. Defaults to `exclude` if the parameter is omitted.
            public var pendingInvoiceItemsBehavior: PendingInvoiceItemsBehavior?
            /// Options for invoice PDF rendering.
            public var renderingOptions: RenderingOptions?
            /// Extra information about a charge for the customer's credit card statement. It must contain at least one letter. If not specified and this invoice is part of a subscription, the default `statement_descriptor` will be set to the first subscription item's product's `statement_descriptor`.
            public var statementDescriptor: String?
            /// The ID of the subscription to invoice, if any. If set, the created invoice will only include pending invoice items for that subscription and pending invoice items not associated with any subscription if `pending_invoice_items_behavior` is `include`. The subscription's billing cycle and regular subscription events won't be affected.
            public var subscription: String?
            /// Transfer_data_specs
            ///
            /// If specified, the funds from the invoice will be transferred to the destination and the ID of the resulting transfer will be found on the invoice's charge.
            public var transferData: TransferData?

            /// The account tax IDs associated with the invoice. Only editable when the invoice is a draft.
            public struct AccountTaxIDs: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Automatic_tax_param
            ///
            /// Settings for automatic tax lookup for this invoice.
            public struct AutomaticTax: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this invoice using the default source attached to the customer. When sending an invoice, Stripe will email this invoice to the customer with payment instructions. Defaults to `charge_automatically`.
            public enum CollectionMethod: String, Codable, CaseIterable {
                case chargeAutomatically = "charge_automatically"
                case sendInvoice = "send_invoice"
            }

            /// A list of up to 4 custom fields to be displayed on the invoice.
            public struct CustomFields: Encodable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Custom_field_params
                public struct PlaceholderItem: Encodable {
                    public var name: String
                    public var value: String

                    public init(name: String, value: String) {
                        self.name = name
                        self.value = value
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(name, forKey: "name")
                        encoder.encode(value, forKey: "value")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The coupons to redeem into discounts for the invoice. If not specified, inherits the discount from the invoice's customer. Pass an empty string to avoid inheriting any discounts.
            public struct Discounts: Encodable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Discounts_data_param
                public struct PlaceholderItem: Encodable {
                    public var coupon: String?
                    public var discount: String?

                    public init(coupon: String? = nil, discount: String? = nil) {
                        self.coupon = coupon
                        self.discount = discount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(coupon, forKey: "coupon")
                        encoder.encode(discount, forKey: "discount")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Payment_settings
            ///
            /// Configuration settings for the PaymentIntent that is generated when the invoice is finalized.
            public struct PaymentSettings: Encodable {
                public var defaultMandate: String?
                /// Payment_method_options
                public var paymentMethodOptions: PaymentMethodOptions?
                public var paymentMethodTypes: PaymentMethodTypes?

                /// Payment_method_options
                public struct PaymentMethodOptions: Encodable {
                    public var acssDebit: AcssDebit?
                    public var bancontact: Bancontact?
                    public var card: Card?
                    public var customerBalance: CustomerBalance?
                    public var konbini: Konbini?
                    public var usBankAccount: UsBankAccount?

                    public struct AcssDebit: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            /// Mandate_options_param
                            public var mandateOptions: MandateOptions?
                            public var verificationMethod: VerificationMethod?

                            /// Mandate_options_param
                            public struct MandateOptions: Encodable {
                                public var transactionType: TransactionType?

                                public enum TransactionType: String, Codable, CaseIterable {
                                    case business
                                    case personal
                                }

                                public init(transactionType: TransactionType? = nil) {
                                    self.transactionType = transactionType
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(transactionType, forKey: "transaction_type")
                                    return encoder.items
                                }
                            }

                            public enum VerificationMethod: String, Codable, CaseIterable {
                                case automatic
                                case instant
                                case microdeposits
                            }

                            public init(mandateOptions: MandateOptions? = nil, verificationMethod: VerificationMethod? = nil) {
                                self.mandateOptions = mandateOptions
                                self.verificationMethod = verificationMethod
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(mandateOptions, forKey: "mandate_options")
                                encoder.encode(verificationMethod, forKey: "verification_method")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Bancontact: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            public var preferredLanguage: PreferredLanguage?

                            public enum PreferredLanguage: String, Codable, CaseIterable {
                                case de
                                case en
                                case fr
                                case nl
                            }

                            public init(preferredLanguage: PreferredLanguage? = nil) {
                                self.preferredLanguage = preferredLanguage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(preferredLanguage, forKey: "preferred_language")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Card: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            /// Installments_param
                            public var installments: Installments?
                            public var requestThreeDSecure: RequestThreeDSecure?

                            /// Installments_param
                            public struct Installments: Encodable {
                                public var isEnabled: Bool?
                                public var plan: Plan?

                                public struct Plan: Encodable {
                                    /// Installment_plan
                                    public var a: A?
                                    public var b: B?

                                    /// Installment_plan
                                    public struct A: Encodable {
                                        public var count: Int
                                        public var interval: Interval
                                        public var type: `Type`

                                        public enum Interval: String, Codable, CaseIterable {
                                            case month
                                        }

                                        public enum `Type`: String, Codable, CaseIterable {
                                            case fixedCount = "fixed_count"
                                        }

                                        public init(count: Int, interval: Interval, type: `Type`) {
                                            self.count = count
                                            self.interval = interval
                                            self.type = type
                                        }

                                        public var asQuery: [(String, String?)] {
                                            let encoder = URLQueryEncoder()
                                            encoder.encode(count, forKey: "count")
                                            encoder.encode(interval, forKey: "interval")
                                            encoder.encode(type, forKey: "type")
                                            return encoder.items
                                        }
                                    }

                                    public enum B: String, Codable, CaseIterable {
                                        case empty = ""
                                    }

                                    public init(a: A? = nil, b: B? = nil) {
                                        self.a = a
                                        self.b = b
                                    }

                                    public var asQuery: [(String, String?)] {
                                        let encoder = URLQueryEncoder()
                                        encoder.encode(a, forKey: "a")
                                        encoder.encode(b, forKey: "b")
                                        return encoder.items
                                    }
                                }

                                public init(isEnabled: Bool? = nil, plan: Plan? = nil) {
                                    self.isEnabled = isEnabled
                                    self.plan = plan
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(isEnabled, forKey: "enabled")
                                    encoder.encode(plan, forKey: "plan")
                                    return encoder.items
                                }
                            }

                            public enum RequestThreeDSecure: String, Codable, CaseIterable {
                                case any
                                case automatic
                            }

                            public init(installments: Installments? = nil, requestThreeDSecure: RequestThreeDSecure? = nil) {
                                self.installments = installments
                                self.requestThreeDSecure = requestThreeDSecure
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(installments, forKey: "installments")
                                encoder.encode(requestThreeDSecure, forKey: "request_three_d_secure")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct CustomerBalance: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            /// Bank_transfer_param
                            public var bankTransfer: BankTransfer?
                            public var fundingType: String?

                            /// Bank_transfer_param
                            public struct BankTransfer: Encodable {
                                /// Eu_bank_transfer_param
                                public var euBankTransfer: EuBankTransfer?
                                public var type: String?

                                /// Eu_bank_transfer_param
                                public struct EuBankTransfer: Encodable {
                                    public var country: String

                                    public init(country: String) {
                                        self.country = country
                                    }

                                    public var asQuery: [(String, String?)] {
                                        let encoder = URLQueryEncoder()
                                        encoder.encode(country, forKey: "country")
                                        return encoder.items
                                    }
                                }

                                public init(euBankTransfer: EuBankTransfer? = nil, type: String? = nil) {
                                    self.euBankTransfer = euBankTransfer
                                    self.type = type
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(euBankTransfer, forKey: "eu_bank_transfer")
                                    encoder.encode(type, forKey: "type")
                                    return encoder.items
                                }
                            }

                            public init(bankTransfer: BankTransfer? = nil, fundingType: String? = nil) {
                                self.bankTransfer = bankTransfer
                                self.fundingType = fundingType
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(bankTransfer, forKey: "bank_transfer")
                                encoder.encode(fundingType, forKey: "funding_type")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Konbini: Encodable {
                        /// Invoice_payment_method_options_param
                        public var object: [String: AnyJSON]?
                        public var object2: Object2?

                        public enum Object2: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(object: [String: AnyJSON]? = nil, object2: Object2? = nil) {
                            self.object = object
                            self.object2 = object2
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(object, forKey: "object")
                            encoder.encode(object2, forKey: "object2")
                            return encoder.items
                        }
                    }

                    public struct UsBankAccount: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            /// Invoice_linked_account_options_param
                            public var financialConnections: FinancialConnections?
                            public var verificationMethod: VerificationMethod?

                            /// Invoice_linked_account_options_param
                            public struct FinancialConnections: Encodable {
                                public var permissions: [Permission]?

                                public enum Permission: String, Codable, CaseIterable {
                                    case balances
                                    case ownership
                                    case paymentMethod = "payment_method"
                                    case transactions
                                }

                                public init(permissions: [Permission]? = nil) {
                                    self.permissions = permissions
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(permissions, forKey: "permissions")
                                    return encoder.items
                                }
                            }

                            public enum VerificationMethod: String, Codable, CaseIterable {
                                case automatic
                                case instant
                                case microdeposits
                            }

                            public init(financialConnections: FinancialConnections? = nil, verificationMethod: VerificationMethod? = nil) {
                                self.financialConnections = financialConnections
                                self.verificationMethod = verificationMethod
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(financialConnections, forKey: "financial_connections")
                                encoder.encode(verificationMethod, forKey: "verification_method")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public init(acssDebit: AcssDebit? = nil, bancontact: Bancontact? = nil, card: Card? = nil, customerBalance: CustomerBalance? = nil, konbini: Konbini? = nil, usBankAccount: UsBankAccount? = nil) {
                        self.acssDebit = acssDebit
                        self.bancontact = bancontact
                        self.card = card
                        self.customerBalance = customerBalance
                        self.konbini = konbini
                        self.usBankAccount = usBankAccount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(acssDebit, forKey: "acss_debit")
                        encoder.encode(bancontact, forKey: "bancontact")
                        encoder.encode(card, forKey: "card")
                        encoder.encode(customerBalance, forKey: "customer_balance")
                        encoder.encode(konbini, forKey: "konbini")
                        encoder.encode(usBankAccount, forKey: "us_bank_account")
                        return encoder.items
                    }
                }

                public struct PaymentMethodTypes: Encodable {
                    public var placeholderItems: [PlaceholderItem]?
                    public var object: Object?

                    public enum PlaceholderItem: String, Codable, CaseIterable {
                        case achCreditTransfer = "ach_credit_transfer"
                        case achDebit = "ach_debit"
                        case acssDebit = "acss_debit"
                        case auBecsDebit = "au_becs_debit"
                        case bacsDebit = "bacs_debit"
                        case bancontact
                        case boleto
                        case card
                        case customerBalance = "customer_balance"
                        case fpx
                        case giropay
                        case grabpay
                        case ideal
                        case konbini
                        case link
                        case paynow
                        case promptpay
                        case sepaDebit = "sepa_debit"
                        case sofort
                        case usBankAccount = "us_bank_account"
                        case wechatPay = "wechat_pay"
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                        self.placeholderItems = placeholderItems
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(placeholderItems, forKey: "placeholderItems")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(defaultMandate: String? = nil, paymentMethodOptions: PaymentMethodOptions? = nil, paymentMethodTypes: PaymentMethodTypes? = nil) {
                    self.defaultMandate = defaultMandate
                    self.paymentMethodOptions = paymentMethodOptions
                    self.paymentMethodTypes = paymentMethodTypes
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(defaultMandate, forKey: "default_mandate")
                    encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                    encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                    return encoder.items
                }
            }

            /// How to handle pending invoice items on invoice creation. One of `include` or `exclude`. `include` will include any pending invoice items, and will create an empty draft invoice if no pending invoice items exist. `exclude` will always create an empty invoice draft regardless if there are pending invoice items or not. Defaults to `exclude` if the parameter is omitted.
            public enum PendingInvoiceItemsBehavior: String, Codable, CaseIterable {
                case exclude
                case include
                case includeAndRequire = "include_and_require"
            }

            /// Options for invoice PDF rendering.
            public struct RenderingOptions: Encodable {
                /// Rendering_options_param
                public var a: A?
                public var b: B?

                /// Rendering_options_param
                public struct A: Encodable {
                    public var amountTaxDisplay: AmountTaxDisplay?

                    public enum AmountTaxDisplay: String, Codable, CaseIterable {
                        case empty = ""
                        case excludeTax = "exclude_tax"
                        case includeInclusiveTax = "include_inclusive_tax"
                    }

                    public init(amountTaxDisplay: AmountTaxDisplay? = nil) {
                        self.amountTaxDisplay = amountTaxDisplay
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amountTaxDisplay, forKey: "amount_tax_display")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Transfer_data_specs
            ///
            /// If specified, the funds from the invoice will be transferred to the destination and the ID of the resulting transfer will be found on the invoice's charge.
            public struct TransferData: Encodable {
                public var amount: Int?
                public var destination: String

                public init(amount: Int? = nil, destination: String) {
                    self.amount = amount
                    self.destination = destination
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    encoder.encode(destination, forKey: "destination")
                    return encoder.items
                }
            }

            public init(accountTaxIDs: AccountTaxIDs? = nil, applicationFeeAmount: Int? = nil, isAutoAdvance: Bool? = nil, automaticTax: AutomaticTax? = nil, collectionMethod: CollectionMethod? = nil, currency: String? = nil, customFields: CustomFields? = nil, customer: String? = nil, daysUntilDue: Int? = nil, defaultPaymentMethod: String? = nil, defaultSource: String? = nil, defaultTaxRates: [String]? = nil, description: String? = nil, discounts: Discounts? = nil, dueDate: Int? = nil, expand: [String]? = nil, footer: String? = nil, metadata: Metadata? = nil, onBehalfOf: String? = nil, paymentSettings: PaymentSettings? = nil, pendingInvoiceItemsBehavior: PendingInvoiceItemsBehavior? = nil, renderingOptions: RenderingOptions? = nil, statementDescriptor: String? = nil, subscription: String? = nil, transferData: TransferData? = nil) {
                self.accountTaxIDs = accountTaxIDs
                self.applicationFeeAmount = applicationFeeAmount
                self.isAutoAdvance = isAutoAdvance
                self.automaticTax = automaticTax
                self.collectionMethod = collectionMethod
                self.currency = currency
                self.customFields = customFields
                self.customer = customer
                self.daysUntilDue = daysUntilDue
                self.defaultPaymentMethod = defaultPaymentMethod
                self.defaultSource = defaultSource
                self.defaultTaxRates = defaultTaxRates
                self.description = description
                self.discounts = discounts
                self.dueDate = dueDate
                self.expand = expand
                self.footer = footer
                self.metadata = metadata
                self.onBehalfOf = onBehalfOf
                self.paymentSettings = paymentSettings
                self.pendingInvoiceItemsBehavior = pendingInvoiceItemsBehavior
                self.renderingOptions = renderingOptions
                self.statementDescriptor = statementDescriptor
                self.subscription = subscription
                self.transferData = transferData
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(accountTaxIDs, forKey: "account_tax_ids")
                encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                encoder.encode(isAutoAdvance, forKey: "auto_advance")
                encoder.encode(automaticTax, forKey: "automatic_tax")
                encoder.encode(collectionMethod, forKey: "collection_method")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(customFields, forKey: "custom_fields")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(daysUntilDue, forKey: "days_until_due")
                encoder.encode(defaultPaymentMethod, forKey: "default_payment_method")
                encoder.encode(defaultSource, forKey: "default_source")
                encoder.encode(defaultTaxRates, forKey: "default_tax_rates")
                encoder.encode(description, forKey: "description")
                encoder.encode(discounts, forKey: "discounts")
                encoder.encode(dueDate, forKey: "due_date")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(footer, forKey: "footer")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(onBehalfOf, forKey: "on_behalf_of")
                encoder.encode(paymentSettings, forKey: "payment_settings")
                encoder.encode(pendingInvoiceItemsBehavior, forKey: "pending_invoice_items_behavior")
                encoder.encode(renderingOptions, forKey: "rendering_options")
                encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                encoder.encode(subscription, forKey: "subscription")
                encoder.encode(transferData, forKey: "transfer_data")
                return encoder.items
            }
        }
    }
}
