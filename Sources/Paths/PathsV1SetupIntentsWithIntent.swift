// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths.SetupIntents {
    public func intent(_ intent: String) -> WithIntent {
        WithIntent(path: "\(path)/\(intent)")
    }

    public struct WithIntent {
        /// Path: `/v1/setup_intents/{intent}`
        public let path: String

        /// <p>Retrieves the details of a SetupIntent that has previously been created. </p>
        /// 
        /// <p>Client-side retrieval using a publishable key is allowed when the <code>client_secret</code> is provided in the query string. </p>
        /// 
        /// <p>When retrieved with a publishable key, only a subset of properties will be returned. Please refer to the <a href="#setup_intent_object">SetupIntent</a> object reference for more details.</p>
        public func get(clientSecret: String? = nil, expand: [String]? = nil) -> Request<StripeKit.SetupIntent> {
            Request(method: "GET", url: path, query: makeGetQuery(clientSecret, expand), id: "GetSetupIntentsIntent")
        }

        private func makeGetQuery(_ clientSecret: String?, _ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(clientSecret, forKey: "client_secret")
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates a SetupIntent object.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeKit.SetupIntent> {
            Request(method: "POST", url: path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery, id: "PostSetupIntentsIntent")
        }

        public struct PostRequest: Encodable {
            /// If present, the SetupIntent's payment method will be attached to the in-context Stripe Account.
            /// 
            /// It can only be used for this Stripe Accountâ€™s own money movement flows like InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a Customer.
            public var isAttachToSelf: Bool?
            /// ID of the Customer this SetupIntent belongs to, if one exists.
            /// 
            /// If present, the SetupIntent's payment method will be attached to the Customer on successful setup. Payment methods attached to other Customers cannot be used with this SetupIntent.
            public var customer: String?
            /// An arbitrary string attached to the object. Often useful for displaying to users.
            public var description: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Indicates the directions of money movement for which this payment method is intended to be used.
            /// 
            /// Include `inbound` if you intend to use the payment method as the origin to pull funds from. Include `outbound` if you intend to use the payment method as the destination to send funds to. You can include both if you intend to use the payment method for both purposes.
            public var flowDirections: [FlowDirection]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// ID of the payment method (a PaymentMethod, Card, or saved Source object) to attach to this SetupIntent.
            public var paymentMethod: String?
            /// Payment_method_data_params
            ///
            /// When included, this hash creates a PaymentMethod that is set as the [`payment_method`](https://stripe.com/docs/api/setup_intents/object#setup_intent_object-payment_method)
            /// value in the SetupIntent.
            public var paymentMethodData: PaymentMethodData?
            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration for this SetupIntent.
            public var paymentMethodOptions: PaymentMethodOptions?
            /// The list of payment method types (e.g. card) that this SetupIntent is allowed to set up. If this is not provided, defaults to ["card"].
            public var paymentMethodTypes: [String]?

            public enum FlowDirection: String, Codable, CaseIterable {
                case inbound
                case outbound
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Payment_method_data_params
            ///
            /// When included, this hash creates a PaymentMethod that is set as the [`payment_method`](https://stripe.com/docs/api/setup_intents/object#setup_intent_object-payment_method)
            /// value in the SetupIntent.
            public struct PaymentMethodData: Encodable {
                /// Payment_method_param
                public var acssDebit: AcssDebit?
                /// Param
                public var affirm: [String: AnyJSON]?
                /// Param
                public var afterpayClearpay: [String: AnyJSON]?
                /// Param
                public var alipay: [String: AnyJSON]?
                /// Param
                public var auBecsDebit: AuBecsDebit?
                /// Param
                public var bacsDebit: BacsDebit?
                /// Param
                public var bancontact: [String: AnyJSON]?
                /// Billing_details_inner_params
                public var billingDetails: BillingDetails?
                /// Param
                public var blik: [String: AnyJSON]?
                /// Param
                public var boleto: Boleto?
                /// Param
                public var customerBalance: [String: AnyJSON]?
                /// Param
                public var eps: Eps?
                /// Param
                public var fpx: Fpx?
                /// Param
                public var giropay: [String: AnyJSON]?
                /// Param
                public var grabpay: [String: AnyJSON]?
                /// Param
                public var ideal: Ideal?
                /// Param
                public var interacPresent: [String: AnyJSON]?
                /// Param
                public var klarna: Klarna?
                /// Param
                public var konbini: [String: AnyJSON]?
                /// Param
                public var link: [String: AnyJSON]?
                public var metadata: [String: String]?
                /// Param
                public var oxxo: [String: AnyJSON]?
                /// Param
                public var p24: P24?
                /// Param
                public var paynow: [String: AnyJSON]?
                /// Param
                public var promptpay: [String: AnyJSON]?
                /// Radar_options
                public var radarOptions: RadarOptions?
                /// Param
                public var sepaDebit: SepaDebit?
                /// Param
                public var sofort: Sofort?
                public var type: `Type`
                /// Payment_method_param
                public var usBankAccount: UsBankAccount?
                /// Param
                public var wechatPay: [String: AnyJSON]?

                /// Payment_method_param
                public struct AcssDebit: Encodable {
                    public var accountNumber: String
                    public var institutionNumber: String
                    public var transitNumber: String

                    public init(accountNumber: String, institutionNumber: String, transitNumber: String) {
                        self.accountNumber = accountNumber
                        self.institutionNumber = institutionNumber
                        self.transitNumber = transitNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(institutionNumber, forKey: "institution_number")
                        encoder.encode(transitNumber, forKey: "transit_number")
                        return encoder.items
                    }
                }

                /// Param
                public struct AuBecsDebit: Encodable {
                    public var accountNumber: String
                    public var bsbNumber: String

                    public init(accountNumber: String, bsbNumber: String) {
                        self.accountNumber = accountNumber
                        self.bsbNumber = bsbNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(bsbNumber, forKey: "bsb_number")
                        return encoder.items
                    }
                }

                /// Param
                public struct BacsDebit: Encodable {
                    public var accountNumber: String?
                    public var sortCode: String?

                    public init(accountNumber: String? = nil, sortCode: String? = nil) {
                        self.accountNumber = accountNumber
                        self.sortCode = sortCode
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(sortCode, forKey: "sort_code")
                        return encoder.items
                    }
                }

                /// Billing_details_inner_params
                public struct BillingDetails: Encodable {
                    public var address: Address?
                    public var email: Email?
                    public var name: String?
                    public var phone: String?

                    public struct Address: Encodable {
                        /// Billing_details_address
                        public var a: A?
                        public var b: B?

                        /// Billing_details_address
                        public struct A: Encodable {
                            public var city: String?
                            public var country: String?
                            public var line1: String?
                            public var line2: String?
                            public var postalCode: String?
                            public var state: String?

                            public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                                self.city = city
                                self.country = country
                                self.line1 = line1
                                self.line2 = line2
                                self.postalCode = postalCode
                                self.state = state
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(city, forKey: "city")
                                encoder.encode(country, forKey: "country")
                                encoder.encode(line1, forKey: "line1")
                                encoder.encode(line2, forKey: "line2")
                                encoder.encode(postalCode, forKey: "postal_code")
                                encoder.encode(state, forKey: "state")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Email: Encodable {
                        public var string: String?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(string: String? = nil, object: Object? = nil) {
                            self.string = string
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(string, forKey: "string")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(address: Address? = nil, email: Email? = nil, name: String? = nil, phone: String? = nil) {
                        self.address = address
                        self.email = email
                        self.name = name
                        self.phone = phone
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(address, forKey: "address")
                        encoder.encode(email, forKey: "email")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(phone, forKey: "phone")
                        return encoder.items
                    }
                }

                /// Param
                public struct Boleto: Encodable {
                    public var taxID: String

                    public init(taxID: String) {
                        self.taxID = taxID
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(taxID, forKey: "tax_id")
                        return encoder.items
                    }
                }

                /// Param
                public struct Eps: Encodable {
                    public var bank: Bank?

                    public enum Bank: String, Codable, CaseIterable {
                        case arzteUndApothekerBank = "arzte_und_apotheker_bank"
                        case austrianAnadiBankAg = "austrian_anadi_bank_ag"
                        case bankAustria = "bank_austria"
                        case bankhausCarlSpangler = "bankhaus_carl_spangler"
                        case bankhausSchelhammerUndSchatteraAg = "bankhaus_schelhammer_und_schattera_ag"
                        case bawagPskAg = "bawag_psk_ag"
                        case bksBankAg = "bks_bank_ag"
                        case brullKallmusBankAg = "brull_kallmus_bank_ag"
                        case btvVierLanderBank = "btv_vier_lander_bank"
                        case capitalBankGraweGruppeAg = "capital_bank_grawe_gruppe_ag"
                        case dolomitenbank
                        case easybankAg = "easybank_ag"
                        case ersteBankUndSparkassen = "erste_bank_und_sparkassen"
                        case hypoAlpeadriabankInternationalAg = "hypo_alpeadriabank_international_ag"
                        case hypoBankBurgenlandAktiengesellschaft = "hypo_bank_burgenland_aktiengesellschaft"
                        case hypoNoeLbFurNiederosterreichUWien = "hypo_noe_lb_fur_niederosterreich_u_wien"
                        case hypoOberosterreichSalzburgSteiermark = "hypo_oberosterreich_salzburg_steiermark"
                        case hypoTirolBankAg = "hypo_tirol_bank_ag"
                        case hypoVorarlbergBankAg = "hypo_vorarlberg_bank_ag"
                        case marchfelderBank = "marchfelder_bank"
                        case oberbankAg = "oberbank_ag"
                        case raiffeisenBankengruppeOsterreich = "raiffeisen_bankengruppe_osterreich"
                        case schoellerbankAg = "schoellerbank_ag"
                        case spardaBankWien = "sparda_bank_wien"
                        case volksbankGruppe = "volksbank_gruppe"
                        case volkskreditbankAg = "volkskreditbank_ag"
                        case vrBankBraunau = "vr_bank_braunau"
                    }

                    public init(bank: Bank? = nil) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Param
                public struct Fpx: Encodable {
                    public var bank: Bank

                    public enum Bank: String, Codable, CaseIterable {
                        case affinBank = "affin_bank"
                        case agrobank
                        case allianceBank = "alliance_bank"
                        case ambank
                        case bankIslam = "bank_islam"
                        case bankMuamalat = "bank_muamalat"
                        case bankRakyat = "bank_rakyat"
                        case bsn
                        case cimb
                        case deutscheBank = "deutsche_bank"
                        case hongLeongBank = "hong_leong_bank"
                        case hsbc
                        case kfh
                        case maybank2e
                        case maybank2u
                        case ocbc
                        case pbEnterprise = "pb_enterprise"
                        case publicBank = "public_bank"
                        case rhb
                        case standardChartered = "standard_chartered"
                        case uob
                    }

                    public init(bank: Bank) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Param
                public struct Ideal: Encodable {
                    public var bank: Bank?

                    public enum Bank: String, Codable, CaseIterable {
                        case abnAmro = "abn_amro"
                        case asnBank = "asn_bank"
                        case bunq
                        case handelsbanken
                        case ing
                        case knab
                        case moneyou
                        case rabobank
                        case regiobank
                        case revolut
                        case snsBank = "sns_bank"
                        case triodosBank = "triodos_bank"
                        case vanLanschot = "van_lanschot"
                    }

                    public init(bank: Bank? = nil) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Param
                public struct Klarna: Encodable {
                    /// Date_of_birth
                    public var dob: Dob?

                    /// Date_of_birth
                    public struct Dob: Encodable {
                        public var day: Int
                        public var month: Int
                        public var year: Int

                        public init(day: Int, month: Int, year: Int) {
                            self.day = day
                            self.month = month
                            self.year = year
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(day, forKey: "day")
                            encoder.encode(month, forKey: "month")
                            encoder.encode(year, forKey: "year")
                            return encoder.items
                        }
                    }

                    public init(dob: Dob? = nil) {
                        self.dob = dob
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(dob, forKey: "dob")
                        return encoder.items
                    }
                }

                /// Param
                public struct P24: Encodable {
                    public var bank: Bank?

                    public enum Bank: String, Codable, CaseIterable {
                        case aliorBank = "alior_bank"
                        case bankMillennium = "bank_millennium"
                        case bankNowyBfgSa = "bank_nowy_bfg_sa"
                        case bankPekaoSa = "bank_pekao_sa"
                        case bankiSpbdzielcze = "banki_spbdzielcze"
                        case blik
                        case bnpParibas = "bnp_paribas"
                        case boz
                        case citiHandlowy = "citi_handlowy"
                        case creditAgricole = "credit_agricole"
                        case envelobank
                        case etransferPocztowy24 = "etransfer_pocztowy24"
                        case getinBank = "getin_bank"
                        case ideabank
                        case ing
                        case inteligo
                        case mbankMtransfer = "mbank_mtransfer"
                        case nestPrzelew = "nest_przelew"
                        case noblePay = "noble_pay"
                        case pbacZIpko = "pbac_z_ipko"
                        case plusBank = "plus_bank"
                        case santanderPrzelew24 = "santander_przelew24"
                        case tmobileUsbugiBankowe = "tmobile_usbugi_bankowe"
                        case toyotaBank = "toyota_bank"
                        case volkswagenBank = "volkswagen_bank"
                    }

                    public init(bank: Bank? = nil) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Radar_options
                public struct RadarOptions: Encodable {
                    public var session: String?

                    public init(session: String? = nil) {
                        self.session = session
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(session, forKey: "session")
                        return encoder.items
                    }
                }

                /// Param
                public struct SepaDebit: Encodable {
                    public var iban: String

                    public init(iban: String) {
                        self.iban = iban
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(iban, forKey: "iban")
                        return encoder.items
                    }
                }

                /// Param
                public struct Sofort: Encodable {
                    public var country: Country

                    public enum Country: String, Codable, CaseIterable {
                        case at = "AT"
                        case be = "BE"
                        case de = "DE"
                        case es = "ES"
                        case it = "IT"
                        case nl = "NL"
                    }

                    public init(country: Country) {
                        self.country = country
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(country, forKey: "country")
                        return encoder.items
                    }
                }

                public enum `Type`: String, Codable, CaseIterable {
                    case acssDebit = "acss_debit"
                    case affirm
                    case afterpayClearpay = "afterpay_clearpay"
                    case alipay
                    case auBecsDebit = "au_becs_debit"
                    case bacsDebit = "bacs_debit"
                    case bancontact
                    case blik
                    case boleto
                    case customerBalance = "customer_balance"
                    case eps
                    case fpx
                    case giropay
                    case grabpay
                    case ideal
                    case klarna
                    case konbini
                    case link
                    case oxxo
                    case p24
                    case paynow
                    case promptpay
                    case sepaDebit = "sepa_debit"
                    case sofort
                    case usBankAccount = "us_bank_account"
                    case wechatPay = "wechat_pay"
                }

                /// Payment_method_param
                public struct UsBankAccount: Encodable {
                    public var accountHolderType: AccountHolderType?
                    public var accountNumber: String?
                    public var accountType: AccountType?
                    public var financialConnectionsAccount: String?
                    public var routingNumber: String?

                    public enum AccountHolderType: String, Codable, CaseIterable {
                        case company
                        case individual
                    }

                    public enum AccountType: String, Codable, CaseIterable {
                        case checking
                        case savings
                    }

                    public init(accountHolderType: AccountHolderType? = nil, accountNumber: String? = nil, accountType: AccountType? = nil, financialConnectionsAccount: String? = nil, routingNumber: String? = nil) {
                        self.accountHolderType = accountHolderType
                        self.accountNumber = accountNumber
                        self.accountType = accountType
                        self.financialConnectionsAccount = financialConnectionsAccount
                        self.routingNumber = routingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountHolderType, forKey: "account_holder_type")
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(accountType, forKey: "account_type")
                        encoder.encode(financialConnectionsAccount, forKey: "financial_connections_account")
                        encoder.encode(routingNumber, forKey: "routing_number")
                        return encoder.items
                    }
                }

                public init(acssDebit: AcssDebit? = nil, affirm: [String: AnyJSON]? = nil, afterpayClearpay: [String: AnyJSON]? = nil, alipay: [String: AnyJSON]? = nil, auBecsDebit: AuBecsDebit? = nil, bacsDebit: BacsDebit? = nil, bancontact: [String: AnyJSON]? = nil, billingDetails: BillingDetails? = nil, blik: [String: AnyJSON]? = nil, boleto: Boleto? = nil, customerBalance: [String: AnyJSON]? = nil, eps: Eps? = nil, fpx: Fpx? = nil, giropay: [String: AnyJSON]? = nil, grabpay: [String: AnyJSON]? = nil, ideal: Ideal? = nil, interacPresent: [String: AnyJSON]? = nil, klarna: Klarna? = nil, konbini: [String: AnyJSON]? = nil, link: [String: AnyJSON]? = nil, metadata: [String: String]? = nil, oxxo: [String: AnyJSON]? = nil, p24: P24? = nil, paynow: [String: AnyJSON]? = nil, promptpay: [String: AnyJSON]? = nil, radarOptions: RadarOptions? = nil, sepaDebit: SepaDebit? = nil, sofort: Sofort? = nil, type: `Type`, usBankAccount: UsBankAccount? = nil, wechatPay: [String: AnyJSON]? = nil) {
                    self.acssDebit = acssDebit
                    self.affirm = affirm
                    self.afterpayClearpay = afterpayClearpay
                    self.alipay = alipay
                    self.auBecsDebit = auBecsDebit
                    self.bacsDebit = bacsDebit
                    self.bancontact = bancontact
                    self.billingDetails = billingDetails
                    self.blik = blik
                    self.boleto = boleto
                    self.customerBalance = customerBalance
                    self.eps = eps
                    self.fpx = fpx
                    self.giropay = giropay
                    self.grabpay = grabpay
                    self.ideal = ideal
                    self.interacPresent = interacPresent
                    self.klarna = klarna
                    self.konbini = konbini
                    self.link = link
                    self.metadata = metadata
                    self.oxxo = oxxo
                    self.p24 = p24
                    self.paynow = paynow
                    self.promptpay = promptpay
                    self.radarOptions = radarOptions
                    self.sepaDebit = sepaDebit
                    self.sofort = sofort
                    self.type = type
                    self.usBankAccount = usBankAccount
                    self.wechatPay = wechatPay
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acssDebit, forKey: "acss_debit")
                    encoder.encode(affirm, forKey: "affirm")
                    encoder.encode(afterpayClearpay, forKey: "afterpay_clearpay")
                    encoder.encode(alipay, forKey: "alipay")
                    encoder.encode(auBecsDebit, forKey: "au_becs_debit")
                    encoder.encode(bacsDebit, forKey: "bacs_debit")
                    encoder.encode(bancontact, forKey: "bancontact")
                    encoder.encode(billingDetails, forKey: "billing_details")
                    encoder.encode(blik, forKey: "blik")
                    encoder.encode(boleto, forKey: "boleto")
                    encoder.encode(customerBalance, forKey: "customer_balance")
                    encoder.encode(eps, forKey: "eps")
                    encoder.encode(fpx, forKey: "fpx")
                    encoder.encode(giropay, forKey: "giropay")
                    encoder.encode(grabpay, forKey: "grabpay")
                    encoder.encode(ideal, forKey: "ideal")
                    encoder.encode(interacPresent, forKey: "interac_present")
                    encoder.encode(klarna, forKey: "klarna")
                    encoder.encode(konbini, forKey: "konbini")
                    encoder.encode(link, forKey: "link")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(oxxo, forKey: "oxxo")
                    encoder.encode(p24, forKey: "p24")
                    encoder.encode(paynow, forKey: "paynow")
                    encoder.encode(promptpay, forKey: "promptpay")
                    encoder.encode(radarOptions, forKey: "radar_options")
                    encoder.encode(sepaDebit, forKey: "sepa_debit")
                    encoder.encode(sofort, forKey: "sofort")
                    encoder.encode(type, forKey: "type")
                    encoder.encode(usBankAccount, forKey: "us_bank_account")
                    encoder.encode(wechatPay, forKey: "wechat_pay")
                    return encoder.items
                }
            }

            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration for this SetupIntent.
            public struct PaymentMethodOptions: Encodable {
                /// Setup_intent_payment_method_options_param
                public var acssDebit: AcssDebit?
                /// Setup_intent_payment_method_options_param
                public var blik: Blik?
                /// Setup_intent_param
                public var card: Card?
                /// Setup_intent_payment_method_options_param
                public var link: Link?
                /// Setup_intent_payment_method_options_param
                public var sepaDebit: SepaDebit?
                /// Setup_intent_payment_method_options_param
                public var usBankAccount: UsBankAccount?

                /// Setup_intent_payment_method_options_param
                public struct AcssDebit: Encodable {
                    public var currency: Currency?
                    /// Setup_intent_payment_method_options_mandate_options_param
                    public var mandateOptions: MandateOptions?
                    public var verificationMethod: VerificationMethod?

                    public enum Currency: String, Codable, CaseIterable {
                        case cad
                        case usd
                    }

                    /// Setup_intent_payment_method_options_mandate_options_param
                    public struct MandateOptions: Encodable {
                        public var customMandateURL: CustomMandateURL?
                        public var defaultFor: [DefaultForItem]?
                        public var intervalDescription: String?
                        public var paymentSchedule: PaymentSchedule?
                        public var transactionType: TransactionType?

                        public struct CustomMandateURL: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public enum DefaultForItem: String, Codable, CaseIterable {
                            case invoice
                            case subscription
                        }

                        public enum PaymentSchedule: String, Codable, CaseIterable {
                            case combined
                            case interval
                            case sporadic
                        }

                        public enum TransactionType: String, Codable, CaseIterable {
                            case business
                            case personal
                        }

                        public init(customMandateURL: CustomMandateURL? = nil, defaultFor: [DefaultForItem]? = nil, intervalDescription: String? = nil, paymentSchedule: PaymentSchedule? = nil, transactionType: TransactionType? = nil) {
                            self.customMandateURL = customMandateURL
                            self.defaultFor = defaultFor
                            self.intervalDescription = intervalDescription
                            self.paymentSchedule = paymentSchedule
                            self.transactionType = transactionType
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(customMandateURL, forKey: "custom_mandate_url")
                            encoder.encode(defaultFor, forKey: "default_for")
                            encoder.encode(intervalDescription, forKey: "interval_description")
                            encoder.encode(paymentSchedule, forKey: "payment_schedule")
                            encoder.encode(transactionType, forKey: "transaction_type")
                            return encoder.items
                        }
                    }

                    public enum VerificationMethod: String, Codable, CaseIterable {
                        case automatic
                        case instant
                        case microdeposits
                    }

                    public init(currency: Currency? = nil, mandateOptions: MandateOptions? = nil, verificationMethod: VerificationMethod? = nil) {
                        self.currency = currency
                        self.mandateOptions = mandateOptions
                        self.verificationMethod = verificationMethod
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(mandateOptions, forKey: "mandate_options")
                        encoder.encode(verificationMethod, forKey: "verification_method")
                        return encoder.items
                    }
                }

                /// Setup_intent_payment_method_options_param
                public struct Blik: Encodable {
                    public var code: String?

                    public init(code: String? = nil) {
                        self.code = code
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(code, forKey: "code")
                        return encoder.items
                    }
                }

                /// Setup_intent_param
                public struct Card: Encodable {
                    /// Setup_intent_mandate_options_param
                    public var mandateOptions: MandateOptions?
                    public var requestThreeDSecure: RequestThreeDSecure?

                    /// Setup_intent_mandate_options_param
                    public struct MandateOptions: Encodable {
                        public var amount: Int
                        public var amountType: AmountType
                        public var currency: String
                        public var description: String?
                        public var endDate: Int?
                        public var interval: Interval
                        public var intervalCount: Int?
                        public var reference: String
                        public var startDate: Int
                        public var supportedTypes: [SupportedType]?

                        public enum AmountType: String, Codable, CaseIterable {
                            case fixed
                            case maximum
                        }

                        public enum Interval: String, Codable, CaseIterable {
                            case day
                            case month
                            case sporadic
                            case week
                            case year
                        }

                        public enum SupportedType: String, Codable, CaseIterable {
                            case india
                        }

                        public init(amount: Int, amountType: AmountType, currency: String, description: String? = nil, endDate: Int? = nil, interval: Interval, intervalCount: Int? = nil, reference: String, startDate: Int, supportedTypes: [SupportedType]? = nil) {
                            self.amount = amount
                            self.amountType = amountType
                            self.currency = currency
                            self.description = description
                            self.endDate = endDate
                            self.interval = interval
                            self.intervalCount = intervalCount
                            self.reference = reference
                            self.startDate = startDate
                            self.supportedTypes = supportedTypes
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(amount, forKey: "amount")
                            encoder.encode(amountType, forKey: "amount_type")
                            encoder.encode(currency, forKey: "currency")
                            encoder.encode(description, forKey: "description")
                            encoder.encode(endDate, forKey: "end_date")
                            encoder.encode(interval, forKey: "interval")
                            encoder.encode(intervalCount, forKey: "interval_count")
                            encoder.encode(reference, forKey: "reference")
                            encoder.encode(startDate, forKey: "start_date")
                            encoder.encode(supportedTypes, forKey: "supported_types")
                            return encoder.items
                        }
                    }

                    public enum RequestThreeDSecure: String, Codable, CaseIterable {
                        case any
                        case automatic
                    }

                    public init(mandateOptions: MandateOptions? = nil, requestThreeDSecure: RequestThreeDSecure? = nil) {
                        self.mandateOptions = mandateOptions
                        self.requestThreeDSecure = requestThreeDSecure
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(mandateOptions, forKey: "mandate_options")
                        encoder.encode(requestThreeDSecure, forKey: "request_three_d_secure")
                        return encoder.items
                    }
                }

                /// Setup_intent_payment_method_options_param
                public struct Link: Encodable {
                    public var persistentToken: String?

                    public init(persistentToken: String? = nil) {
                        self.persistentToken = persistentToken
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(persistentToken, forKey: "persistent_token")
                        return encoder.items
                    }
                }

                /// Setup_intent_payment_method_options_param
                public struct SepaDebit: Encodable {
                    /// Payment_method_options_mandate_options_param
                    public var mandateOptions: [String: AnyJSON]?

                    public init(mandateOptions: [String: AnyJSON]? = nil) {
                        self.mandateOptions = mandateOptions
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(mandateOptions, forKey: "mandate_options")
                        return encoder.items
                    }
                }

                /// Setup_intent_payment_method_options_param
                public struct UsBankAccount: Encodable {
                    /// Linked_account_options_param
                    public var financialConnections: FinancialConnections?
                    /// Networks_options_param
                    public var networks: Networks?
                    public var verificationMethod: VerificationMethod?

                    /// Linked_account_options_param
                    public struct FinancialConnections: Encodable {
                        public var permissions: [Permission]?
                        public var returnURL: String?

                        public enum Permission: String, Codable, CaseIterable {
                            case balances
                            case ownership
                            case paymentMethod = "payment_method"
                            case transactions
                        }

                        public init(permissions: [Permission]? = nil, returnURL: String? = nil) {
                            self.permissions = permissions
                            self.returnURL = returnURL
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(permissions, forKey: "permissions")
                            encoder.encode(returnURL, forKey: "return_url")
                            return encoder.items
                        }
                    }

                    /// Networks_options_param
                    public struct Networks: Encodable {
                        public var requested: [RequestedItem]?

                        public enum RequestedItem: String, Codable, CaseIterable {
                            case ach
                            case usDomesticWire = "us_domestic_wire"
                        }

                        public init(requested: [RequestedItem]? = nil) {
                            self.requested = requested
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(requested, forKey: "requested")
                            return encoder.items
                        }
                    }

                    public enum VerificationMethod: String, Codable, CaseIterable {
                        case automatic
                        case instant
                        case microdeposits
                    }

                    public init(financialConnections: FinancialConnections? = nil, networks: Networks? = nil, verificationMethod: VerificationMethod? = nil) {
                        self.financialConnections = financialConnections
                        self.networks = networks
                        self.verificationMethod = verificationMethod
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(financialConnections, forKey: "financial_connections")
                        encoder.encode(networks, forKey: "networks")
                        encoder.encode(verificationMethod, forKey: "verification_method")
                        return encoder.items
                    }
                }

                public init(acssDebit: AcssDebit? = nil, blik: Blik? = nil, card: Card? = nil, link: Link? = nil, sepaDebit: SepaDebit? = nil, usBankAccount: UsBankAccount? = nil) {
                    self.acssDebit = acssDebit
                    self.blik = blik
                    self.card = card
                    self.link = link
                    self.sepaDebit = sepaDebit
                    self.usBankAccount = usBankAccount
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acssDebit, forKey: "acss_debit")
                    encoder.encode(blik, forKey: "blik")
                    encoder.encode(card, forKey: "card")
                    encoder.encode(link, forKey: "link")
                    encoder.encode(sepaDebit, forKey: "sepa_debit")
                    encoder.encode(usBankAccount, forKey: "us_bank_account")
                    return encoder.items
                }
            }

            public init(isAttachToSelf: Bool? = nil, customer: String? = nil, description: String? = nil, expand: [String]? = nil, flowDirections: [FlowDirection]? = nil, metadata: Metadata? = nil, paymentMethod: String? = nil, paymentMethodData: PaymentMethodData? = nil, paymentMethodOptions: PaymentMethodOptions? = nil, paymentMethodTypes: [String]? = nil) {
                self.isAttachToSelf = isAttachToSelf
                self.customer = customer
                self.description = description
                self.expand = expand
                self.flowDirections = flowDirections
                self.metadata = metadata
                self.paymentMethod = paymentMethod
                self.paymentMethodData = paymentMethodData
                self.paymentMethodOptions = paymentMethodOptions
                self.paymentMethodTypes = paymentMethodTypes
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isAttachToSelf, forKey: "attach_to_self")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(description, forKey: "description")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(flowDirections, forKey: "flow_directions")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(paymentMethod, forKey: "payment_method")
                encoder.encode(paymentMethodData, forKey: "payment_method_data")
                encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                return encoder.items
            }
        }
    }
}
