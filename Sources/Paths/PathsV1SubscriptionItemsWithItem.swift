// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths.SubscriptionItems {
    public func item(_ item: String) -> WithItem {
        WithItem(path: "\(path)/\(item)")
    }

    public struct WithItem {
        /// Path: `/v1/subscription_items/{item}`
        public let path: String

        /// <p>Retrieves the subscription item with the given ID.</p>
        public func get(expand: [String]? = nil) -> Request<StripeKit.SubscriptionItem> {
            Request(method: "GET", url: path, query: makeGetQuery(expand), id: "GetSubscriptionItemsItem")
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the plan or quantity of an item on a current subscription.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeKit.SubscriptionItem> {
            Request(method: "POST", url: path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery, id: "PostSubscriptionItemsItem")
        }

        public struct PostRequest: Encodable {
            /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period. When updating, pass an empty string to remove previously-defined thresholds.
            public var billingThresholds: BillingThresholds?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Indicates if a customer is on or off-session while an invoice payment is attempted.
            public var isOffSession: Bool?
            /// Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.
            /// 
            /// Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.
            /// 
            /// Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).
            /// 
            /// Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
            public var paymentBehavior: PaymentBehavior?
            /// The ID of the price object. When changing a subscription item's price, `quantity` is set to 1 unless a `quantity` parameter is provided.
            public var price: String?
            /// Recurring_price_data
            ///
            /// Data used to generate a new [Price](https://stripe.com/docs/api/prices) object inline.
            public var priceData: PriceData?
            /// Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
            public var prorationBehavior: ProrationBehavior?
            /// If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply the same proration that was previewed with the [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint.
            public var prorationDate: Int?
            /// The quantity you'd like to apply to the subscription item you're creating.
            public var quantity: Int?
            /// A list of [Tax Rate](https://stripe.com/docs/api/tax_rates) ids. These Tax Rates will override the [`default_tax_rates`](https://stripe.com/docs/api/subscriptions/create#create_subscription-default_tax_rates) on the Subscription. When updating, pass an empty string to remove previously-defined tax rates.
            public var taxRates: TaxRates?

            /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period. When updating, pass an empty string to remove previously-defined thresholds.
            public struct BillingThresholds: Encodable {
                /// Item_billing_thresholds_param
                public var a: A?
                public var b: B?

                /// Item_billing_thresholds_param
                public struct A: Encodable {
                    public var usageGte: Int

                    public init(usageGte: Int) {
                        self.usageGte = usageGte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(usageGte, forKey: "usage_gte")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.
            /// 
            /// Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.
            /// 
            /// Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).
            /// 
            /// Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
            public enum PaymentBehavior: String, Codable, CaseIterable {
                case allowIncomplete = "allow_incomplete"
                case defaultIncomplete = "default_incomplete"
                case errorIfIncomplete = "error_if_incomplete"
                case pendingIfIncomplete = "pending_if_incomplete"
            }

            /// Recurring_price_data
            ///
            /// Data used to generate a new [Price](https://stripe.com/docs/api/prices) object inline.
            public struct PriceData: Encodable {
                public var currency: String
                public var product: String
                /// Recurring_adhoc
                public var recurring: Recurring
                public var taxBehavior: TaxBehavior?
                public var unitAmount: Int?
                public var unitAmountDecimal: String?

                /// Recurring_adhoc
                public struct Recurring: Encodable {
                    public var interval: Interval
                    public var intervalCount: Int?

                    public enum Interval: String, Codable, CaseIterable {
                        case day
                        case month
                        case week
                        case year
                    }

                    public init(interval: Interval, intervalCount: Int? = nil) {
                        self.interval = interval
                        self.intervalCount = intervalCount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(interval, forKey: "interval")
                        encoder.encode(intervalCount, forKey: "interval_count")
                        return encoder.items
                    }
                }

                public enum TaxBehavior: String, Codable, CaseIterable {
                    case exclusive
                    case inclusive
                    case unspecified
                }

                public init(currency: String, product: String, recurring: Recurring, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                    self.currency = currency
                    self.product = product
                    self.recurring = recurring
                    self.taxBehavior = taxBehavior
                    self.unitAmount = unitAmount
                    self.unitAmountDecimal = unitAmountDecimal
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(currency, forKey: "currency")
                    encoder.encode(product, forKey: "product")
                    encoder.encode(recurring, forKey: "recurring")
                    encoder.encode(taxBehavior, forKey: "tax_behavior")
                    encoder.encode(unitAmount, forKey: "unit_amount")
                    encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                    return encoder.items
                }
            }

            /// Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
            public enum ProrationBehavior: String, Codable, CaseIterable {
                case alwaysInvoice = "always_invoice"
                case createProrations = "create_prorations"
                case `none`
            }

            /// A list of [Tax Rate](https://stripe.com/docs/api/tax_rates) ids. These Tax Rates will override the [`default_tax_rates`](https://stripe.com/docs/api/subscriptions/create#create_subscription-default_tax_rates) on the Subscription. When updating, pass an empty string to remove previously-defined tax rates.
            public struct TaxRates: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(billingThresholds: BillingThresholds? = nil, expand: [String]? = nil, metadata: Metadata? = nil, isOffSession: Bool? = nil, paymentBehavior: PaymentBehavior? = nil, price: String? = nil, priceData: PriceData? = nil, prorationBehavior: ProrationBehavior? = nil, prorationDate: Int? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                self.billingThresholds = billingThresholds
                self.expand = expand
                self.metadata = metadata
                self.isOffSession = isOffSession
                self.paymentBehavior = paymentBehavior
                self.price = price
                self.priceData = priceData
                self.prorationBehavior = prorationBehavior
                self.prorationDate = prorationDate
                self.quantity = quantity
                self.taxRates = taxRates
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(billingThresholds, forKey: "billing_thresholds")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(isOffSession, forKey: "off_session")
                encoder.encode(paymentBehavior, forKey: "payment_behavior")
                encoder.encode(price, forKey: "price")
                encoder.encode(priceData, forKey: "price_data")
                encoder.encode(prorationBehavior, forKey: "proration_behavior")
                encoder.encode(prorationDate, forKey: "proration_date")
                encoder.encode(quantity, forKey: "quantity")
                encoder.encode(taxRates, forKey: "tax_rates")
                return encoder.items
            }
        }

        /// <p>Deletes an item from the subscription. Removing a subscription item from a subscription will not cancel the subscription.</p>
        public func delete(_ body: DeleteRequest? = nil) -> Request<StripeKit.DeletedSubscriptionItem> {
            Request(method: "DELETE", url: path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery, id: "DeleteSubscriptionItemsItem")
        }

        public struct DeleteRequest: Encodable {
            /// Delete all usage for the given subscription item. Allowed only when the current plan's `usage_type` is `metered`.
            public var isClearUsage: Bool?
            /// Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
            public var prorationBehavior: ProrationBehavior?
            /// If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply the same proration that was previewed with the [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint.
            public var prorationDate: Int?

            /// Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
            public enum ProrationBehavior: String, Codable, CaseIterable {
                case alwaysInvoice = "always_invoice"
                case createProrations = "create_prorations"
                case `none`
            }

            public init(isClearUsage: Bool? = nil, prorationBehavior: ProrationBehavior? = nil, prorationDate: Int? = nil) {
                self.isClearUsage = isClearUsage
                self.prorationBehavior = prorationBehavior
                self.prorationDate = prorationDate
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isClearUsage, forKey: "clear_usage")
                encoder.encode(prorationBehavior, forKey: "proration_behavior")
                encoder.encode(prorationDate, forKey: "proration_date")
                return encoder.items
            }
        }
    }
}
