// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths.Prices {
    public func price(_ price: String) -> WithPrice {
        WithPrice(path: "\(path)/\(price)")
    }

    public struct WithPrice {
        /// Path: `/v1/prices/{price}`
        public let path: String

        /// <p>Retrieves the price with the given ID.</p>
        public func get(expand: [String]? = nil) -> Request<StripeKit.Price> {
            Request(method: "GET", url: path, query: makeGetQuery(expand), id: "GetPricesPrice")
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified price by setting the values of the parameters passed. Any parameters not provided are left unchanged.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeKit.Price> {
            Request(method: "POST", url: path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery, id: "PostPricesPrice")
        }

        public struct PostRequest: Encodable {
            /// Whether the price can be used for new purchases. Defaults to `true`.
            public var isActive: Bool?
            /// Prices defined in each available currency option. Each key must be a three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html) and a [supported currency](https://stripe.com/docs/currencies).
            public var currencyOptions: CurrencyOptions?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// A lookup key used to retrieve prices dynamically from a static string. This may be up to 200 characters.
            public var lookupKey: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// A brief description of the price, hidden from customers.
            public var nickname: String?
            /// Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it cannot be changed.
            public var taxBehavior: TaxBehavior?
            /// If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
            public var isTransferLookupKey: Bool?

            /// Prices defined in each available currency option. Each key must be a three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html) and a [supported currency](https://stripe.com/docs/currencies).
            public struct CurrencyOptions: Encodable {
                public var stringPlaceholderItem: [String: StringPlaceholderItemItem]?
                public var object: Object?

                /// Currency_option
                public struct StringPlaceholderItemItem: Encodable {
                    /// Custom_unit_amount
                    public var customUnitAmount: CustomUnitAmount?
                    public var taxBehavior: TaxBehavior?
                    public var tiers: [Tier]?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    /// Custom_unit_amount
                    public struct CustomUnitAmount: Encodable {
                        public var isEnabled: Bool
                        public var maximum: Int?
                        public var minimum: Int?
                        public var preset: Int?

                        public init(isEnabled: Bool, maximum: Int? = nil, minimum: Int? = nil, preset: Int? = nil) {
                            self.isEnabled = isEnabled
                            self.maximum = maximum
                            self.minimum = minimum
                            self.preset = preset
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(isEnabled, forKey: "enabled")
                            encoder.encode(maximum, forKey: "maximum")
                            encoder.encode(minimum, forKey: "minimum")
                            encoder.encode(preset, forKey: "preset")
                            return encoder.items
                        }
                    }

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public struct Tier: Encodable {
                        public var flatAmount: Int?
                        public var flatAmountDecimal: String?
                        public var unitAmount: Int?
                        public var unitAmountDecimal: String?
                        public var upTo: UpTo

                        public struct UpTo: Encodable {
                            public var object: Object?
                            public var int: Int?

                            public enum Object: String, Codable, CaseIterable {
                                case inf
                            }

                            public init(object: Object? = nil, int: Int? = nil) {
                                self.object = object
                                self.int = int
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(object, forKey: "object")
                                encoder.encode(int, forKey: "int")
                                return encoder.items
                            }
                        }

                        public init(flatAmount: Int? = nil, flatAmountDecimal: String? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil, upTo: UpTo) {
                            self.flatAmount = flatAmount
                            self.flatAmountDecimal = flatAmountDecimal
                            self.unitAmount = unitAmount
                            self.unitAmountDecimal = unitAmountDecimal
                            self.upTo = upTo
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(flatAmount, forKey: "flat_amount")
                            encoder.encode(flatAmountDecimal, forKey: "flat_amount_decimal")
                            encoder.encode(unitAmount, forKey: "unit_amount")
                            encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                            encoder.encode(upTo, forKey: "up_to")
                            return encoder.items
                        }
                    }

                    public init(customUnitAmount: CustomUnitAmount? = nil, taxBehavior: TaxBehavior? = nil, tiers: [Tier]? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.customUnitAmount = customUnitAmount
                        self.taxBehavior = taxBehavior
                        self.tiers = tiers
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(customUnitAmount, forKey: "custom_unit_amount")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(tiers, forKey: "tiers")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringPlaceholderItem: [String: StringPlaceholderItemItem]? = nil, object: Object? = nil) {
                    self.stringPlaceholderItem = stringPlaceholderItem
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringPlaceholderItem, forKey: "stringPlaceholderItem")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it cannot be changed.
            public enum TaxBehavior: String, Codable, CaseIterable {
                case exclusive
                case inclusive
                case unspecified
            }

            public init(isActive: Bool? = nil, currencyOptions: CurrencyOptions? = nil, expand: [String]? = nil, lookupKey: String? = nil, metadata: Metadata? = nil, nickname: String? = nil, taxBehavior: TaxBehavior? = nil, isTransferLookupKey: Bool? = nil) {
                self.isActive = isActive
                self.currencyOptions = currencyOptions
                self.expand = expand
                self.lookupKey = lookupKey
                self.metadata = metadata
                self.nickname = nickname
                self.taxBehavior = taxBehavior
                self.isTransferLookupKey = isTransferLookupKey
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(currencyOptions, forKey: "currency_options")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(lookupKey, forKey: "lookup_key")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(nickname, forKey: "nickname")
                encoder.encode(taxBehavior, forKey: "tax_behavior")
                encoder.encode(isTransferLookupKey, forKey: "transfer_lookup_key")
                return encoder.items
            }
        }
    }
}
