// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths.Invoices {
    public func invoice(_ invoice: String) -> WithInvoice {
        WithInvoice(path: "\(path)/\(invoice)")
    }

    public struct WithInvoice {
        /// Path: `/v1/invoices/{invoice}`
        public let path: String

        /// <p>Retrieves the invoice with the given ID.</p>
        public func get(expand: [String]? = nil) -> Request<StripeKit.Invoice> {
            Request(method: "GET", url: path, query: makeGetQuery(expand), id: "GetInvoicesInvoice")
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Draft invoices are fully editable. Once an invoice is <a href="/docs/billing/invoices/workflow#finalized">finalized</a>,
        /// monetary values, as well as <code>collection_method</code>, become uneditable.</p>
        /// 
        /// <p>If you would like to stop the Stripe Billing engine from automatically finalizing, reattempting payments on,
        /// sending reminders for, or <a href="/docs/billing/invoices/reconciliation">automatically reconciling</a> invoices, pass
        /// <code>auto_advance=false</code>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeKit.Invoice> {
            Request(method: "POST", url: path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery, id: "PostInvoicesInvoice")
        }

        public struct PostRequest: Encodable {
            /// The account tax IDs associated with the invoice. Only editable when the invoice is a draft.
            public var accountTaxIDs: AccountTaxIDs?
            /// A fee in cents (or local equivalent) that will be applied to the invoice and transferred to the application owner's Stripe account. The request must be made with an OAuth key or the Stripe-Account header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/billing/invoices/connect#collecting-fees).
            public var applicationFeeAmount: Int?
            /// Controls whether Stripe will perform [automatic collection](https://stripe.com/docs/billing/invoices/workflow/#auto_advance) of the invoice.
            public var isAutoAdvance: Bool?
            /// Automatic_tax_param
            ///
            /// Settings for automatic tax lookup for this invoice.
            public var automaticTax: AutomaticTax?
            /// Either `charge_automatically` or `send_invoice`. This field can be updated only on `draft` invoices.
            public var collectionMethod: CollectionMethod?
            /// A list of up to 4 custom fields to be displayed on the invoice. If a value for `custom_fields` is specified, the list specified will replace the existing custom field list on this invoice. Pass an empty string to remove previously-defined fields.
            public var customFields: CustomFields?
            /// The number of days from which the invoice is created until it is due. Only valid for invoices where `collection_method=send_invoice`. This field can only be updated on `draft` invoices.
            public var daysUntilDue: Int?
            /// ID of the default payment method for the invoice. It must belong to the customer associated with the invoice. If not set, defaults to the subscription's default payment method, if any, or to the default payment method in the customer's invoice settings.
            public var defaultPaymentMethod: String?
            /// ID of the default payment source for the invoice. It must belong to the customer associated with the invoice and be in a chargeable state. If not set, defaults to the subscription's default source, if any, or to the customer's default source.
            public var defaultSource: String?
            /// The tax rates that will apply to any line item that does not have `tax_rates` set. Pass an empty string to remove previously-defined tax rates.
            public var defaultTaxRates: DefaultTaxRates?
            /// An arbitrary string attached to the object. Often useful for displaying to users. Referenced as 'memo' in the Dashboard.
            public var description: String?
            /// The discounts that will apply to the invoice. Pass an empty string to remove previously-defined discounts.
            public var discounts: Discounts?
            /// The date on which payment for this invoice is due. Only valid for invoices where `collection_method=send_invoice`. This field can only be updated on `draft` invoices.
            public var dueDate: Int?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Footer to be displayed on the invoice.
            public var footer: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The account (if any) for which the funds of the invoice payment are intended. If set, the invoice will be presented with the branding and support information of the specified account. See the [Invoices with Connect](https://stripe.com/docs/billing/invoices/connect) documentation for details.
            public var onBehalfOf: OnBehalfOf?
            /// Payment_settings
            ///
            /// Configuration settings for the PaymentIntent that is generated when the invoice is finalized.
            public var paymentSettings: PaymentSettings?
            /// Options for invoice PDF rendering.
            public var renderingOptions: RenderingOptions?
            /// Extra information about a charge for the customer's credit card statement. It must contain at least one letter. If not specified and this invoice is part of a subscription, the default `statement_descriptor` will be set to the first subscription item's product's `statement_descriptor`.
            public var statementDescriptor: String?
            /// If specified, the funds from the invoice will be transferred to the destination and the ID of the resulting transfer will be found on the invoice's charge. This will be unset if you POST an empty value.
            public var transferData: TransferData?

            /// The account tax IDs associated with the invoice. Only editable when the invoice is a draft.
            public struct AccountTaxIDs: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Automatic_tax_param
            ///
            /// Settings for automatic tax lookup for this invoice.
            public struct AutomaticTax: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Either `charge_automatically` or `send_invoice`. This field can be updated only on `draft` invoices.
            public enum CollectionMethod: String, Codable, CaseIterable {
                case chargeAutomatically = "charge_automatically"
                case sendInvoice = "send_invoice"
            }

            /// A list of up to 4 custom fields to be displayed on the invoice. If a value for `custom_fields` is specified, the list specified will replace the existing custom field list on this invoice. Pass an empty string to remove previously-defined fields.
            public struct CustomFields: Encodable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Custom_field_params
                public struct PlaceholderItem: Encodable {
                    public var name: String
                    public var value: String

                    public init(name: String, value: String) {
                        self.name = name
                        self.value = value
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(name, forKey: "name")
                        encoder.encode(value, forKey: "value")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The tax rates that will apply to any line item that does not have `tax_rates` set. Pass an empty string to remove previously-defined tax rates.
            public struct DefaultTaxRates: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The discounts that will apply to the invoice. Pass an empty string to remove previously-defined discounts.
            public struct Discounts: Encodable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Discounts_data_param
                public struct PlaceholderItem: Encodable {
                    public var coupon: String?
                    public var discount: String?

                    public init(coupon: String? = nil, discount: String? = nil) {
                        self.coupon = coupon
                        self.discount = discount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(coupon, forKey: "coupon")
                        encoder.encode(discount, forKey: "discount")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The account (if any) for which the funds of the invoice payment are intended. If set, the invoice will be presented with the branding and support information of the specified account. See the [Invoices with Connect](https://stripe.com/docs/billing/invoices/connect) documentation for details.
            public struct OnBehalfOf: Encodable {
                public var string: String?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(string: String? = nil, object: Object? = nil) {
                    self.string = string
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(string, forKey: "string")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Payment_settings
            ///
            /// Configuration settings for the PaymentIntent that is generated when the invoice is finalized.
            public struct PaymentSettings: Encodable {
                public var defaultMandate: String?
                /// Payment_method_options
                public var paymentMethodOptions: PaymentMethodOptions?
                public var paymentMethodTypes: PaymentMethodTypes?

                /// Payment_method_options
                public struct PaymentMethodOptions: Encodable {
                    public var acssDebit: AcssDebit?
                    public var bancontact: Bancontact?
                    public var card: Card?
                    public var customerBalance: CustomerBalance?
                    public var konbini: Konbini?
                    public var usBankAccount: UsBankAccount?

                    public struct AcssDebit: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            /// Mandate_options_param
                            public var mandateOptions: MandateOptions?
                            public var verificationMethod: VerificationMethod?

                            /// Mandate_options_param
                            public struct MandateOptions: Encodable {
                                public var transactionType: TransactionType?

                                public enum TransactionType: String, Codable, CaseIterable {
                                    case business
                                    case personal
                                }

                                public init(transactionType: TransactionType? = nil) {
                                    self.transactionType = transactionType
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(transactionType, forKey: "transaction_type")
                                    return encoder.items
                                }
                            }

                            public enum VerificationMethod: String, Codable, CaseIterable {
                                case automatic
                                case instant
                                case microdeposits
                            }

                            public init(mandateOptions: MandateOptions? = nil, verificationMethod: VerificationMethod? = nil) {
                                self.mandateOptions = mandateOptions
                                self.verificationMethod = verificationMethod
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(mandateOptions, forKey: "mandate_options")
                                encoder.encode(verificationMethod, forKey: "verification_method")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Bancontact: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            public var preferredLanguage: PreferredLanguage?

                            public enum PreferredLanguage: String, Codable, CaseIterable {
                                case de
                                case en
                                case fr
                                case nl
                            }

                            public init(preferredLanguage: PreferredLanguage? = nil) {
                                self.preferredLanguage = preferredLanguage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(preferredLanguage, forKey: "preferred_language")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Card: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            /// Installments_param
                            public var installments: Installments?
                            public var requestThreeDSecure: RequestThreeDSecure?

                            /// Installments_param
                            public struct Installments: Encodable {
                                public var isEnabled: Bool?
                                public var plan: Plan?

                                public struct Plan: Encodable {
                                    /// Installment_plan
                                    public var a: A?
                                    public var b: B?

                                    /// Installment_plan
                                    public struct A: Encodable {
                                        public var count: Int
                                        public var interval: Interval
                                        public var type: `Type`

                                        public enum Interval: String, Codable, CaseIterable {
                                            case month
                                        }

                                        public enum `Type`: String, Codable, CaseIterable {
                                            case fixedCount = "fixed_count"
                                        }

                                        public init(count: Int, interval: Interval, type: `Type`) {
                                            self.count = count
                                            self.interval = interval
                                            self.type = type
                                        }

                                        public var asQuery: [(String, String?)] {
                                            let encoder = URLQueryEncoder()
                                            encoder.encode(count, forKey: "count")
                                            encoder.encode(interval, forKey: "interval")
                                            encoder.encode(type, forKey: "type")
                                            return encoder.items
                                        }
                                    }

                                    public enum B: String, Codable, CaseIterable {
                                        case empty = ""
                                    }

                                    public init(a: A? = nil, b: B? = nil) {
                                        self.a = a
                                        self.b = b
                                    }

                                    public var asQuery: [(String, String?)] {
                                        let encoder = URLQueryEncoder()
                                        encoder.encode(a, forKey: "a")
                                        encoder.encode(b, forKey: "b")
                                        return encoder.items
                                    }
                                }

                                public init(isEnabled: Bool? = nil, plan: Plan? = nil) {
                                    self.isEnabled = isEnabled
                                    self.plan = plan
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(isEnabled, forKey: "enabled")
                                    encoder.encode(plan, forKey: "plan")
                                    return encoder.items
                                }
                            }

                            public enum RequestThreeDSecure: String, Codable, CaseIterable {
                                case any
                                case automatic
                            }

                            public init(installments: Installments? = nil, requestThreeDSecure: RequestThreeDSecure? = nil) {
                                self.installments = installments
                                self.requestThreeDSecure = requestThreeDSecure
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(installments, forKey: "installments")
                                encoder.encode(requestThreeDSecure, forKey: "request_three_d_secure")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct CustomerBalance: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            /// Bank_transfer_param
                            public var bankTransfer: BankTransfer?
                            public var fundingType: String?

                            /// Bank_transfer_param
                            public struct BankTransfer: Encodable {
                                /// Eu_bank_transfer_param
                                public var euBankTransfer: EuBankTransfer?
                                public var type: String?

                                /// Eu_bank_transfer_param
                                public struct EuBankTransfer: Encodable {
                                    public var country: String

                                    public init(country: String) {
                                        self.country = country
                                    }

                                    public var asQuery: [(String, String?)] {
                                        let encoder = URLQueryEncoder()
                                        encoder.encode(country, forKey: "country")
                                        return encoder.items
                                    }
                                }

                                public init(euBankTransfer: EuBankTransfer? = nil, type: String? = nil) {
                                    self.euBankTransfer = euBankTransfer
                                    self.type = type
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(euBankTransfer, forKey: "eu_bank_transfer")
                                    encoder.encode(type, forKey: "type")
                                    return encoder.items
                                }
                            }

                            public init(bankTransfer: BankTransfer? = nil, fundingType: String? = nil) {
                                self.bankTransfer = bankTransfer
                                self.fundingType = fundingType
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(bankTransfer, forKey: "bank_transfer")
                                encoder.encode(fundingType, forKey: "funding_type")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Konbini: Encodable {
                        /// Invoice_payment_method_options_param
                        public var object: [String: AnyJSON]?
                        public var object2: Object2?

                        public enum Object2: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(object: [String: AnyJSON]? = nil, object2: Object2? = nil) {
                            self.object = object
                            self.object2 = object2
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(object, forKey: "object")
                            encoder.encode(object2, forKey: "object2")
                            return encoder.items
                        }
                    }

                    public struct UsBankAccount: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            /// Invoice_linked_account_options_param
                            public var financialConnections: FinancialConnections?
                            public var verificationMethod: VerificationMethod?

                            /// Invoice_linked_account_options_param
                            public struct FinancialConnections: Encodable {
                                public var permissions: [Permission]?

                                public enum Permission: String, Codable, CaseIterable {
                                    case balances
                                    case ownership
                                    case paymentMethod = "payment_method"
                                    case transactions
                                }

                                public init(permissions: [Permission]? = nil) {
                                    self.permissions = permissions
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(permissions, forKey: "permissions")
                                    return encoder.items
                                }
                            }

                            public enum VerificationMethod: String, Codable, CaseIterable {
                                case automatic
                                case instant
                                case microdeposits
                            }

                            public init(financialConnections: FinancialConnections? = nil, verificationMethod: VerificationMethod? = nil) {
                                self.financialConnections = financialConnections
                                self.verificationMethod = verificationMethod
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(financialConnections, forKey: "financial_connections")
                                encoder.encode(verificationMethod, forKey: "verification_method")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public init(acssDebit: AcssDebit? = nil, bancontact: Bancontact? = nil, card: Card? = nil, customerBalance: CustomerBalance? = nil, konbini: Konbini? = nil, usBankAccount: UsBankAccount? = nil) {
                        self.acssDebit = acssDebit
                        self.bancontact = bancontact
                        self.card = card
                        self.customerBalance = customerBalance
                        self.konbini = konbini
                        self.usBankAccount = usBankAccount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(acssDebit, forKey: "acss_debit")
                        encoder.encode(bancontact, forKey: "bancontact")
                        encoder.encode(card, forKey: "card")
                        encoder.encode(customerBalance, forKey: "customer_balance")
                        encoder.encode(konbini, forKey: "konbini")
                        encoder.encode(usBankAccount, forKey: "us_bank_account")
                        return encoder.items
                    }
                }

                public struct PaymentMethodTypes: Encodable {
                    public var placeholderItems: [PlaceholderItem]?
                    public var object: Object?

                    public enum PlaceholderItem: String, Codable, CaseIterable {
                        case achCreditTransfer = "ach_credit_transfer"
                        case achDebit = "ach_debit"
                        case acssDebit = "acss_debit"
                        case auBecsDebit = "au_becs_debit"
                        case bacsDebit = "bacs_debit"
                        case bancontact
                        case boleto
                        case card
                        case customerBalance = "customer_balance"
                        case fpx
                        case giropay
                        case grabpay
                        case ideal
                        case konbini
                        case link
                        case paynow
                        case promptpay
                        case sepaDebit = "sepa_debit"
                        case sofort
                        case usBankAccount = "us_bank_account"
                        case wechatPay = "wechat_pay"
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                        self.placeholderItems = placeholderItems
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(placeholderItems, forKey: "placeholderItems")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(defaultMandate: String? = nil, paymentMethodOptions: PaymentMethodOptions? = nil, paymentMethodTypes: PaymentMethodTypes? = nil) {
                    self.defaultMandate = defaultMandate
                    self.paymentMethodOptions = paymentMethodOptions
                    self.paymentMethodTypes = paymentMethodTypes
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(defaultMandate, forKey: "default_mandate")
                    encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                    encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                    return encoder.items
                }
            }

            /// Options for invoice PDF rendering.
            public struct RenderingOptions: Encodable {
                /// Rendering_options_param
                public var a: A?
                public var b: B?

                /// Rendering_options_param
                public struct A: Encodable {
                    public var amountTaxDisplay: AmountTaxDisplay?

                    public enum AmountTaxDisplay: String, Codable, CaseIterable {
                        case empty = ""
                        case excludeTax = "exclude_tax"
                        case includeInclusiveTax = "include_inclusive_tax"
                    }

                    public init(amountTaxDisplay: AmountTaxDisplay? = nil) {
                        self.amountTaxDisplay = amountTaxDisplay
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amountTaxDisplay, forKey: "amount_tax_display")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// If specified, the funds from the invoice will be transferred to the destination and the ID of the resulting transfer will be found on the invoice's charge. This will be unset if you POST an empty value.
            public struct TransferData: Encodable {
                /// Transfer_data_specs
                public var a: A?
                public var b: B?

                /// Transfer_data_specs
                public struct A: Encodable {
                    public var amount: Int?
                    public var destination: String

                    public init(amount: Int? = nil, destination: String) {
                        self.amount = amount
                        self.destination = destination
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amount, forKey: "amount")
                        encoder.encode(destination, forKey: "destination")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            public init(accountTaxIDs: AccountTaxIDs? = nil, applicationFeeAmount: Int? = nil, isAutoAdvance: Bool? = nil, automaticTax: AutomaticTax? = nil, collectionMethod: CollectionMethod? = nil, customFields: CustomFields? = nil, daysUntilDue: Int? = nil, defaultPaymentMethod: String? = nil, defaultSource: String? = nil, defaultTaxRates: DefaultTaxRates? = nil, description: String? = nil, discounts: Discounts? = nil, dueDate: Int? = nil, expand: [String]? = nil, footer: String? = nil, metadata: Metadata? = nil, onBehalfOf: OnBehalfOf? = nil, paymentSettings: PaymentSettings? = nil, renderingOptions: RenderingOptions? = nil, statementDescriptor: String? = nil, transferData: TransferData? = nil) {
                self.accountTaxIDs = accountTaxIDs
                self.applicationFeeAmount = applicationFeeAmount
                self.isAutoAdvance = isAutoAdvance
                self.automaticTax = automaticTax
                self.collectionMethod = collectionMethod
                self.customFields = customFields
                self.daysUntilDue = daysUntilDue
                self.defaultPaymentMethod = defaultPaymentMethod
                self.defaultSource = defaultSource
                self.defaultTaxRates = defaultTaxRates
                self.description = description
                self.discounts = discounts
                self.dueDate = dueDate
                self.expand = expand
                self.footer = footer
                self.metadata = metadata
                self.onBehalfOf = onBehalfOf
                self.paymentSettings = paymentSettings
                self.renderingOptions = renderingOptions
                self.statementDescriptor = statementDescriptor
                self.transferData = transferData
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(accountTaxIDs, forKey: "account_tax_ids")
                encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                encoder.encode(isAutoAdvance, forKey: "auto_advance")
                encoder.encode(automaticTax, forKey: "automatic_tax")
                encoder.encode(collectionMethod, forKey: "collection_method")
                encoder.encode(customFields, forKey: "custom_fields")
                encoder.encode(daysUntilDue, forKey: "days_until_due")
                encoder.encode(defaultPaymentMethod, forKey: "default_payment_method")
                encoder.encode(defaultSource, forKey: "default_source")
                encoder.encode(defaultTaxRates, forKey: "default_tax_rates")
                encoder.encode(description, forKey: "description")
                encoder.encode(discounts, forKey: "discounts")
                encoder.encode(dueDate, forKey: "due_date")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(footer, forKey: "footer")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(onBehalfOf, forKey: "on_behalf_of")
                encoder.encode(paymentSettings, forKey: "payment_settings")
                encoder.encode(renderingOptions, forKey: "rendering_options")
                encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                encoder.encode(transferData, forKey: "transfer_data")
                return encoder.items
            }
        }

        /// <p>Permanently deletes a one-off invoice draft. This cannot be undone. Attempts to delete invoices that are no longer in a draft state will fail; once an invoice has been finalized or if an invoice is for a subscription, it must be <a href="#void_invoice">voided</a>.</p>
        public var delete: Request<StripeKit.DeletedInvoice> {
            Request(method: "DELETE", url: path, id: "DeleteInvoicesInvoice")
        }
    }
}
