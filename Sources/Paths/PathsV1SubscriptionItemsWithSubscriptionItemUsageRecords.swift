// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths.SubscriptionItems.WithSubscriptionItem {
    public var usageRecords: UsageRecords {
        UsageRecords(path: path + "/usage_records")
    }

    public struct UsageRecords {
        /// Path: `/v1/subscription_items/{subscription_item}/usage_records`
        public let path: String

        /// <p>Creates a usage record for a specified subscription item and date, and fills it with a quantity.</p>
        /// 
        /// <p>Usage records provide <code>quantity</code> information that Stripe uses to track how much a customer is using your service. With usage information and the pricing model set up by the <a href="https://stripe.com/docs/billing/subscriptions/metered-billing">metered billing</a> plan, Stripe helps you send accurate invoices to your customers.</p>
        /// 
        /// <p>The default calculation for usage is to add up all the <code>quantity</code> values of the usage records within a billing period. You can change this default behavior with the billing planâ€™s <code>aggregate_usage</code> <a href="/docs/api/plans/create#create_plan-aggregate_usage">parameter</a>. When there is more than one usage record with the same timestamp, Stripe adds the <code>quantity</code> values together. In most cases, this is the desired resolution, however, you can change this behavior with the <code>action</code> parameter.</p>
        /// 
        /// <p>The default pricing model for metered billing is <a href="/docs/api/plans/object#plan_object-billing_scheme">per-unit pricing</a>. For finer granularity, you can configure metered billing to have a <a href="https://stripe.com/docs/billing/subscriptions/tiers">tiered pricing</a> model.</p>
        public func post(_ body: PostRequest) -> Request<StripeKit.UsageRecord> {
            Request(method: "POST", url: path, body: URLQueryEncoder.encode(body).percentEncodedQuery, id: "PostSubscriptionItemsSubscriptionItemUsageRecords")
        }

        public struct PostRequest: Encodable {
            /// Valid values are `increment` (default) or `set`. When using `increment` the specified `quantity` will be added to the usage at the specified timestamp. The `set` action will overwrite the usage quantity at that timestamp. If the subscription has [billing thresholds](https://stripe.com/docs/api/subscriptions/object#subscription_object-billing_thresholds), `increment` is the only allowed value.
            public var action: Action?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The usage quantity for the specified timestamp.
            public var quantity: Int
            /// The timestamp for the usage event. This timestamp must be within the current billing period of the subscription of the provided `subscription_item`, and must not be in the future. When passing `"now"`, Stripe records usage for the current time. Default is `"now"` if a value is not provided.
            public var timestamp: Timestamp?

            /// Valid values are `increment` (default) or `set`. When using `increment` the specified `quantity` will be added to the usage at the specified timestamp. The `set` action will overwrite the usage quantity at that timestamp. If the subscription has [billing thresholds](https://stripe.com/docs/api/subscriptions/object#subscription_object-billing_thresholds), `increment` is the only allowed value.
            public enum Action: String, Codable, CaseIterable {
                case increment
                case set
            }

            /// The timestamp for the usage event. This timestamp must be within the current billing period of the subscription of the provided `subscription_item`, and must not be in the future. When passing `"now"`, Stripe records usage for the current time. Default is `"now"` if a value is not provided.
            public struct Timestamp: Encodable {
                public var object: Object?
                public var int: Int?

                public enum Object: String, Codable, CaseIterable {
                    case now
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(action: Action? = nil, expand: [String]? = nil, quantity: Int, timestamp: Timestamp? = nil) {
                self.action = action
                self.expand = expand
                self.quantity = quantity
                self.timestamp = timestamp
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(action, forKey: "action")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(quantity, forKey: "quantity")
                encoder.encode(timestamp, forKey: "timestamp")
                return encoder.items
            }
        }
    }
}
